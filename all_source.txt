===== AdminConfig.h ===== 
#pragma once

#include <string>
#include <fstream>
#include <sstream>
#include <filesystem>
#include <mutex>

class AdminConfig
{
public:
    double   premiumPriceMbtc = 5.0;
    int      freeTradeLimit   = 10;
    std::string electrumPath  = "electrum";
    std::string electrumWallet;

    explicit AdminConfig(const std::string& path = "admin_config.json")
        : m_path(path)
    {
        load();
    }

    void load()
    {
        std::ifstream f(m_path);
        if (!f) return;
        std::string content((std::istreambuf_iterator<char>(f)), std::istreambuf_iterator<char>());
        premiumPriceMbtc = getNum(content, "premiumPriceMbtc", premiumPriceMbtc);
        freeTradeLimit   = (int)getNum(content, "freeTradeLimit", (double)freeTradeLimit);
        electrumPath     = getStr(content, "electrumPath", electrumPath);
        electrumWallet   = getStr(content, "electrumWallet", electrumWallet);
    }

    void save() const
    {
        std::ofstream f(m_path, std::ios::trunc);
        if (!f) return;
        f << "{\n"
          << "  \"premiumPriceMbtc\": " << premiumPriceMbtc << ",\n"
          << "  \"freeTradeLimit\": " << freeTradeLimit << ",\n"
          << "  \"electrumPath\": \"" << jsonEsc(electrumPath) << "\",\n"
          << "  \"electrumWallet\": \"" << jsonEsc(electrumWallet) << "\"\n"
          << "}\n";
    }

    double premiumPriceBtc() const { return premiumPriceMbtc * 0.001; }

    std::string electrumCmd() const
    {
        std::string cmd = electrumPath;
        if (!electrumWallet.empty())
            cmd += " -w \"" + electrumWallet + "\"";
        return cmd;
    }

private:
    std::string m_path;

    static std::string jsonEsc(const std::string& s)
    {
        std::string o;
        for (char c : s)
        {
            if (c == '"')       o += "\\\"";
            else if (c == '\\') o += "\\\\";
            else                o += c;
        }
        return o;
    }

    static std::string jsonUnesc(const std::string& s)
    {
        std::string o;
        for (size_t i = 0; i < s.size(); ++i)
        {
            if (s[i] == '\\' && i + 1 < s.size()) { ++i; o += s[i]; }
            else o += s[i];
        }
        return o;
    }

    static std::string getStr(const std::string& obj, const std::string& key, const std::string& def)
    {
        std::string needle = "\"" + key + "\"";
        auto pos = obj.find(needle);
        if (pos == std::string::npos) return def;
        pos = obj.find(':', pos + needle.size());
        if (pos == std::string::npos) return def;
        pos++;
        while (pos < obj.size() && (obj[pos] == ' ' || obj[pos] == '\t')) pos++;
        if (pos >= obj.size() || obj[pos] != '"') return def;
        pos++;
        auto end = pos;
        while (end < obj.size() && !(obj[end] == '"' && (end == 0 || obj[end - 1] != '\\'))) end++;
        return jsonUnesc(obj.substr(pos, end - pos));
    }

    static double getNum(const std::string& obj, const std::string& key, double def)
    {
        std::string needle = "\"" + key + "\"";
        auto pos = obj.find(needle);
        if (pos == std::string::npos) return def;
        pos = obj.find(':', pos + needle.size());
        if (pos == std::string::npos) return def;
        pos++;
        while (pos < obj.size() && (obj[pos] == ' ' || obj[pos] == '\t')) pos++;
        try { return std::stod(obj.substr(pos)); } catch (...) { return def; }
    }
};
===== AppContext.h ===== 
#pragma once

#include "UserManager.h"
#include "TradeDatabase.h"
#include "AdminConfig.h"
#include "cpp-httplib-master/httplib.h"

#include <mutex>
#include <map>
#include <memory>
#include <string>

struct AppContext
{
    UserManager& users;
    std::mutex&  dbMutex;
    TradeDatabase& defaultDb;
    AdminConfig& config;

    // Per-user database cache
    std::map<std::string, std::shared_ptr<TradeDatabase>> userDbs;

    // Get or create the TradeDatabase for a given username
    TradeDatabase& dbFor(const std::string& username)
    {
        auto it = userDbs.find(username);
        if (it != userDbs.end()) return *it->second;
        auto newDb = std::make_shared<TradeDatabase>(users.userDbDir(username));
        userDbs[username] = newDb;
        return *newDb;
    }

    // Resolve the database for the current request's authenticated user
    TradeDatabase& userDb(const httplib::Request& req)
    {
        auto user = currentUser(req);
        if (user.empty()) return defaultDb;
        return dbFor(user);
    }

    // Get the username of the currently logged-in user
    std::string currentUser(const httplib::Request& req) const
    {
        auto token = getSessionToken(req);
        return users.getSessionUser(token);
    }

    // Check if the current user has premium access
    bool isPremium(const httplib::Request& req) const
    {
        auto user = currentUser(req);
        return !user.empty() && (users.isAdmin(user) || users.isPremium(user));
    }

    bool isAdmin(const httplib::Request& req) const
    {
        auto user = currentUser(req);
        return !user.empty() && users.isAdmin(user);
    }

    // Check if user can add more trades (returns true if allowed)
    bool canAddTrade(const httplib::Request& req) const
    {
        if (isPremium(req)) return true;
        int count = (int)defaultDb.loadTrades().size();
        return count < config.freeTradeLimit;
    }

    int tradesRemaining(const httplib::Request& req) const
    {
        if (isPremium(req)) return 999999;
        int count = (int)defaultDb.loadTrades().size();
        int rem = config.freeTradeLimit - count;
        return rem > 0 ? rem : 0;
    }

    // Extract session token from request cookies
    static std::string getSessionToken(const httplib::Request& req)
    {
        if (!req.has_header("Cookie")) return "";
        auto cookies = req.get_header_value("Cookie");
        std::string prefix = std::string(UserManager::cookieName()) + "=";
        auto pos = cookies.find(prefix);
        if (pos == std::string::npos) return "";
        auto start = pos + prefix.size();
        auto end = cookies.find(';', start);
        return cookies.substr(start, end == std::string::npos ? end : end - start);
    }
};
===== ExitStrategyCalculator.h ===== 
#pragma once

#include "MultiHorizonEngine.h"
#include "ProfitCalculator.h"
#include <vector>
#include <cmath>

// Exit strategy: distributes a sigmoidal fraction of one trade's holdings
// across TP levels as pending sell orders.
//
//   effective = overhead + surplusRate
//   TP_price[i] = entry * (1 + effective * (i + 1))
//
// exitFraction in [0, 1]: total fraction of holdings to sell (e.g. 0.5 = 50%)
// steepness: controls sigmoid curve shape (0=uniform, 4=smooth S, 10+=step)
// riskCoefficient: shifts sigmoid center
//   0 = conservative -> sell most at early TP levels (lock in gains)
//   1 = aggressive   -> hold most for deeper TP levels (maximize upside)
//
// Cumulative sold follows a logistic sigmoid:
//   cumFrac(i) = sigmoid(steepness * (i - center))  normalized to [0,1]
//   sellQty[i] = sellableQty * (cumFrac[i+1] - cumFrac[i])

struct ExitLevel
{
    // -- Computed at generation time --
    int    index          = 0;
    double tpPrice        = 0.0;   // take-profit price per unit at this level
    double sellQty        = 0.0;   // quantity to sell at this level
    double sellFraction   = 0.0;   // fraction of sellable position (0-1)
    double sellValue      = 0.0;   // gross proceeds = tpPrice * sellQty
    double grossProfit    = 0.0;   // (tpPrice - entry) * sellQty
    double cumSold        = 0.0;   // cumulative quantity sold through this level

    // -- Per-level fees (filled progressively) --
    double levelBuyFee    = 0.0;   // amortized buy fee for this tranche (auto-set at generation)
    double levelSellFee   = 0.0;   // actual sell fee (set at execution time)
    double netProfit      = 0.0;   // grossProfit - levelBuyFee - levelSellFee
    double cumNetProfit   = 0.0;   // cumulative net profit locked in
};

class ExitStrategyCalculator
{
public:
    static std::vector<ExitLevel> generate(const Trade& trade,
                                           const HorizonParams& p,
                                           double riskCoefficient = 0.0,
                                           double exitFraction = 1.0,
                                           double steepness = 4.0)
    {
        double eo = MultiHorizonEngine::effectiveOverhead(trade, p);

        int N = p.horizonCount;
        if (N < 1) N = 1;

        double frac  = clamp01(exitFraction);
        double risk  = clamp01(riskCoefficient);
        double steep = (steepness > 0.0) ? steepness : 0.01;

        double sellableQty = trade.quantity * frac;

        // Sigmoid cumulative distribution
        // center = where the steepest part is
        // risk=0 -> center near start -> sell heavy early
        // risk=1 -> center near end   -> sell heavy late
        double center = risk * static_cast<double>(N - 1);

        std::vector<double> cumSigma(N + 1);
        for (int i = 0; i <= N; ++i)
        {
            double x = static_cast<double>(i) - 0.5;
            cumSigma[i] = sigmoid(steep * (x - center));
        }
        double lo = cumSigma[0], hi = cumSigma[N];
        for (int i = 0; i <= N; ++i)
            cumSigma[i] = (hi > lo) ? (cumSigma[i] - lo) / (hi - lo)
                                    : static_cast<double>(i) / static_cast<double>(N);

        double totalBuyFees = trade.buyFee;

        std::vector<ExitLevel> levels;
        levels.reserve(N);

        bool useMaxRisk = (p.maxRisk > 0.0 && p.maxRisk > trade.value);
        double mrMinF = 0, mrMaxF = 0, mrS0 = 0, mrSR = 1;
        if (useMaxRisk)
        {
            mrMinF = MultiHorizonEngine::computeOverhead(trade.value, trade.quantity, p);
            mrMaxF = (p.maxRisk / trade.value) - 1.0;
            if (mrMaxF < mrMinF) mrMaxF = mrMinF;
            mrS0 = sigmoid(-steep * 0.5);
            double mrS1 = sigmoid(steep * 0.5);
            mrSR = (mrS1 - mrS0 > 0) ? mrS1 - mrS0 : 1.0;
        }

        double cumSold = 0.0;
        double cumNet  = 0.0;

        for (int i = 0; i < N; ++i)
        {
            double factor;
            if (useMaxRisk)
            {
                double t = (N > 1) ? static_cast<double>(i) / static_cast<double>(N - 1)
                                   : 1.0;
                double norm = (sigmoid(steep * (t - 0.5)) - mrS0) / mrSR;
                factor = mrMinF + norm * (mrMaxF - mrMinF);
            }
            else
            {
                factor = eo * static_cast<double>(i + 1);
            }

            ExitLevel el;
            el.index        = i;
            el.tpPrice      = trade.value * (1.0 + factor);
            el.sellFraction = cumSigma[i + 1] - cumSigma[i];
            el.sellQty      = sellableQty * el.sellFraction;
            el.sellValue    = el.tpPrice * el.sellQty;
            el.grossProfit  = (el.tpPrice - trade.value) * el.sellQty;

            el.levelBuyFee  = totalBuyFees * el.sellFraction;
            el.levelSellFee = 0.0;
            el.netProfit    = el.grossProfit - el.levelBuyFee;

            cumSold += el.sellQty;
            cumNet  += el.netProfit;
            el.cumSold      = cumSold;
            el.cumNetProfit  = cumNet;

            levels.push_back(el);
        }

        return levels;
    }

    // Recompute netProfit and cumNetProfit after per-level fees are updated.
    static void applyFees(std::vector<ExitLevel>& levels)
    {
        double cumNet = 0.0;
        for (auto& el : levels)
        {
            el.netProfit = el.grossProfit - el.levelBuyFee - el.levelSellFee;
            cumNet += el.netProfit;
            el.cumNetProfit = cumNet;
        }
    }

private:
    static double sigmoid(double x)
    {
        return 1.0 / (1.0 + std::exp(-x));
    }

    static double clamp01(double v)
    {
        return (v < 0.0) ? 0.0 : (v > 1.0) ? 1.0 : v;
    }
};
===== HtmlHelpers.h ===== 
#pragma once

#include "Trade.h"
#include "ProfitCalculator.h"
#include "MultiHorizonEngine.h"
#include "cpp-httplib-master\httplib.h"

#include <string>
#include <sstream>
#include <iomanip>
#include <map>
#include <cmath>

// ---- HTML helpers ----
namespace html {

inline std::string esc(const std::string& s)
{
    std::string o;
    for (char c : s)
    {
        if (c == '<') o += "&lt;";
        else if (c == '>') o += "&gt;";
        else if (c == '&') o += "&amp;";
        else if (c == '"') o += "&quot;";
        else o += c;
    }
    return o;
}

inline std::string css()
{
    return
        "<style>"
        "*{box-sizing:border-box;}"
        "body{font-family:'Segoe UI',monospace;background:#0b1426;color:#cbd5e1;margin:0;padding:0;}"
        "nav{background:#0f1b2d;padding:10px 20px;border-bottom:1px solid #1a2744;display:flex;gap:8px;flex-wrap:wrap;}"
        "nav a{color:#7b97c4;text-decoration:none;font-size:0.85em;padding:4px 8px;border-radius:4px;}"
        "nav a:hover{background:#132035;}"
        ".container{max-width:1200px;margin:0 auto;padding:20px;}"
        "h1{color:#c9a44a;margin:0 0 12px 0;}"
        "h2{color:#64748b;border-bottom:1px solid #152238;padding-bottom:5px;}"
        "table{border-collapse:collapse;width:100%;margin:8px 0 18px 0;}"
        "th,td{border:1px solid #152238;padding:5px 8px;text-align:right;font-size:0.85em;}"
        "th{background:#0f1b2d;color:#c9a44a;text-align:left;}"
        "td{background:#0b1426;}tr:hover td{background:#0f1b2d;}"
        ".buy{color:#22c55e;font-weight:bold;}"
        ".sell{color:#ef4444;font-weight:bold;}"
        ".on{color:#22c55e;}.off{color:#475569;}"
        "form.card{background:#0f1b2d;border:1px solid #1a2744;border-radius:8px;padding:12px;margin:8px 0;}"
        "form.card h3{margin:0 0 8px 0;color:#c9a44a;font-size:0.95em;}"
        "label{display:inline-block;min-width:110px;color:#64748b;font-size:0.82em;}"
        "input,select{background:#0b1426;border:1px solid #1a2744;color:#cbd5e1;padding:4px 6px;"
        "border-radius:4px;margin:2px 4px 2px 0;font-family:inherit;font-size:0.85em;}"
        "input:focus,select:focus{border-color:#c9a44a;outline:none;}"
        "button,.btn{background:#166534;color:#fff;border:none;padding:5px 12px;border-radius:4px;"
        "cursor:pointer;font-size:0.82em;font-family:inherit;text-decoration:none;display:inline-block;}"
        "button:hover,.btn:hover{background:#15803d;}"
        ".btn-danger{background:#991b1b;}.btn-danger:hover{background:#ef4444;}"
        ".btn-sm{padding:2px 7px;font-size:0.78em;}"
        ".btn-warn{background:#a16207;}.btn-warn:hover{background:#ca8a04;}"
        ".row{display:flex;gap:12px;flex-wrap:wrap;}"
        ".stat{background:#0f1b2d;border:1px solid #1a2744;border-radius:8px;padding:10px 16px;min-width:140px;}"
        ".stat .lbl{color:#64748b;font-size:0.78em;}"
        ".stat .val{font-size:1.3em;color:#c9a44a;}"
        ".msg{background:#1e3a5f22;border:1px solid #2563eb;padding:6px 10px;border-radius:4px;margin:8px 0;color:#7b97c4;font-size:0.9em;}"
        ".err{background:#ef444422;border:1px solid #ef4444;color:#ef4444;}"
        ".iform{display:inline;}"
        "input[type=number]{width:90px;}"
        "input[type=text]{width:120px;}"
        ".forms-row{display:flex;gap:10px;flex-wrap:wrap;}"
        ".forms-row form.card{flex:1;min-width:280px;}"
        "p.empty{color:#475569;font-style:italic;}"
        ".child-row td{border-left:3px solid #1a2744;}"
        ".child-row td:first-child{padding-left:24px;color:#64748b;}"
        ".child-indent{color:#475569;font-size:0.8em;margin-right:4px;}"
        ".workflow{display:flex;margin:0 0 16px 0;}"
        ".wf-step{flex:1;text-align:center;padding:8px 0;font-size:0.82em;border-bottom:3px solid #152238;color:#475569;}"
        ".wf-step a{color:inherit;text-decoration:none;}"
        ".wf-step.active{border-color:#2563eb;color:#7b97c4;font-weight:bold;}"
        ".wf-step.done{border-color:#16a34a;color:#22c55e;}"
        ".wf-step.done a::before{content:'\2713  ';}"
        ".wf-step.locked{border-color:#152238;color:#1a2744;pointer-events:none;opacity:0.4;}"
        ".wf-step.locked a{color:#1a2744;cursor:default;}"
        ".calc-console{background:#0b1426;border:1px solid #1a2744;border-radius:6px;padding:12px 16px;"
        "margin:12px 0;font-family:'Consolas',monospace;font-size:0.78em;color:#64748b;overflow-x:auto;"
        "white-space:pre-wrap;line-height:1.6;}"
        ".calc-console .hd{color:#c9a44a;font-weight:bold;display:block;margin:6px 0 2px 0;"
        "border-bottom:1px solid #152238;padding-bottom:2px;}"
        ".calc-console .fm{color:#a78bfa;}"
        ".calc-console .vl{color:#c9a44a;}"
        ".calc-console .rs{color:#22c55e;font-weight:bold;}"
        "</style>";
}

inline std::string nav()
{
    return
        "<nav>"
        "<a href='/'>Dashboard</a>"
        "<a href='/trades'>Trades</a>"
        "<a href='/wallet'>Wallet</a>"
        "<a href='/portfolio'>Portfolio</a>"
        "<a href='/dca'>DCA</a>"
        "<a href='/profit'>Profit</a>"
        "<a href='/generate-horizons'>Horizons Gen</a>"
        "<a href='/price-check'>Price Check</a>"
        "<a href='/market-entry'>Entry Calc</a>"
        "<a href='/serial-generator'>Serial Gen</a>"
        "<a href='/exit-strategy'>Exit Calc</a>"
        "<a href='/pending-exits'>Pending Exits</a>"
        "<a href='/entry-points'>Entry Points</a>"
        "<a href='/profit-history'>Profit History</a>"
        "<a href='/params-history'>Params</a>"
        "<a href='/param-models'>Models</a>"
        "<a href='/pnl' style='color:#22c55e;'>&#9654; P&amp;L</a>"
        "<a href='/chart' style='color:#c9a44a;font-weight:bold;'>&#9733; Chart</a>"
        "<a href='/premium' style='color:#c9a44a;'>&#9733; Premium</a>"
        "<a href='/admin' style='color:#7b97c4;'>Admin</a>"
        "<a href='/wipe' style='color:#ef4444;'>Wipe</a>"
        "<a href='/logout' style='color:#94a3b8;margin-left:auto;'>Logout</a>"
        "</nav>";
}

inline std::string workflow(int step, bool canHorizons = true, bool canExits = true)
{
    static const char* labels[] = {"1. Market Entry", "2. Generate Horizons", "3. Exit Strategy"};
    static const char* hrefs[]  = {"/market-entry", "/generate-horizons", "/exit-strategy"};
    bool available[] = {true, canHorizons, canExits};
    std::string h = "<div class='workflow'>";
    for (int i = 0; i < 3; ++i)
    {
        const char* cls;
        if (!available[i])      cls = "wf-step locked";
        else if (i == step)     cls = "wf-step active";
        else if (i < step)      cls = "wf-step done";
        else                    cls = "wf-step";
        h += std::string("<div class='") + cls + "'><a href='" + hrefs[i] + "'>" + labels[i] + "</a></div>";
    }
    return h + "</div>";
}

inline std::string traceOverhead(double price, double quantity,
                                 const HorizonParams& p)
{
    std::ostringstream c;
    c << std::fixed << std::setprecision(8);
    double fc  = p.feeSpread * p.feeHedgingCoefficient * p.deltaTime;
    double num = fc * static_cast<double>(p.symbolCount);
    double ppq = (quantity > 0.0) ? price / quantity : 0.0;
    double den = ppq * p.portfolioPump + p.coefficientK;
    double oh  = (den != 0.0) ? num / den : 0.0;
    double surpComp = p.surplusRate * p.feeHedgingCoefficient * p.deltaTime;
    double feeComp  = p.feeSpread * p.feeHedgingCoefficient * p.deltaTime;
    double eo  = oh + surpComp + feeComp;
    c << "<span class='hd'>Overhead</span>"
      << "feeComponent = <span class='fm'>" << p.feeSpread << " &times; " << p.feeHedgingCoefficient << " &times; " << p.deltaTime << "</span>"
      << " = <span class='vl'>" << fc << "</span>\n"
      << "numerator    = <span class='fm'>" << fc << " &times; " << p.symbolCount << "</span>"
      << " = <span class='vl'>" << num << "</span>\n"
      << "pricePerQty  = <span class='fm'>" << price << " / " << quantity << "</span>"
      << " = <span class='vl'>" << ppq << "</span>\n"
      << "denominator  = <span class='fm'>" << ppq << " &times; " << p.portfolioPump << " + " << p.coefficientK << "</span>"
      << " = <span class='vl'>" << den << "</span>\n"
      << "<span class='rs'>overhead</span>     = " << num << " / " << den
      << " = <span class='rs'>" << oh << " (" << (oh * 100.0) << "%)</span>\n"
      << "surplusComp  = <span class='fm'>" << p.surplusRate << " &times; " << p.feeHedgingCoefficient << " &times; " << p.deltaTime << "</span>"
      << " = <span class='vl'>" << surpComp << "</span>\n"
      << "feeTimeComp  = <span class='fm'>" << p.feeSpread << " &times; " << p.feeHedgingCoefficient << " &times; " << p.deltaTime << "</span>"
      << " = <span class='vl'>" << feeComp << "</span>\n"
      << "<span class='rs'>effective</span>    = " << oh << " + " << surpComp << " + " << feeComp
      << " = <span class='rs'>" << eo << " (" << (eo * 100.0) << "%)</span>\n";
    if (p.maxRisk > 0.0)
        c << "maxRisk      = <span class='vl'>" << p.maxRisk << " (" << (p.maxRisk * 100.0) << "%)</span> (TP ceiling per entry)\n";
    if (p.minRisk > 0.0)
        c << "minRisk      = <span class='vl'>" << p.minRisk << " (" << (p.minRisk * 100.0) << "%)</span> (TP floor above BE)\n";
    return c.str();
}

inline std::string traceProfit(const Trade& t, double curPrice,
                               double buyFees, double sellFees,
                               const ProfitResult& r)
{
    std::ostringstream c;
    c << std::fixed << std::setprecision(8);
    bool isBuy = (t.type == TradeType::Buy);
    c << "<span class='hd'>Profit</span>"
      << "trade #" << t.tradeId << " " << t.symbol << " " << (isBuy ? "BUY" : "SELL")
      << "  entry=<span class='vl'>" << t.value << "</span>"
      << "  qty=<span class='vl'>" << t.quantity << "</span>"
      << "  current=<span class='vl'>" << curPrice << "</span>\n\n";
    if (isBuy)
        c << "<span class='fm'>grossProfit</span>  = (current - entry) &times; qty\n"
          << "               = (" << curPrice << " - " << t.value << ") &times; " << t.quantity
          << " = <span class='vl'>" << r.grossProfit << "</span>\n";
    else
        c << "<span class='fm'>grossProfit</span>  = (entry - current) &times; qty\n"
          << "               = (" << t.value << " - " << curPrice << ") &times; " << t.quantity
          << " = <span class='vl'>" << r.grossProfit << "</span>\n";
    double cost = t.value * t.quantity + buyFees;
    c << "<span class='fm'>netProfit</span>    = gross - buyFees - sellFees\n"
      << "               = " << r.grossProfit << " - " << buyFees << " - " << sellFees
      << " = <span class='rs'>" << r.netProfit << "</span>\n"
      << "<span class='fm'>cost</span>         = entry &times; qty + buyFees\n"
      << "               = " << t.value << " &times; " << t.quantity << " + " << buyFees
      << " = <span class='vl'>" << cost << "</span>\n"
      << "<span class='fm'>ROI</span>          = (net / cost) &times; 100\n"
      << "               = (" << r.netProfit << " / " << cost << ") &times; 100"
      << " = <span class='rs'>" << r.roi << "%</span>\n";
    return c.str();
}

inline std::string wrap(const std::string& title, const std::string& body)
{
    return "<!DOCTYPE html><html><head><meta charset='utf-8'>"
           "<meta name='viewport' content='width=device-width,initial-scale=1'>"
           "<title>" + esc(title) + " - Quant</title>" + css() +
           "</head><body>" + nav() +
           "<div class='container'>" + body + "</div></body></html>";
}

inline std::string msgBanner(const httplib::Request& req)
{
    if (!req.has_param("msg")) return "";
    return "<div class='msg'>" + esc(req.get_param_value("msg")) + "</div>";
}

inline std::string errBanner(const httplib::Request& req)
{
    if (!req.has_param("err")) return "";
    return "<div class='msg err'>" + esc(req.get_param_value("err")) + "</div>";
}

} // namespace html

// ---- Form body parser ----
inline std::string urlDec(const std::string& s)
{
    std::string o;
    for (size_t i = 0; i < s.size(); ++i)
    {
        if (s[i] == '+') o += ' ';
        else if (s[i] == '%' && i + 2 < s.size())
        {
            auto hv = [](char c) -> int {
                if (c >= '0' && c <= '9') return c - '0';
                if (c >= 'a' && c <= 'f') return c - 'a' + 10;
                if (c >= 'A' && c <= 'F') return c - 'A' + 10;
                return 0;
            };
            o += (char)(hv(s[i + 1]) * 16 + hv(s[i + 2]));
            i += 2;
        }
        else o += s[i];
    }
    return o;
}

inline std::string urlEnc(const std::string& s)
{
    std::ostringstream o;
    for (unsigned char c : s)
    {
        if (std::isalnum(c) || c == '-' || c == '_' || c == '.' || c == '~')
            o << c;
        else
            o << '%' << "0123456789ABCDEF"[c >> 4] << "0123456789ABCDEF"[c & 0xF];
    }
    return o.str();
}

inline std::map<std::string, std::string> parseForm(const std::string& body)
{
    std::map<std::string, std::string> m;
    std::istringstream ss(body);
    std::string pair;
    while (std::getline(ss, pair, '&'))
    {
        auto eq = pair.find('=');
        if (eq != std::string::npos)
            m[urlDec(pair.substr(0, eq))] = urlDec(pair.substr(eq + 1));
    }
    return m;
}

inline std::string fv(const std::map<std::string, std::string>& f, const std::string& k, const std::string& d = "")
{
    auto it = f.find(k);
    return it != f.end() ? it->second : d;
}

inline double fd(const std::map<std::string, std::string>& f, const std::string& k, double d = 0.0)
{
    auto s = fv(f, k);
    if (s.empty()) return d;
    try { return std::stod(s); } catch (...) { return d; }
}

inline int fi(const std::map<std::string, std::string>& f, const std::string& k, int d = 0)
{
    auto s = fv(f, k);
    if (s.empty()) return d;
    try { return std::stoi(s); } catch (...) { return d; }
}
===== HttpApi.h ===== 
#pragma once

#include "HtmlHelpers.h"
#include "TradeDatabase.h"
#include "UserManager.h"
#include "AdminConfig.h"
#include "AppContext.h"

#include "Routes_Auth.h"
#include "Routes_Core.h"
#include "Routes_Trades.h"
#include "Routes_Profit.h"
#include "Routes_Horizons.h"
#include "Routes_Entry.h"
#include "Routes_Exit.h"
#include "Routes_PriceCheck.h"
#include "Routes_SerialGen.h"
#include "Routes_Chart.h"
#include "Routes_Api.h"
#include "Routes_Admin.h"
#include "Routes_Premium.h"

#include <mutex>
#include <thread>
#include <iostream>

// ---- HTTP server ----
inline void startHttpApi(TradeDatabase& db, int port, std::mutex& dbMutex)
{
    static UserManager  users("users");
    static AdminConfig  config("admin_config.json");
    AppContext ctx{ users, dbMutex, db, config };

    httplib::Server svr;

    // Auth middleware — allow login/register/logout without session
    svr.set_pre_routing_handler([&](const httplib::Request& req, httplib::Response& res) {
        if (req.path == "/login" || req.path == "/register" || req.path == "/logout")
            return httplib::Server::HandlerResponse::Unhandled;
        auto user = ctx.currentUser(req);
        if (user.empty())
        {
            res.set_redirect("/login", 303);
            return httplib::Server::HandlerResponse::Handled;
        }
        return httplib::Server::HandlerResponse::Unhandled;
    });

    registerAuthRoutes(svr, ctx);
    registerCoreRoutes(svr, ctx);
    registerTradeRoutes(svr, ctx);
    registerProfitRoutes(svr, ctx);
    registerHorizonRoutes(svr, ctx);
    registerEntryRoutes(svr, ctx);
    registerExitRoutes(svr, ctx);
    registerPriceCheckRoutes(svr, ctx);
    registerSerialGenRoutes(svr, ctx);
    registerChartRoutes(svr, ctx);
    registerApiRoutes(svr, ctx);
    registerAdminRoutes(svr, ctx);
    registerPremiumRoutes(svr, ctx);

    std::cout << "  [HTTP] listening on http://localhost:" << port << "\n";
    svr.listen("0.0.0.0", port);
}
===== MarketEntryCalculator.h ===== 
#pragma once

#include "MultiHorizonEngine.h"
#include <vector>
#include <cmath>
#include <limits>

// Sigmoid-distributed entry price levels.
//
// When rangeAbove / rangeBelow are both 0 (default):
//   Level 0       = near 0  (deepest discount)
//   Level N-1     = currentPrice (shallowest, at market)
//
// When rangeAbove or rangeBelow > 0:
//   Level 0       = currentPrice - rangeBelow
//   Level N-1     = currentPrice + rangeAbove
//   Levels are sigmoid-interpolated between these bounds.
//   Higher price levels receive less funding (controlled by risk).
//
//   overhead  = computeOverhead(price, qty, params)
//   BreakEven = entryPrice * (1 + overhead)
//
// Funding allocation (portfolioPump = total funds):
//   riskCoefficient in [0, 1] warps a sigmoid funding curve:
//     0 = conservative -> sigmoid weights (more funds at higher prices)
//     0.5 = uniform distribution
//     1 = aggressive   -> inverse sigmoid (more funds at lower prices)
//   weight[i] = (1 - risk) * norm[i] + risk * (1 - norm[i])
//   allocation[i] = weight[i] / sum(weights) * totalFunds

struct EntryLevel
{
    int    index           = 0;
    double entryPrice      = 0.0;   // suggested entry price per unit
    double breakEven       = 0.0;   // price needed to break even after costs
    double costCoverage    = 0.0;   // how many layers of overhead are covered
    double potentialNet    = 0.0;   // net profit if price returns to currentPrice
    double funding         = 0.0;   // allocated funds for this level
    double fundingFraction = 0.0;   // fraction of total funds (0-1)
    double fundingQty      = 0.0;   // how many units this funding buys at entryPrice
};

class MarketEntryCalculator
{
public:
    static std::vector<EntryLevel> generate(double currentPrice,
                                            double quantity,
                                            const HorizonParams& p,
                                            double riskCoefficient = 0.0,
                                            double steepness = 6.0,
                                            double rangeAbove = 0.0,
                                            double rangeBelow = 0.0)
    {
        double oh = MultiHorizonEngine::computeOverhead(currentPrice, quantity, p);

        int N = p.horizonCount;
        if (N < 1) N = 1;
        if (steepness < 0.1) steepness = 0.1;

        double risk = (riskCoefficient < 0.0) ? 0.0
                    : (riskCoefficient > 1.0) ? 1.0
                    : riskCoefficient;

        // sigmoid helpers
        auto sigmoid = [](double x) { return 1.0 / (1.0 + std::exp(-x)); };
        double sig0 = sigmoid(-steepness * 0.5);
        double sig1 = sigmoid( steepness * 0.5);
        double sigRange = (sig1 - sig0 > 0.0) ? sig1 - sig0 : 1.0;

        // entry price range
        double priceLow, priceHigh;
        if (rangeAbove > 0.0 || rangeBelow > 0.0)
        {
            priceLow  = currentPrice - rangeBelow;
            if (priceLow < std::numeric_limits<double>::epsilon())
                priceLow = std::numeric_limits<double>::epsilon();
            priceHigh = currentPrice + rangeAbove;
        }
        else
        {
            priceLow  = 0.0;
            priceHigh = currentPrice;
        }

        // first pass: compute sigmoid-normalized values for each level
        std::vector<double> norm(N);
        for (int i = 0; i < N; ++i)
        {
            double t = (N > 1) ? static_cast<double>(i) / static_cast<double>(N - 1)
                               : 1.0;
            double sigVal = sigmoid(steepness * (t - 0.5));
            norm[i] = (sigVal - sig0) / sigRange;
        }

        // inverse-sigmoid funding warped by risk:
        //   risk=0   -> sigmoid weights (more funding near current price)
        //   risk=0.5 -> uniform
        //   risk=1   -> inverse sigmoid (more funding at deep discounts)
        std::vector<double> weights(N);
        double weightSum = 0.0;
        for (int i = 0; i < N; ++i)
        {
            weights[i] = (1.0 - risk) * norm[i] + risk * (1.0 - norm[i]);
            if (weights[i] < 1e-12) weights[i] = 1e-12;
            weightSum += weights[i];
        }

        std::vector<EntryLevel> levels;
        levels.reserve(N);

        for (int i = 0; i < N; ++i)
        {
            EntryLevel el;
            el.index        = i;
            el.costCoverage = static_cast<double>(i + 1);
            el.entryPrice   = priceLow + norm[i] * (priceHigh - priceLow);

            if (el.entryPrice < std::numeric_limits<double>::epsilon())
                el.entryPrice = std::numeric_limits<double>::epsilon();

            el.breakEven    = el.entryPrice * (1.0 + oh);

            el.fundingFraction = (weightSum != 0.0) ? weights[i] / weightSum : 0.0;
            el.funding         = p.portfolioPump * el.fundingFraction;
            el.fundingQty      = (el.entryPrice > 0.0) ? el.funding / el.entryPrice : 0.0;

            el.potentialNet = (currentPrice - el.entryPrice) * el.fundingQty;

            levels.push_back(el);
        }

        return levels;
    }
};
===== MultiHorizonEngine.h ===== 
#pragma once

#include "Trade.h"
#include <vector>
#include <cmath>

// TP/SL horizon formula:
//
//   overhead = (feeSpread * feeHedgingCoefficient * deltaTime)
//            * symbolCount
//            / ((price / quantity) * portfolioPump + coefficientK)
//
//   effective = overhead + surplusRate * feeHedgingCoefficient * deltaTime
//                        + feeSpread * feeHedgingCoefficient * deltaTime
//   positionDelta = (price * quantity) / portfolioPump
//
//   TP[i] = entry * qty * (1 + effective * (i + 1))
//   SL[i] = entry * qty * (1 - effective * (i + 1))
//
// levelTP is governed by maxRisk: when maxRisk = 0 the TP is 0 (no
// target).  As maxRisk increases the TP scales from break-even toward
// the ceiling, sigmoid-distributed across levels with half-steepness
// and (i+1)/(N+1) mapping so every level visibly responds.
// riskCoefficient warps the TP sigmoid to mirror funding allocation:
//   risk=0 ? forward sigmoid (higher prices get higher TP, conservative)
//   risk=0.5 ? uniform midpoint TP across all levels
//   risk=1 ? inverse sigmoid (lower prices get higher TP, aggressive)
//
// overhead scales fee spread by symbolCount and normalises against a
// denominator built from the per-unit price ratio and pump capital.
// feeHedgingCoefficient is a safety multiplier on the fee spread.
// coefficientK is an additive offset in the denominator.
// positionDelta is the portfolio weight of this trade.
// surplusRate is pure profit margin on top of break-even.
// horizonCount controls how many levels are generated.
//
// Absolute fees (buyFee / sellFee) are tracked per-trade on Trade
// and per-level on ExitLevel — not in HorizonParams.

struct HorizonParams
{
    double feeHedgingCoefficient      = 1.0;
    double portfolioPump              = 0.0;   // portfolio pump for time t
    int    symbolCount                = 1;     // number of symbols in portfolio
    double coefficientK               = 0.0;
    double feeSpread                  = 0.0;   // fee spread / slippage rate
    double deltaTime                  = 1.0;   // time delta
    double surplusRate                = 0.0;   // profit margin above break-even (e.g. 0.02 = 2%)
    int    horizonCount               = 1;     // how many TP/SL levels to generate
    bool   generateStopLosses         = false; // stop losses deactivated by default
    bool   allowShortTrades           = false; // short trades disabled by default
    double maxRisk                    = 0.0;   // max TP fraction above entry (0 = disabled)
    double minRisk                    = 0.0;   // min TP fraction above break-even (floor)
};

struct HorizonLevel
{
    int    index      = 0;
    double takeProfit = 0.0;
    double stopLoss   = 0.0;
    bool   stopLossActive = false;
};

class MultiHorizonEngine
{
public:
    static double computeOverhead(double price, double quantity, const HorizonParams& p)
    {
        double feeComponent = p.feeSpread * p.feeHedgingCoefficient * p.deltaTime;
        double numerator = feeComponent * static_cast<double>(p.symbolCount);
        double pricePerQty = (quantity > 0.0) ? price / quantity : 0.0;
        double denominator = pricePerQty * p.portfolioPump + p.coefficientK;
        return (denominator != 0.0) ? numerator / denominator : 0.0;
    }

    static double computeOverhead(const Trade& trade, const HorizonParams& p)
    {
        return computeOverhead(trade.value, trade.quantity, p);
    }

    static double effectiveOverhead(double price, double quantity, const HorizonParams& p)
    {
        return computeOverhead(price, quantity, p)
             + p.surplusRate * p.feeHedgingCoefficient * p.deltaTime
             + p.feeSpread * p.feeHedgingCoefficient * p.deltaTime;
    }

    static double effectiveOverhead(const Trade& trade, const HorizonParams& p)
    {
        return effectiveOverhead(trade.value, trade.quantity, p);
    }

    static double positionDelta(double price, double quantity, double portfolioPump)
    {
        return (portfolioPump > 0.0) ? (price * quantity) / portfolioPump : 0.0;
    }

    // Additional quantity the pump buys at this price.
    static double fundedQuantity(double price, const HorizonParams& p)
    {
        return (price > 0.0 && p.portfolioPump > 0.0) ? p.portfolioPump / price : 0.0;
    }

    static double totalQuantity(const Trade& trade, const HorizonParams& p)
    {
        return trade.quantity + fundedQuantity(trade.value, p);
    }

    static double sigmoid(double x)
    {
        return 1.0 / (1.0 + std::exp(-x));
    }

    // Per-level TP controlled by maxRisk.
    // maxRisk = 0  ->  TP = 0  (no take-profit target).
    // maxRisk > 0  ->  TP ceiling = referencePrice * (1 + maxRisk) for LONG.
    //
    // The TP floor (break-even) is always per-entry: entryPrice * (1 + eo).
    // The TP ceiling uses referencePrice (the highest entry in the set,
    // typically currentPrice or priceHigh) so the ceiling is fixed across
    // all levels.  This prevents a bell-curve when entry prices span a
    // wide range: the ceiling is constant, only the sigmoid norm varies.
    //
    // riskCoefficient warps the TP distribution (mirrors funding):
    //   risk=0   -> forward sigmoid (higher price levels get higher TP)
    //   risk=0.5 -> uniform (all levels get midpoint TP)
    //   risk=1   -> inverse sigmoid (lower price levels get higher TP)
    //
    // referencePrice: the highest entry price in the set (or currentPrice).
    //   When 0, falls back to entryPrice (legacy single-entry behaviour).
    static double levelTP(double entryPrice, double overhead, double eo,
                          const HorizonParams& p, double steepness,
                          int levelIndex, int totalLevels, bool isShort,
                          double riskCoefficient = 0.5,
                          double referencePrice = 0.0)
    {
        if (p.maxRisk <= 0.0)
            return 0.0;

        double risk = (riskCoefficient < 0.0) ? 0.0
                    : (riskCoefficient > 1.0) ? 1.0
                    : riskCoefficient;

        double tpRef = (referencePrice > 0.0) ? referencePrice : entryPrice;

        // Halve steepness so the TP sigmoid doesn't compress to the
        // same extremes as the already-sigmoidal entry prices.
        double steep = (steepness > 0.1) ? steepness * 0.5 : 0.1;
        double s0 = sigmoid(-steep * 0.5);
        double s1 = sigmoid( steep * 0.5);
        double sR = (s1 - s0 > 0.0) ? s1 - s0 : 1.0;
        // (i+1)/(N+1) keeps t inside (0,1) so every level moves.
        double t = static_cast<double>(levelIndex + 1)
                 / static_cast<double>(totalLevels + 1);
        double rawNorm = (sigmoid(steep * (t - 0.5)) - s0) / sR;

        // risk warps the curve: risk=1 inverts so lower prices get higher TP
        double norm = (1.0 - risk) * rawNorm + risk * (1.0 - rawNorm);

        if (!isShort)
        {
            double minTP = entryPrice * (1.0 + eo + p.minRisk);
            double maxTP = tpRef * (1.0 + p.maxRisk);
            if (maxTP <= minTP) return minTP;
            return minTP + norm * (maxTP - minTP);
        }
        else
        {
            double maxTP = entryPrice * (1.0 - eo - p.minRisk);
            if (maxTP < 0.0) maxTP = 0.0;
            double floorTP = tpRef * (1.0 - p.maxRisk);
            if (floorTP < 0.0) floorTP = 0.0;
            if (floorTP >= maxTP) return maxTP;
            return maxTP - norm * (maxTP - floorTP);
        }
    }

    static double levelSL(double entryPrice, double eo, bool isShort)
    {
        double sl = isShort ? entryPrice * (1.0 + eo) : entryPrice * (1.0 - eo);
        return (sl < 0.0) ? 0.0 : sl;
    }

    static std::vector<HorizonLevel> generate(const Trade& trade,
                                              const HorizonParams& p)
    {
        std::vector<HorizonLevel> levels;
        levels.reserve(p.horizonCount);

        double base     = trade.value * trade.quantity;
        double eo       = effectiveOverhead(trade, p);

        bool useMaxRisk = (p.maxRisk > 0.0 && p.maxRisk > trade.value);
        double mrMinF = 0, mrMaxF = 0, mrS0 = 0, mrSR = 1;
        if (useMaxRisk)
        {
            mrMinF = computeOverhead(trade, p);
            mrMaxF = (p.maxRisk / trade.value) - 1.0;
            if (mrMaxF < mrMinF) mrMaxF = mrMinF;
            double steep = 4.0;
            mrS0 = sigmoid(-steep * 0.5);
            double mrS1 = sigmoid(steep * 0.5);
            mrSR = (mrS1 - mrS0 > 0) ? mrS1 - mrS0 : 1.0;
        }

        for (int i = 0; i < p.horizonCount; ++i)
        {
            double factor;
            if (useMaxRisk)
            {
                double t = (p.horizonCount > 1)
                         ? static_cast<double>(i) / static_cast<double>(p.horizonCount - 1)
                         : 1.0;
                double norm = (sigmoid(4.0 * (t - 0.5)) - mrS0) / mrSR;
                factor = mrMinF + norm * (mrMaxF - mrMinF);
            }
            else
            {
                factor = eo * static_cast<double>(i + 1);
            }

            HorizonLevel hl;
            hl.index     = i;
            hl.takeProfit = base * (1.0 + factor);

            if (p.generateStopLosses && trade.type == TradeType::Buy)
            {
                hl.stopLoss       = base * (1.0 - factor);
                hl.stopLossActive = false;
            }

            levels.push_back(hl);
        }

        return levels;
    }

    // Convenience: apply the generated horizons back onto a Trade
    static void applyFirstHorizon(Trade& trade,
                                  const std::vector<HorizonLevel>& levels,
                                  bool activateStopLoss = false)
    {
        if (levels.empty() || trade.type != TradeType::Buy)
            return;

        trade.takeProfit     = levels.front().takeProfit;
        trade.stopLoss       = levels.front().stopLoss;
        trade.stopLossActive = activateStopLoss;
    }
};
===== ProfitCalculator.h ===== 
#pragma once

#include "Trade.h"

struct ProfitResult
{
    double grossProfit = 0.0;   // before fees
    double netProfit   = 0.0;   // after sell fees
    double roi         = 0.0;   // return on investment (%)
};

class ProfitCalculator
{
public:
    static ProfitResult calculate(const Trade& trade, double currentPrice,
                                  double buyFees, double sellFees)
    {
        return calculateForQty(trade, currentPrice, trade.quantity, buyFees, sellFees);
    }

    // Calculate on a specific quantity (e.g. remaining after partial sells)
    static ProfitResult calculateForQty(const Trade& trade, double currentPrice,
                                        double qty, double buyFees, double sellFees)
    {
        ProfitResult r{};

        if (trade.type == TradeType::Buy)
            r.grossProfit = (currentPrice - trade.value) * qty;
        else
            r.grossProfit = (trade.value - currentPrice) * qty;

        r.netProfit = r.grossProfit - buyFees - sellFees;

        double cost = trade.value * qty + buyFees;
        r.roi = (cost != 0.0) ? (r.netProfit / cost) * 100.0 : 0.0;

        return r;
    }

    // Overload using stored fees from the trade
    static ProfitResult calculate(const Trade& trade, double currentPrice)
    {
        return calculate(trade, currentPrice, trade.buyFee, trade.sellFee);
    }

    // Realized profit for a child sell against a parent buy entry
    static ProfitResult childProfit(const Trade& sell, double parentEntry)
    {
        ProfitResult r{};
        r.grossProfit = (sell.value - parentEntry) * sell.quantity;
        r.netProfit   = r.grossProfit - sell.buyFee - sell.sellFee;
        double cost   = parentEntry * sell.quantity + sell.buyFee;
        r.roi = (cost != 0.0) ? (r.netProfit / cost) * 100.0 : 0.0;
        return r;
    }
};
===== Routes_Admin.h ===== 
#pragma once

#include "AppContext.h"
#include "HtmlHelpers.h"
#include <sstream>

inline void registerAdminRoutes(httplib::Server& svr, AppContext& ctx)
{
    // ========== GET /admin ==========
    svr.Get("/admin", [&](const httplib::Request& req, httplib::Response& res) {
        if (!ctx.isAdmin(req)) { res.set_redirect("/?err=Admin+only", 303); return; }

        std::ostringstream pg;
        pg << html::msgBanner(req) << html::errBanner(req);
        pg << "<h1>Admin Panel</h1>";

        // config form
        pg << "<form class='card' method='POST' action='/admin/config'>"
              "<h3>Platform Settings</h3>"
              "<label>Premium Price (mBTC)</label>"
              "<input type='number' name='premiumPriceMbtc' step='any' value='"
           << ctx.config.premiumPriceMbtc << "'><br>"
              "<label>Free Trade Limit</label>"
              "<input type='number' name='freeTradeLimit' value='"
           << ctx.config.freeTradeLimit << "'><br>"
              "<label>Electrum CLI Path</label>"
              "<input type='text' name='electrumPath' value='"
           << html::esc(ctx.config.electrumPath) << "'><br>"
              "<label>Electrum Wallet File</label>"
              "<input type='text' name='electrumWallet' value='"
           << html::esc(ctx.config.electrumWallet) << "'>"
              "<div style='color:#64748b;font-size:0.78em;'>Leave empty for default wallet</div>"
              "<button>Save Config</button></form>";

        // user list
        pg << "<h2>Users</h2>"
              "<table><tr><th>Username</th><th>Email</th><th>Created</th>"
              "<th>Premium</th><th>Admin</th><th>Actions</th></tr>";
        for (const auto& u : ctx.users.users())
        {
            bool adm = ctx.users.isAdmin(u.username);
            pg << "<tr><td>" << html::esc(u.username) << "</td>"
               << "<td>" << html::esc(u.email) << "</td>"
               << "<td>" << html::esc(u.createdAt) << "</td>"
               << "<td class='" << (u.premium ? "buy" : "off") << "'>"
               << (u.premium ? "YES" : "NO") << "</td>"
               << "<td>" << (adm ? "ADMIN" : "-") << "</td>"
               << "<td>";
            if (!adm)
            {
                pg << "<form class='iform' method='POST' action='/admin/toggle-premium'>"
                   << "<input type='hidden' name='username' value='" << html::esc(u.username) << "'>"
                   << "<button class='btn-sm " << (u.premium ? "btn-warn" : "btn-sm") << "'>"
                   << (u.premium ? "Revoke" : "Grant") << "</button></form>";
            }
            pg << "</td></tr>";
        }
        pg << "</table>";

        // pending payments
        const auto& pp = ctx.users.pendingPayments();
        if (!pp.empty())
        {
            pg << "<h2>Pending Payments</h2>"
                  "<table><tr><th>User</th><th>Address</th><th>Required BTC</th>"
                  "<th>Created</th></tr>";
            for (const auto& p : pp)
            {
                pg << "<tr><td>" << html::esc(p.username) << "</td>"
                   << "<td style='font-family:monospace;font-size:0.8em;'>"
                   << html::esc(p.btcAddress) << "</td>"
                   << "<td>" << std::fixed << std::setprecision(8) << p.requiredBtc << "</td>"
                   << "<td>" << html::esc(p.createdAt) << "</td></tr>";
            }
            pg << "</table>";
        }

        res.set_content(html::wrap("Admin", pg.str()), "text/html");
    });

    // ========== POST /admin/config ==========
    svr.Post("/admin/config", [&](const httplib::Request& req, httplib::Response& res) {
        if (!ctx.isAdmin(req)) { res.set_redirect("/", 303); return; }
        auto f = parseForm(req.body);
        ctx.config.premiumPriceMbtc = fd(f, "premiumPriceMbtc", ctx.config.premiumPriceMbtc);
        ctx.config.freeTradeLimit   = fi(f, "freeTradeLimit", ctx.config.freeTradeLimit);
        auto ep = fv(f, "electrumPath");
        if (!ep.empty()) ctx.config.electrumPath = ep;
        ctx.config.electrumWallet = fv(f, "electrumWallet");
        ctx.config.save();
        res.set_redirect("/admin?msg=Config+saved", 303);
    });

    // ========== POST /admin/toggle-premium ==========
    svr.Post("/admin/toggle-premium", [&](const httplib::Request& req, httplib::Response& res) {
        if (!ctx.isAdmin(req)) { res.set_redirect("/", 303); return; }
        auto f = parseForm(req.body);
        std::string username = fv(f, "username");
        if (username.empty() || ctx.users.isAdmin(username))
        {
            res.set_redirect("/admin?err=Invalid+user", 303);
            return;
        }
        bool current = ctx.users.isPremium(username);
        ctx.users.setPremium(username, !current);
        res.set_redirect("/admin?msg=" + urlEnc(username) + "+premium+" +
            (current ? "revoked" : "granted"), 303);
    });
}
===== Routes_Api.h ===== 
#pragma once

#include "AppContext.h"
#include "HtmlHelpers.h"
#include "MarketEntryCalculator.h"
#include <mutex>
#include <cmath>
#include <limits>

inline void registerApiRoutes(httplib::Server& svr, AppContext& ctx)
{
    auto& db = ctx.defaultDb;
    auto& dbMutex = ctx.dbMutex;

    // ========== JSON API: GET /api/trades ==========
    svr.Get("/api/trades", [&](const httplib::Request&, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto trades = db.loadTrades();
        std::ostringstream j;
        j << std::fixed << std::setprecision(17) << "[";
        bool first = true;
        for (const auto& t : trades)
        {
            if (!first) j << ",";
            first = false;
            double sold = db.soldQuantityForParent(t.tradeId);
            bool isBuy = (t.type == TradeType::Buy);
            double tpPrice = (isBuy && t.quantity > 0 && t.takeProfit > 0) ? t.takeProfit / t.quantity : 0;
            double slPrice = (isBuy && t.quantity > 0 && t.stopLoss > 0) ? t.stopLoss / t.quantity : 0;
            j << "{\"id\":" << t.tradeId
              << ",\"symbol\":\"" << t.symbol << "\""
              << ",\"type\":\"" << (isBuy ? "Buy" : "Sell") << "\""
              << ",\"price\":" << t.value
              << ",\"qty\":" << t.quantity
              << ",\"sold\":" << sold
              << ",\"remaining\":" << (t.quantity - sold)
              << ",\"buyFee\":" << t.buyFee
              << ",\"sellFee\":" << t.sellFee
              << ",\"tp\":" << t.takeProfit
              << ",\"sl\":" << t.stopLoss
              << ",\"tpPrice\":" << tpPrice
              << ",\"slPrice\":" << slPrice
              << ",\"slActive\":" << (t.stopLossActive ? "true" : "false")
              << ",\"parentId\":" << t.parentTradeId
              << "}";
        }
        j << "]";
        res.set_header("Access-Control-Allow-Origin", "*");
        res.set_content(j.str(), "application/json");
    });

    // ========== JSON API: GET /api/entry-points ==========
    svr.Get("/api/entry-points", [&](const httplib::Request&, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto pts = db.loadEntryPoints();
        std::ostringstream j;
        j << std::fixed << std::setprecision(17) << "[";
        bool first = true;
        for (const auto& ep : pts)
        {
            if (!first) j << ",";
            first = false;
            j << "{\"id\":" << ep.entryId
              << ",\"symbol\":\"" << ep.symbol << "\""
              << ",\"level\":" << ep.levelIndex
              << ",\"entry\":" << ep.entryPrice
              << ",\"breakEven\":" << ep.breakEven
              << ",\"funding\":" << ep.funding
              << ",\"qty\":" << ep.fundingQty
              << ",\"tp\":" << ep.exitTakeProfit
              << ",\"sl\":" << ep.exitStopLoss
              << ",\"isShort\":" << (ep.isShort ? "true" : "false")
              << ",\"traded\":" << (ep.traded ? "true" : "false")
              << ",\"linkedTrade\":" << ep.linkedTradeId
              << "}";
        }
        j << "]";
        res.set_header("Access-Control-Allow-Origin", "*");
        res.set_content(j.str(), "application/json");
    });

    // ========== JSON API: GET /api/pending-exits ==========
    svr.Get("/api/pending-exits", [&](const httplib::Request&, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto orders = db.loadPendingExits();
        std::ostringstream j;
        j << std::fixed << std::setprecision(17) << "[";
        bool first = true;
        for (const auto& pe : orders)
        {
            if (!first) j << ",";
            first = false;
            j << "{\"orderId\":" << pe.orderId
              << ",\"symbol\":\"" << pe.symbol << "\""
              << ",\"tradeId\":" << pe.tradeId
              << ",\"trigger\":" << pe.triggerPrice
              << ",\"qty\":" << pe.sellQty
              << ",\"level\":" << pe.levelIndex
              << "}";
        }
        j << "]";
        res.set_header("Access-Control-Allow-Origin", "*");
        res.set_content(j.str(), "application/json");
    });

    // ========== JSON API: GET /api/horizons?tradeId=N ==========
    svr.Get("/api/horizons", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        int id = 0;
        try { id = std::stoi(req.get_param_value("tradeId")); } catch (...) {}
        auto trades = db.loadTrades();
        auto* tp = db.findTradeById(trades, id);
        std::ostringstream j;
        j << std::fixed << std::setprecision(17) << "[";
        if (tp)
        {
            auto levels = db.loadHorizonLevels(tp->symbol, id);
            bool first = true;
            for (const auto& lv : levels)
            {
                if (!first) j << ",";
                first = false;
                double tpu = tp->quantity > 0 ? lv.takeProfit / tp->quantity : 0;
                double slu = (tp->quantity > 0 && lv.stopLoss > 0) ? lv.stopLoss / tp->quantity : 0;
                j << "{\"index\":" << lv.index
                  << ",\"tp\":" << lv.takeProfit
                  << ",\"tpPrice\":" << tpu
                  << ",\"sl\":" << lv.stopLoss
                  << ",\"slPrice\":" << slu
                  << ",\"slActive\":" << (lv.stopLossActive ? "true" : "false")
                  << "}";
            }
        }
        j << "]";
        res.set_header("Access-Control-Allow-Origin", "*");
        res.set_content(j.str(), "application/json");
    });

    // ========== JSON API: POST /api/calc/entry ï¿½ live entry calculation ==========
    svr.Post("/api/calc/entry", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        std::string sym = normalizeSymbol(fv(f, "symbol"));
        double cur = fd(f, "currentPrice");
        double qty = fd(f, "quantity");
        double risk = fd(f, "risk");
        double steepness = fd(f, "steepness", 6.0);
        bool isShort = (fv(f, "isShort") == "1");
        int fundMode = fi(f, "fundMode", 1);
        double rangeAbove = fd(f, "rangeAbove");
        double rangeBelow = fd(f, "rangeBelow");
        HorizonParams p;
        p.horizonCount = fi(f, "levels", 4);
        p.feeHedgingCoefficient = fd(f, "feeHedgingCoefficient", 1.0);
        p.portfolioPump = fd(f, "portfolioPump");
        p.symbolCount = fi(f, "symbolCount", 1);
        p.coefficientK = fd(f, "coefficientK");
        p.feeSpread = fd(f, "feeSpread");
        p.deltaTime = fd(f, "deltaTime", 1.0);
        p.surplusRate = fd(f, "surplusRate");
        p.maxRisk = fd(f, "maxRisk");
        p.minRisk = fd(f, "minRisk");

        double walBal = db.loadWalletBalance();
        double availableFunds = p.portfolioPump;
        if (fundMode == 2) availableFunds += walBal;
        HorizonParams entryParams = p;
        entryParams.portfolioPump = availableFunds;

        std::ostringstream j;
        j << std::fixed << std::setprecision(17);
        if (sym.empty() || cur <= 0 || qty <= 0) { j << "{\"error\":true}"; }
        else
        {
            auto levels = MarketEntryCalculator::generate(cur, qty, entryParams, risk, steepness, rangeAbove, rangeBelow);
            double eo = MultiHorizonEngine::effectiveOverhead(cur, qty, p);
            double overhead = MultiHorizonEngine::computeOverhead(cur, qty, p);
            double tpRef = (rangeAbove > 0.0 || rangeBelow > 0.0) ? cur + rangeAbove : cur;

            j << "{\"symbol\":\"" << sym << "\",\"currentPrice\":" << cur
              << ",\"overhead\":" << overhead << ",\"effective\":" << eo
              << ",\"isShort\":" << (isShort ? "true" : "false")
              << ",\"levels\":[";
            bool first = true;
            for (const auto& el : levels)
            {
                if (!first) j << ",";
                first = false;
                double exitTP = MultiHorizonEngine::levelTP(el.entryPrice, overhead, eo, p, steepness, el.index, p.horizonCount, isShort, risk, tpRef);
                double exitSL = MultiHorizonEngine::levelSL(el.entryPrice, eo, isShort);
                j << "{\"index\":" << el.index
                  << ",\"entry\":" << el.entryPrice
                  << ",\"breakEven\":" << el.breakEven
                  << ",\"tp\":" << exitTP
                  << ",\"sl\":" << exitSL
                  << ",\"funding\":" << el.funding
                  << ",\"fundPct\":" << (el.fundingFraction * 100)
                  << ",\"qty\":" << el.fundingQty
                  << ",\"net\":" << el.potentialNet
                  << "}";
            }
            j << "]}";
        }
        res.set_header("Access-Control-Allow-Origin", "*");
        res.set_content(j.str(), "application/json");
    });

    // ========== JSON API: POST /api/calc/serial ï¿½ live serial calculation ==========
    svr.Post("/api/calc/serial", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        std::string sym = normalizeSymbol(fv(f, "symbol"));
        double cur = fd(f, "currentPrice");
        double qty = fd(f, "quantity");
        double risk = fd(f, "risk");
        double steepness = fd(f, "steepness", 6.0);
        bool isShort = (fv(f, "isShort") == "1");
        int fundMode = fi(f, "fundMode", 1);
        bool genSL = (fv(f, "generateStopLosses") == "1");
        double rangeAbove = fd(f, "rangeAbove");
        double rangeBelow = fd(f, "rangeBelow");

        HorizonParams p;
        p.horizonCount = fi(f, "levels", 4);
        p.feeHedgingCoefficient = fd(f, "feeHedgingCoefficient", 1.0);
        p.portfolioPump = fd(f, "portfolioPump");
        p.symbolCount = fi(f, "symbolCount", 1);
        p.coefficientK = fd(f, "coefficientK");
        p.feeSpread = fd(f, "feeSpread");
        p.deltaTime = fd(f, "deltaTime", 1.0);
        p.surplusRate = fd(f, "surplusRate");
        p.maxRisk = fd(f, "maxRisk");
        p.minRisk = fd(f, "minRisk");

        double walBal = db.loadWalletBalance();
        double availableFunds = p.portfolioPump;
        if (fundMode == 2) availableFunds += walBal;

        std::ostringstream j;
        j << std::fixed << std::setprecision(17);
        if (sym.empty() || cur <= 0 || qty <= 0) { j << "{\"error\":true}"; }
        else
        {
            int N = p.horizonCount;
            if (N < 1) N = 1;
            if (steepness < 0.1) steepness = 0.1;

            auto sigmoid = [](double x) { return 1.0 / (1.0 + std::exp(-x)); };
            double sig0 = sigmoid(-steepness * 0.5);
            double sig1 = sigmoid(steepness * 0.5);
            double sigRange = (sig1 - sig0 > 0) ? sig1 - sig0 : 1.0;

            double priceLow, priceHigh;
            if (rangeAbove > 0.0 || rangeBelow > 0.0)
            {
                priceLow = cur - rangeBelow;
                if (priceLow < 1e-18) priceLow = 1e-18;
                priceHigh = cur + rangeAbove;
            }
            else
            {
                priceLow = 0.0;
                priceHigh = cur;
            }

            std::vector<double> norm(N);
            for (int i = 0; i < N; ++i)
            {
                double t = (N > 1) ? static_cast<double>(i) / static_cast<double>(N - 1) : 1.0;
                double sigVal = sigmoid(steepness * (t - 0.5));
                norm[i] = (sigVal - sig0) / sigRange;
            }

            double riskClamped = (risk < 0) ? 0 : (risk > 1) ? 1 : risk;
            std::vector<double> weights(N);
            double weightSum = 0;
            for (int i = 0; i < N; ++i)
            {
                weights[i] = (1.0 - riskClamped) * norm[i] + riskClamped * (1.0 - norm[i]);
                if (weights[i] < 1e-12) weights[i] = 1e-12;
                weightSum += weights[i];
            }

            double eo = MultiHorizonEngine::effectiveOverhead(cur, qty, p);
            double overhead = MultiHorizonEngine::computeOverhead(cur, qty, p);

            j << "{\"symbol\":\"" << sym << "\",\"currentPrice\":" << cur
              << ",\"overhead\":" << overhead << ",\"effective\":" << eo
              << ",\"isShort\":" << (isShort ? "true" : "false")
              << ",\"levels\":[";
            bool first = true;
            for (int i = 0; i < N; ++i)
            {
                double entryPrice = priceLow + norm[i] * (priceHigh - priceLow);
                if (entryPrice < 1e-18) entryPrice = 1e-18;

                double tpPrice = MultiHorizonEngine::levelTP(entryPrice, overhead, eo, p, steepness, i, N, isShort, riskClamped, priceHigh);
                double slPrice = MultiHorizonEngine::levelSL(entryPrice, eo, isShort);

                double fundFrac = (weightSum > 0) ? weights[i] / weightSum : 0;
                double funding = availableFunds * fundFrac;
                double fundQty = funding / entryPrice;
                double breakEven = entryPrice * (1.0 + overhead);

                if (!first) j << ",";
                first = false;
                j << "{\"index\":" << i
                  << ",\"entry\":" << entryPrice
                  << ",\"breakEven\":" << breakEven
                  << ",\"tp\":" << tpPrice
                  << ",\"sl\":" << (genSL ? slPrice : 0.0)
                  << ",\"funding\":" << funding
                  << ",\"fundPct\":" << (fundFrac * 100)
                  << ",\"qty\":" << fundQty
                  << "}";
            }
            j << "]}";
        }
        res.set_header("Access-Control-Allow-Origin", "*");
        res.set_content(j.str(), "application/json");
    });

    // ========== JSON API: GET /api/param-models ==========
    svr.Get("/api/param-models", [&](const httplib::Request&, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto models = db.loadParamModels();
        std::ostringstream j;
        j << std::fixed << std::setprecision(17) << "[";
        bool first = true;
        for (const auto& m : models)
        {
            if (!first) j << ",";
            first = false;
            j << "{\"name\":\"" << html::esc(m.name) << "\""
              << ",\"levels\":" << m.levels
              << ",\"risk\":" << m.risk
              << ",\"steepness\":" << m.steepness
              << ",\"feeHedgingCoefficient\":" << m.feeHedgingCoefficient
              << ",\"portfolioPump\":" << m.portfolioPump
              << ",\"symbolCount\":" << m.symbolCount
              << ",\"coefficientK\":" << m.coefficientK
              << ",\"feeSpread\":" << m.feeSpread
              << ",\"deltaTime\":" << m.deltaTime
              << ",\"surplusRate\":" << m.surplusRate
              << ",\"maxRisk\":" << m.maxRisk
              << ",\"minRisk\":" << m.minRisk
              << ",\"isShort\":" << (m.isShort ? "true" : "false")
              << ",\"fundMode\":" << m.fundMode
              << ",\"generateStopLosses\":" << (m.generateStopLosses ? "true" : "false")
              << ",\"rangeAbove\":" << m.rangeAbove
              << ",\"rangeBelow\":" << m.rangeBelow
              << "}";
        }
        j << "]";
        res.set_header("Access-Control-Allow-Origin", "*");
        res.set_content(j.str(), "application/json");
    });

    // ========== JSON API: POST /api/param-models ï¿½ save a model ==========
    svr.Post("/api/param-models", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        try {
        auto f = parseForm(req.body);
        TradeDatabase::ParamModel m;
        m.name = fv(f, "name");
        if (m.name.empty()) { res.status = 400; res.set_content("{\"error\":\"name required\"}", "application/json"); return; }
        m.levels = fi(f, "levels", 4);
        m.risk = fd(f, "risk", 0.5);
        m.steepness = fd(f, "steepness", 6.0);
        m.feeHedgingCoefficient = fd(f, "feeHedgingCoefficient", 1.0);
        m.portfolioPump = fd(f, "portfolioPump");
        m.symbolCount = fi(f, "symbolCount", 1);
        m.coefficientK = fd(f, "coefficientK");
        m.feeSpread = fd(f, "feeSpread");
        m.deltaTime = fd(f, "deltaTime", 1.0);
        m.surplusRate = fd(f, "surplusRate");
        m.maxRisk = fd(f, "maxRisk");
        m.minRisk = fd(f, "minRisk");
        m.isShort = (fv(f, "isShort") == "1");
        m.fundMode = fi(f, "fundMode", 1);
        m.generateStopLosses = (fv(f, "generateStopLosses") == "1");
        m.rangeAbove = fd(f, "rangeAbove");
        m.rangeBelow = fd(f, "rangeBelow");
        db.addParamModel(m);
        res.set_header("Access-Control-Allow-Origin", "*");
        res.set_content("{\"ok\":true}", "application/json");
        } catch (const std::exception& ex) {
            res.status = 500;
            res.set_header("Access-Control-Allow-Origin", "*");
            res.set_content(std::string("{\"error\":\"") + ex.what() + "\"}", "application/json");
        }
    });

    // ========== JSON API: DELETE /api/param-models ï¿½ delete a model ==========
    svr.Delete("/api/param-models", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        std::string name;
        if (req.has_param("name")) name = req.get_param_value("name");
        if (name.empty()) { res.status = 400; res.set_content("{\"error\":\"name required\"}", "application/json"); return; }
        db.removeParamModel(name);
        res.set_header("Access-Control-Allow-Origin", "*");
        res.set_content("{\"ok\":true}", "application/json");
    });

    // ========== JSON API: GET /api/pnl ==========
    svr.Get("/api/pnl", [&](const httplib::Request&, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto entries = db.loadPnl();
        std::ostringstream j;
        j << std::fixed << std::setprecision(17) << "[";
        bool first = true;
        for (const auto& e : entries)
        {
            if (!first) j << ",";
            first = false;
            j << "{\"ts\":" << e.timestamp
              << ",\"symbol\":\"" << e.symbol << "\""
              << ",\"sellId\":" << e.sellTradeId
              << ",\"parentId\":" << e.parentTradeId
              << ",\"entry\":" << e.entryPrice
              << ",\"sell\":" << e.sellPrice
              << ",\"qty\":" << e.quantity
              << ",\"gross\":" << e.grossProfit
              << ",\"net\":" << e.netProfit
              << ",\"cum\":" << e.cumProfit
              << "}";
        }
        j << "]";
        res.set_header("Access-Control-Allow-Origin", "*");
        res.set_content(j.str(), "application/json");
    });

    // ========== GET /param-models â€” HTML management page ==========
    svr.Get("/param-models", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << html::msgBanner(req) << html::errBanner(req);
        h << "<h1>Parameter Models</h1>";
        auto models = db.loadParamModels();
        if (models.empty()) { h << "<p class='empty'>(no saved models)</p>"; }
        else
        {
            h << "<table><tr><th>Name</th><th>Levels</th><th>Risk</th><th>Steepness</th>"
                 "<th>Hedging</th><th>Pump</th><th>Spread</th><th>dT</th>"
                 "<th>Surplus</th><th>MaxRisk</th><th>MinRisk</th>"
                 "<th>Dir</th><th>Range&uarr;</th><th>Range&darr;</th><th>Actions</th></tr>";
            for (const auto& m : models)
            {
                h << "<tr><td>" << html::esc(m.name) << "</td>"
                  << "<td>" << m.levels << "</td>"
                  << "<td>" << m.risk << "</td>"
                  << "<td>" << m.steepness << "</td>"
                  << "<td>" << m.feeHedgingCoefficient << "</td>"
                  << "<td>" << m.portfolioPump << "</td>"
                  << "<td>" << m.feeSpread << "</td>"
                  << "<td>" << m.deltaTime << "</td>"
                  << "<td>" << m.surplusRate << "</td>"
                  << "<td>" << m.maxRisk << "</td>"
                  << "<td>" << m.minRisk << "</td>"
                  << "<td>" << (m.isShort ? "SHORT" : "LONG") << "</td>"
                  << "<td>" << m.rangeAbove << "</td>"
                  << "<td>" << m.rangeBelow << "</td>"
                  << "<td><form class='iform' method='POST' action='/delete-param-model'>"
                  << "<input type='hidden' name='name' value='" << html::esc(m.name) << "'>"
                  << "<button class='btn-sm btn-danger'>Del</button></form></td></tr>";
            }
            h << "</table>";
        }
        h << "<br><a class='btn' href='/chart'>Chart</a>";
        res.set_content(html::wrap("Parameter Models", h.str()), "text/html");
    });

    // ========== POST /delete-param-model ==========
    svr.Post("/delete-param-model", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        std::string name = fv(f, "name");
        db.removeParamModel(name);
        res.set_redirect("/param-models?msg=Model+" + name + "+deleted", 303);
    });

    // ========== JSON API: POST /api/calc/heatmap ï¿½ TP sensitivity trellis ==========
    // Sweeps axisX ï¿½ axisY as primary grid.  axis3 / axis4 (optional, "none" to
    // skip) add facet dimensions ï¿½ each combination produces a sub-heatmap tile
    // arranged in a small-multiples layout.  When a base value is 0 the multiplier
    // is treated as an absolute value so the sweep is still meaningful.
    svr.Post("/api/calc/heatmap", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);

        double price    = fd(f, "currentPrice");
        double baseQty  = fd(f, "quantity");
        int    gridN    = fi(f, "gridSize", 12);
        if (gridN < 2) gridN = 2;
        if (gridN > 40) gridN = 40;

        HorizonParams p;
        p.feeHedgingCoefficient = fd(f, "feeHedgingCoefficient", 1.0);
        p.portfolioPump         = fd(f, "portfolioPump");
        p.symbolCount           = fi(f, "symbolCount", 1);
        p.coefficientK          = fd(f, "coefficientK");
        p.feeSpread             = fd(f, "feeSpread");
        p.deltaTime             = fd(f, "deltaTime", 1.0);
        p.surplusRate           = fd(f, "surplusRate");

        std::string axisX = fv(f, "axisX");
        std::string axisY = fv(f, "axisY");
        std::string axis3 = fv(f, "axis3");
        std::string axis4 = fv(f, "axis4");
        if (axisX.empty()) axisX = "pump";
        if (axisY.empty()) axisY = "qty";
        if (axis3.empty() || axis3 == "none") axis3 = "none";
        if (axis4.empty() || axis4 == "none") axis4 = "none";

        double xLo = fd(f, "xLo", 0.1);
        double xHi = fd(f, "xHi", 3.0);
        double yLo = fd(f, "yLo", 0.1);
        double yHi = fd(f, "yHi", 3.0);

        int    z3Steps = (axis3 != "none") ? fi(f, "z3Steps", 3) : 1;
        double z3Lo    = fd(f, "z3Lo", 0.1);
        double z3Hi    = fd(f, "z3Hi", 3.0);
        int    z4Steps = (axis4 != "none") ? fi(f, "z4Steps", 3) : 1;
        double z4Lo    = fd(f, "z4Lo", 0.1);
        double z4Hi    = fd(f, "z4Hi", 3.0);

        if (z3Steps < 1) z3Steps = 1; if (z3Steps > 6) z3Steps = 6;
        if (z4Steps < 1) z4Steps = 1; if (z4Steps > 6) z4Steps = 6;

        int totalSlices = z3Steps * z4Steps;
        if (totalSlices > 9 && gridN > 6)       gridN = 6;
        else if (totalSlices > 4 && gridN > 8)   gridN = 8;
        else if (totalSlices > 1 && gridN > 10)  gridN = 10;

        auto getBase = [&](const std::string& axis) -> double {
            if (axis == "pump")       return p.portfolioPump;
            if (axis == "qty")        return baseQty;
            if (axis == "feeSpread")  return p.feeSpread;
            if (axis == "feeHedging") return p.feeHedgingCoefficient;
            if (axis == "deltaTime")  return p.deltaTime;
            if (axis == "surplus")    return p.surplusRate;
            if (axis == "coeffK")     return p.coefficientK;
            if (axis == "symbols")    return static_cast<double>(p.symbolCount);
            return 0.0;
        };

        auto applyVal = [](HorizonParams& hp, double& qty,
                           const std::string& axis, double val)
        {
            if      (axis == "pump")       hp.portfolioPump         = val;
            else if (axis == "qty")        qty                      = val;
            else if (axis == "feeSpread")  hp.feeSpread             = val;
            else if (axis == "feeHedging") hp.feeHedgingCoefficient = val;
            else if (axis == "deltaTime")  hp.deltaTime             = val;
            else if (axis == "surplus")    hp.surplusRate            = val;
            else if (axis == "coeffK")     hp.coefficientK           = val;
            else if (axis == "symbols")    hp.symbolCount = std::max(1, static_cast<int>(val));
        };

        auto scaled = [](double base, double mul) -> double {
            return (std::abs(base) > 1e-18) ? base * mul : mul;
        };

        double baseX = getBase(axisX);
        double baseY = getBase(axisY);
        double base3 = (axis3 != "none") ? getBase(axis3) : 0.0;
        double base4 = (axis4 != "none") ? getBase(axis4) : 0.0;

        std::ostringstream j;
        j << std::fixed << std::setprecision(8);

        if (price <= 0) {
            j << "{\"error\":true}";
        } else {
            j << "{\"gridSize\":" << gridN
              << ",\"axisX\":\"" << axisX << "\""
              << ",\"axisY\":\"" << axisY << "\""
              << ",\"axis3\":\"" << axis3 << "\""
              << ",\"axis4\":\"" << axis4 << "\""
              << ",\"baseX\":" << baseX
              << ",\"baseY\":" << baseY
              << ",\"base3\":" << base3
              << ",\"base4\":" << base4
              << ",\"xLo\":" << xLo << ",\"xHi\":" << xHi
              << ",\"yLo\":" << yLo << ",\"yHi\":" << yHi
              << ",\"z3Steps\":" << z3Steps
              << ",\"z3Lo\":" << z3Lo << ",\"z3Hi\":" << z3Hi
              << ",\"z4Steps\":" << z4Steps
              << ",\"z4Lo\":" << z4Lo << ",\"z4Hi\":" << z4Hi
              << ",\"slices\":[";

            bool firstSlice = true;
            for (int z4i = 0; z4i < z4Steps; ++z4i)
            {
                double z4Mul = (z4Steps > 1)
                    ? z4Lo + (z4Hi - z4Lo) * static_cast<double>(z4i) / (z4Steps - 1)
                    : 1.0;
                for (int z3i = 0; z3i < z3Steps; ++z3i)
                {
                    double z3Mul = (z3Steps > 1)
                        ? z3Lo + (z3Hi - z3Lo) * static_cast<double>(z3i) / (z3Steps - 1)
                        : 1.0;
                    if (!firstSlice) j << ",";
                    firstSlice = false;
                    j << "{\"z3m\":" << z3Mul
                      << ",\"z3v\":" << scaled(base3, z3Mul)
                      << ",\"z4m\":" << z4Mul
                      << ",\"z4v\":" << scaled(base4, z4Mul)
                      << ",\"rows\":[";
                    for (int yi = 0; yi < gridN; ++yi)
                    {
                        double yMul = (gridN > 1)
                            ? yLo + (yHi - yLo) * static_cast<double>(yi) / (gridN - 1)
                            : yLo;
                        if (yi > 0) j << ",";
                        j << "[";
                        for (int xi = 0; xi < gridN; ++xi)
                        {
                            double xMul = (gridN > 1)
                                ? xLo + (xHi - xLo) * static_cast<double>(xi) / (gridN - 1)
                                : xLo;
                            HorizonParams hp = p;
                            double qty = baseQty;
                            applyVal(hp, qty, axisX, scaled(baseX, xMul));
                            applyVal(hp, qty, axisY, scaled(baseY, yMul));
                            if (axis3 != "none") applyVal(hp, qty, axis3, scaled(base3, z3Mul));
                            if (axis4 != "none") applyVal(hp, qty, axis4, scaled(base4, z4Mul));
                            if (qty < 1e-18) qty = 1e-18;
                            double eo = MultiHorizonEngine::effectiveOverhead(price, qty, hp);
                            double oh = MultiHorizonEngine::computeOverhead(price, qty, hp);
                            if (xi > 0) j << ",";
                            j << "{\"xm\":" << xMul
                              << ",\"ym\":" << yMul
                              << ",\"xv\":" << scaled(baseX, xMul)
                              << ",\"yv\":" << scaled(baseY, yMul)
                              << ",\"eo\":" << (eo * 100)
                              << ",\"oh\":" << (oh * 100)
                              << "}";
                        }
                        j << "]";
                    }
                    j << "]}";
                }
            }
            j << "]}";
        }
        res.set_header("Access-Control-Allow-Origin", "*");
        res.set_content(j.str(), "application/json");
    });
}
===== Routes_Auth.h ===== 
#pragma once

#include "AppContext.h"
#include "HtmlHelpers.h"
#include <sstream>

inline void registerAuthRoutes(httplib::Server& svr, AppContext& ctx)
{
    // ========== GET /login ==========
    svr.Get("/login", [&](const httplib::Request& req, httplib::Response& res) {
        std::string msg;
        if (req.has_param("error")) msg = req.get_param_value("error");
        if (req.has_param("ok"))    msg = req.get_param_value("ok");

        std::ostringstream pg;
        pg << "<!DOCTYPE html><html><head><meta charset='utf-8'>"
              "<meta name='viewport' content='width=device-width,initial-scale=1'>"
              "<title>Login - Quant</title>"
           << html::css()
           << "<style>"
              ".auth-wrap{display:flex;justify-content:center;align-items:center;min-height:80vh;}"
              ".auth-box{background:#0f1b2d;border:1px solid #1a2744;border-radius:8px;padding:32px;width:340px;}"
              ".auth-box h2{color:#c9a44a;margin-bottom:16px;font-size:1.2em;text-align:center;}"
              ".auth-box label{display:block;color:#64748b;font-size:0.85em;margin:8px 0 3px;}"
              ".auth-box input[type=text],.auth-box input[type=password],.auth-box input[type=email]{"
              "width:100%;padding:8px;background:#0b1426;border:1px solid #1a2744;color:#cbd5e1;"
              "border-radius:4px;font-family:inherit;font-size:0.9em;}"
              ".auth-box input:focus{border-color:#c9a44a;outline:none;}"
              ".auth-box button{width:100%;padding:8px;margin-top:14px;background:#166534;color:#fff;"
              "border:none;border-radius:4px;cursor:pointer;font-family:inherit;font-size:0.9em;}"
              ".auth-box button:hover{background:#15803d;}"
              ".auth-box .link{text-align:center;margin-top:12px;font-size:0.82em;}"
              ".auth-box .link a{color:#7b97c4;}"
              ".auth-msg{padding:6px 10px;border-radius:4px;margin-bottom:8px;font-size:0.82em;text-align:center;}"
              ".auth-msg.err{background:#7f1d1d;color:#fca5a5;border:1px solid #991b1b;}"
              ".auth-msg.ok{background:#14532d;color:#86efac;border:1px solid #166534;}"
              "</style></head><body>";
        pg << "<div class='auth-wrap'><div class='auth-box'>"
              "<h2>&#9733; Quant Login</h2>";
        if (!msg.empty())
        {
            bool isOk = req.has_param("ok");
            pg << "<div class='auth-msg " << (isOk ? "ok" : "err") << "'>"
               << html::esc(msg) << "</div>";
        }
        pg << "<form method='POST' action='/login'>"
              "<label>Username</label>"
              "<input type='text' name='username' required autofocus>"
              "<label>Password</label>"
              "<input type='password' name='password' required>"
              "<button type='submit'>Login</button>"
              "</form>"
              "<div class='link'>No account? <a href='/register'>Register</a></div>"
              "</div></div></body></html>";
        res.set_content(pg.str(), "text/html");
    });

    // ========== POST /login ==========
    svr.Post("/login", [&](const httplib::Request& req, httplib::Response& res) {
        auto f = parseForm(req.body);
        std::string username = fv(f, "username");
        std::string password = fv(f, "password");

        if (!ctx.users.authenticate(username, password))
        {
            res.set_redirect("/login?error=Invalid+username+or+password", 303);
            return;
        }

        std::string token = ctx.users.createSession(username);
        res.set_header("Set-Cookie",
            std::string(UserManager::cookieName()) + "=" + token + "; Path=/; HttpOnly; SameSite=Lax");
        res.set_redirect("/", 303);
    });

    // ========== GET /register ==========
    svr.Get("/register", [&](const httplib::Request& req, httplib::Response& res) {
        std::string msg;
        if (req.has_param("error")) msg = req.get_param_value("error");

        std::ostringstream pg;
        pg << "<!DOCTYPE html><html><head><meta charset='utf-8'>"
              "<meta name='viewport' content='width=device-width,initial-scale=1'>"
              "<title>Register - Quant</title>"
           << html::css()
           << "<style>"
              ".auth-wrap{display:flex;justify-content:center;align-items:center;min-height:80vh;}"
              ".auth-box{background:#0f1b2d;border:1px solid #1a2744;border-radius:8px;padding:32px;width:340px;}"
              ".auth-box h2{color:#c9a44a;margin-bottom:16px;font-size:1.2em;text-align:center;}"
              ".auth-box label{display:block;color:#64748b;font-size:0.85em;margin:8px 0 3px;}"
              ".auth-box input[type=text],.auth-box input[type=password],.auth-box input[type=email]{"
              "width:100%;padding:8px;background:#0b1426;border:1px solid #1a2744;color:#cbd5e1;"
              "border-radius:4px;font-family:inherit;font-size:0.9em;}"
              ".auth-box input:focus{border-color:#c9a44a;outline:none;}"
              ".auth-box button{width:100%;padding:8px;margin-top:14px;background:#1e40af;color:#fff;"
              "border:none;border-radius:4px;cursor:pointer;font-family:inherit;font-size:0.9em;}"
              ".auth-box button:hover{background:#1d4ed8;}"
              ".auth-box .link{text-align:center;margin-top:12px;font-size:0.82em;}"
              ".auth-box .link a{color:#7b97c4;}"
              ".auth-msg.err{background:#7f1d1d;color:#fca5a5;border:1px solid #991b1b;"
              "padding:6px 10px;border-radius:4px;margin-bottom:8px;font-size:0.82em;text-align:center;}"
              "</style></head><body>";
        pg << "<div class='auth-wrap'><div class='auth-box'>"
              "<h2>&#9733; Create Account</h2>";
        if (!msg.empty())
            pg << "<div class='auth-msg err'>" << html::esc(msg) << "</div>";
        pg << "<form method='POST' action='/register'>"
              "<label>Username</label>"
              "<input type='text' name='username' required autofocus pattern='[A-Za-z0-9_]+' "
              "title='Letters, digits, underscores only'>"
              "<label>Email (optional)</label>"
              "<input type='email' name='email'>"
              "<label>Password (min 4 chars)</label>"
              "<input type='password' name='password' required minlength='4'>"
              "<label>Confirm Password</label>"
              "<input type='password' name='password2' required minlength='4'>"
              "<button type='submit'>Register</button>"
              "</form>"
              "<div class='link'>Already registered? <a href='/login'>Login</a></div>"
              "</div></div></body></html>";
        res.set_content(pg.str(), "text/html");
    });

    // ========== POST /register ==========
    svr.Post("/register", [&](const httplib::Request& req, httplib::Response& res) {
        auto f = parseForm(req.body);
        std::string username  = fv(f, "username");
        std::string email     = fv(f, "email");
        std::string password  = fv(f, "password");
        std::string password2 = fv(f, "password2");

        if (password != password2)
        {
            res.set_redirect("/register?error=Passwords+do+not+match", 303);
            return;
        }

        std::string err = ctx.users.registerUser(username, password, email);
        if (!err.empty())
        {
            res.set_redirect("/register?error=" + urlEnc(err), 303);
            return;
        }

        res.set_redirect("/login?ok=Account+created.+Please+login.", 303);
    });

    // ========== GET /logout ==========
    svr.Get("/logout", [&](const httplib::Request& req, httplib::Response& res) {
        auto token = AppContext::getSessionToken(req);
        if (!token.empty())
            ctx.users.destroySession(token);
        res.set_header("Set-Cookie",
            std::string(UserManager::cookieName()) + "=; Path=/; Max-Age=0; HttpOnly; SameSite=Lax");
        res.set_redirect("/login?ok=Logged+out", 303);
    });
}
===== Routes_Chart.h ===== 
#pragma once

#include "AppContext.h"
#include "HtmlHelpers.h"
#include <mutex>
#include <sstream>

inline void registerChartRoutes(httplib::Server& svr, AppContext& ctx)
{
    auto& db = ctx.defaultDb;
    auto& dbMutex = ctx.dbMutex;

    // ========== GET /chart ï¿½ Interactive visualization ==========
    svr.Get("/chart", [&](const httplib::Request&, httplib::Response& res) {
        std::ostringstream pg;
        pg << "<!DOCTYPE html><html><head><meta charset='utf-8'>"
              "<meta name='viewport' content='width=device-width,initial-scale=1'>"
              "<title>Chart - Quant</title><style>"
              "*{box-sizing:border-box;margin:0;padding:0;}"
              "body{font-family:'Segoe UI',monospace;background:#0b1426;color:#cbd5e1;overflow-x:hidden;}"
              "nav{background:#0f1b2d;padding:10px 20px;border-bottom:1px solid #1a2744;display:flex;gap:8px;flex-wrap:wrap;}"
              "nav a{color:#7b97c4;text-decoration:none;font-size:0.85em;padding:4px 8px;border-radius:4px;}"
              "nav a:hover{background:#132035;}"
              ".wrap{display:flex;height:calc(100vh - 44px);}"
              ".sidebar{width:320px;min-width:320px;background:#0f1b2d;border-right:1px solid #1a2744;"
              "overflow-y:auto;padding:10px;font-size:0.82em;}"
              ".sidebar h3{color:#c9a44a;margin:8px 0 4px 0;font-size:0.9em;border-bottom:1px solid #152238;padding-bottom:3px;}"
              ".sidebar label{display:inline-block;width:100px;color:#64748b;font-size:0.8em;}"
              ".sidebar input,.sidebar select{background:#0b1426;border:1px solid #1a2744;color:#cbd5e1;padding:3px 5px;"
              "border-radius:3px;font-family:inherit;font-size:0.85em;width:100px;margin:1px 0;}"
              ".sidebar input:focus,.sidebar select:focus{border-color:#c9a44a;outline:none;}"
              ".sidebar .row{display:flex;align-items:center;margin:2px 0;}"
              ".canvas-wrap{flex:1;position:relative;overflow:hidden;}"
              "canvas{display:block;width:100%;height:100%;}"
              ".tooltip{position:absolute;background:#0f1b2dee;border:1px solid #1a2744;border-radius:6px;padding:6px 10px;"
              "font-size:0.78em;color:#cbd5e1;pointer-events:none;display:none;white-space:pre;z-index:10;}"
              ".legend{position:absolute;top:8px;right:8px;background:#0f1b2ddd;border:1px solid #1a2744;border-radius:6px;"
              "padding:8px 12px;font-size:0.75em;z-index:5;}"
              ".legend div{display:flex;align-items:center;gap:6px;margin:2px 0;}"
              ".legend span.sw{display:inline-block;width:24px;height:3px;border-radius:1px;}"
              ".tabs{display:flex;gap:0;margin-bottom:8px;}"
              ".tabs button{flex:1;background:#0b1426;border:1px solid #1a2744;color:#64748b;padding:5px;cursor:pointer;"
              "font-family:inherit;font-size:0.8em;border-radius:0;}"
              ".tabs button:first-child{border-radius:4px 0 0 4px;}"
              ".tabs button:last-child{border-radius:0 4px 4px 0;}"
              ".tabs button.active{background:#1e40af;color:#fff;border-color:#1e40af;}"
              ".mode-panel{display:none;}.mode-panel.active{display:block;}"
              ".stats{display:flex;flex-wrap:wrap;gap:4px;margin:6px 0;}"
              ".stats div{background:#0b1426;border:1px solid #152238;border-radius:4px;padding:3px 6px;font-size:0.75em;}"
              ".stats .lbl{color:#64748b;}.stats .val{color:#c9a44a;}"
              "button.action{background:#166534;color:#fff;border:none;padding:4px 10px;border-radius:4px;cursor:pointer;"
              "font-family:inherit;font-size:0.8em;width:100%;margin:4px 0;}"
              "button.action:hover{background:#15803d;}"
              ".filter-row{margin:4px 0;}.filter-row label{width:auto;margin-right:6px;}"
              ".filter-row input[type=checkbox]{width:auto;margin-right:2px;}"
              "</style></head><body>";
        pg << "<nav>"
              "<a href='/'>Dashboard</a><a href='/trades'>Trades</a><a href='/wallet'>Wallet</a>"
              "<a href='/portfolio'>Portfolio</a><a href='/market-entry'>Entry Calc</a>"
              "<a href='/serial-generator'>Serial Gen</a><a href='/exit-strategy'>Exit Calc</a>"
              "<a href='/entry-points'>Entry Points</a><a href='/pending-exits'>Pending Exits</a>"
              "<a href='/pnl' style='color:#22c55e;'>&#9654; P&amp;L</a>"
              "<a href='/chart' style='color:#c9a44a;font-weight:bold;'>&#9733; Chart</a>"
              "</nav>";
        pg << "<div class='wrap'><div class='sidebar' id='sidebar'>"
              "<div class='tabs' id='modeTabs'>"
              "<button class='active' data-mode='portfolio'>Portfolio</button>"
              "<button data-mode='entry'>Entry Calc</button>"
              "<button data-mode='serial'>Serial Gen</button></div>";
        // portfolio panel
        pg << "<div class='mode-panel active' id='panel-portfolio'>"
              "<h3>Existing Data</h3>"
              "<button class='action' onclick='loadPortfolio()'>Refresh Data</button>"
              "<div id='portfolio-symbols'></div>"
              "<div class='filter-row' id='portfolio-filters'></div>"
              "<div class='stats' id='portfolio-stats'></div></div>";
        // entry calc panel
        pg << "<div class='mode-panel' id='panel-entry'><h3>Market Entry (Live)</h3>"
              "<div class='row'><label>Symbol</label><input id='e_symbol' value='BTC'></div>"
              "<div class='row'><label>Price</label><input id='e_price' type='number' step='any' value='100000'></div>"
              "<div class='row'><label>Quantity</label><input id='e_qty' type='number' step='any' value='1'></div>"
              "<div class='row'><label>Levels</label><input id='e_levels' type='number' value='4'></div>"
              "<div class='row'><label>Risk</label><input id='e_risk' type='number' step='any' value='0.5'></div>"
              "<div class='row'><label>Steepness</label><input id='e_steepness' type='number' step='any' value='6'></div>"
              "<div class='row'><label>Fee Hedging</label><input id='e_feeHedging' type='number' step='any' value='2'></div>"
              "<div class='row'><label>Pump</label><input id='e_pump' type='number' step='any' value='1000'></div>"
              "<div class='row'><label>Symbols</label><input id='e_symCount' type='number' value='1'></div>"
              "<div class='row'><label>Coeff K</label><input id='e_coeffK' type='number' step='any' value='0'></div>"
              "<div class='row'><label>Fee Spread</label><input id='e_feeSpread' type='number' step='any' value='5'></div>"
              "<div class='row'><label>Delta Time</label><input id='e_deltaTime' type='number' step='any' value='1'></div>"
              "<div class='row'><label>Surplus</label><input id='e_surplus' type='number' step='any' value='0.02'></div>"
              "<div class='row'><label>Max Risk</label><input id='e_maxRisk' type='number' step='any' value='0'></div>"
              "<div class='row'><label>Min Risk</label><input id='e_minRisk' type='number' step='any' value='0'></div>"
              "<div class='row'><label>Direction</label><select id='e_isShort'>"
              "<option value='0'>LONG</option><option value='1'>SHORT</option></select></div>"
              "<div class='row'><label>Funding</label><select id='e_fundMode'>"
              "<option value='1'>Pump only</option><option value='2'>Pump+Wallet</option></select></div>"
              "<div class='row'><label>Range Above</label><input id='e_rangeAbove' type='number' step='any' value='0'></div>"
              "<div class='row'><label>Range Below</label><input id='e_rangeBelow' type='number' step='any' value='0'></div>"
              "<h3>Parameter Models</h3>"
              "<div class='row'><label>Name</label><input id='e_modelName' type='text' value=''></div>"
              "<div class='row'><select id='e_modelSelect' style='width:150px;'><option value=''>-- load --</option></select>"
              "<button type='button' class='action' style='width:auto;margin-left:4px;padding:3px 6px;' onclick='loadModel(\"e\")'>Load</button></div>"
              "<div class='row' style='gap:4px;'>"
              "<button type='button' class='action' style='width:auto;background:#1e40af;' onclick='saveModel(\"e\")'>Save</button>"
              "<button type='button' class='action' style='width:auto;background:#991b1b;' onclick='deleteModel(\"e\")'>Delete</button></div>"
              "<div class='stats' id='entry-stats'></div>"
              "<button class='action' id='saveEntryBtn' style='display:none;background:#1e40af;'>Save Entry Points</button></div>";
        // serial gen panel
        pg << "<div class='mode-panel' id='panel-serial'><h3>Serial Gen (Live)</h3>"
              "<div class='row'><label>Symbol</label><input id='s_symbol' value='BTC'></div>"
              "<div class='row'><label>Price</label><input id='s_price' type='number' step='any' value='100000'></div>"
              "<div class='row'><label>Quantity</label><input id='s_qty' type='number' step='any' value='1'></div>"
              "<div class='row'><label>Levels</label><input id='s_levels' type='number' value='4'></div>"
              "<div class='row'><label>Risk</label><input id='s_risk' type='number' step='any' value='0.5'></div>"
              "<div class='row'><label>Steepness</label><input id='s_steepness' type='number' step='any' value='6'></div>"
              "<div class='row'><label>Fee Hedging</label><input id='s_feeHedging' type='number' step='any' value='2'></div>"
              "<div class='row'><label>Pump</label><input id='s_pump' type='number' step='any' value='1000'></div>"
              "<div class='row'><label>Symbols</label><input id='s_symCount' type='number' value='1'></div>"
              "<div class='row'><label>Coeff K</label><input id='s_coeffK' type='number' step='any' value='0'></div>"
              "<div class='row'><label>Fee Spread</label><input id='s_feeSpread' type='number' step='any' value='5'></div>"
              "<div class='row'><label>Delta Time</label><input id='s_deltaTime' type='number' step='any' value='1'></div>"
              "<div class='row'><label>Surplus</label><input id='s_surplus' type='number' step='any' value='0.02'></div>"
              "<div class='row'><label>Max Risk</label><input id='s_maxRisk' type='number' step='any' value='0'></div>"
              "<div class='row'><label>Min Risk</label><input id='s_minRisk' type='number' step='any' value='0'></div>"
              "<div class='row'><label>Direction</label><select id='s_isShort'>"
              "<option value='0'>LONG</option><option value='1'>SHORT</option></select></div>"
              "<div class='row'><label>Funding</label><select id='s_fundMode'>"
              "<option value='1'>Pump only</option><option value='2'>Pump+Wallet</option></select></div>"
              "<div class='row'><label>Stop Losses</label><select id='s_genSL'>"
              "<option value='0'>No</option><option value='1'>Yes</option></select></div>"
              "<div class='row'><label>Range Above</label><input id='s_rangeAbove' type='number' step='any' value='0'></div>"
              "<div class='row'><label>Range Below</label><input id='s_rangeBelow' type='number' step='any' value='0'></div>"
              "<h3>Parameter Models</h3>"
              "<div class='row'><label>Name</label><input id='s_modelName' type='text' value=''></div>"
              "<div class='row'><select id='s_modelSelect' style='width:150px;'><option value=''>-- load --</option></select>"
              "<button type='button' class='action' style='width:auto;margin-left:4px;padding:3px 6px;' onclick='loadModel(\"s\")'>Load</button></div>"
              "<div class='row' style='gap:4px;'>"
              "<button type='button' class='action' style='width:auto;background:#1e40af;' onclick='saveModel(\"s\")'>Save</button>"
              "<button type='button' class='action' style='width:auto;background:#991b1b;' onclick='deleteModel(\"s\")'>Delete</button></div>"
              "<div class='stats' id='serial-stats'></div>"
              "<button class='action' id='saveSerialBtn' style='display:none;background:#1e40af;'>Save Entry Points</button>"
              "<h3>TP Heatmap Overlay</h3>"
              "<div style='color:#64748b;font-size:0.72em;margin-bottom:4px;'>"
              "Sweep params as a trellis of small-multiple heatmaps</div>"
              "<div class='row'><label>X Axis</label><select id='h_axisX' style='width:100px;'>"
              "<option value='pump'>Pump</option><option value='qty'>Quantity</option>"
              "<option value='feeSpread' selected>Fee Spread</option><option value='feeHedging'>Fee Hedging</option>"
              "<option value='deltaTime'>Delta Time</option><option value='surplus'>Surplus</option>"
              "<option value='coeffK'>Coeff K</option><option value='symbols'>Symbols</option></select></div>"
              "<div class='row'><label>Y Axis</label><select id='h_axisY' style='width:100px;'>"
              "<option value='pump' selected>Pump</option><option value='qty'>Quantity</option>"
              "<option value='feeSpread'>Fee Spread</option><option value='feeHedging'>Fee Hedging</option>"
              "<option value='deltaTime'>Delta Time</option><option value='surplus'>Surplus</option>"
              "<option value='coeffK'>Coeff K</option><option value='symbols'>Symbols</option></select></div>"
              "<div class='row'><label>Grid Size</label><input id='h_gridSize' type='number' value='14' style='width:60px;'></div>"
              "<div class='row'><label>X Lo</label><input id='h_xLo' type='number' step='any' value='0.1' style='width:60px;'></div>"
              "<div class='row'><label>X Hi</label><input id='h_xHi' type='number' step='any' value='3' style='width:60px;'></div>"
              "<div class='row'><label>Y Lo</label><input id='h_yLo' type='number' step='any' value='0.1' style='width:60px;'></div>"
              "<div class='row'><label>Y Hi</label><input id='h_yHi' type='number' step='any' value='3' style='width:60px;'></div>"
              "<div class='row'><label>Axis 3</label><select id='h_axis3' style='width:70px;'>"
              "<option value='none' selected>None</option><option value='pump'>Pump</option><option value='qty'>Qty</option>"
              "<option value='feeSpread'>FeeSprd</option><option value='feeHedging'>FeeHdg</option>"
              "<option value='deltaTime'>DeltaT</option><option value='surplus'>Surpl</option>"
              "<option value='coeffK'>CoeffK</option><option value='symbols'>Syms</option></select>"
              "<input id='h_z3Steps' type='number' value='3' min='1' max='6' style='width:24px;margin-left:2px;' title='Steps'>"
              "<input id='h_z3Lo' type='number' step='any' value='0.1' style='width:34px;' title='Lo'>"
              "<input id='h_z3Hi' type='number' step='any' value='3' style='width:34px;' title='Hi'></div>"
              "<div class='row'><label>Axis 4</label><select id='h_axis4' style='width:70px;'>"
              "<option value='none' selected>None</option><option value='pump'>Pump</option><option value='qty'>Qty</option>"
              "<option value='feeSpread'>FeeSprd</option><option value='feeHedging'>FeeHdg</option>"
              "<option value='deltaTime'>DeltaT</option><option value='surplus'>Surpl</option>"
              "<option value='coeffK'>CoeffK</option><option value='symbols'>Syms</option></select>"
              "<input id='h_z4Steps' type='number' value='3' min='1' max='6' style='width:24px;margin-left:2px;' title='Steps'>"
              "<input id='h_z4Lo' type='number' step='any' value='0.1' style='width:34px;' title='Lo'>"
              "<input id='h_z4Hi' type='number' step='any' value='3' style='width:34px;' title='Hi'></div>"
              "<div style='color:#475569;font-size:0.68em;margin:2px 0;'>"
              "Base=0 &#x2192; multiplier becomes absolute value</div>"
              "<button class='action' id='hmToggle' style='background:#4338ca;' onclick='toggleHM()'>&#x1F525; Show Heatmap</button>"
              "<div class='stats' id='heatmap-stats'></div></div>";
        pg << "</div>"; // sidebar
        pg << "<div class='canvas-wrap' id='canvasWrap'>"
              "<canvas id='chart'></canvas>"
              "<canvas id='heatmapCanvas' style='position:absolute;top:0;left:0;width:100%;height:100%;display:none;pointer-events:none;'></canvas>"
              "<div class='tooltip' id='tip'></div>"
              "<div class='tooltip' id='htip'></div>"
              "<div class='legend' id='legend'>"
              "<div><span class='sw' style='background:#60a5fa'></span> Entry Price</div>"
              "<div><span class='sw' style='background:#22c55e'></span> Take Profit</div>"
              "<div><span class='sw' style='background:#ef4444'></span> Stop Loss</div>"
              "<div><span class='sw' style='background:#f59e0b'></span> Break Even</div>"
              "<div><span class='sw' style='background:#eab308'></span> Current Price</div>"
              "<div><span class='sw' style='background:#64748b'></span> Pending Exit</div>"
              "</div></div></div>";
        // JavaScript - split into multiple strings for MSVC
        pg << "<script>\n(function(){\n'use strict';\n";
        pg << "var $=function(id){return document.getElementById(id);};\n"
              "var canvas=$('chart'),ctx=canvas.getContext('2d');\n"
              "var tip=$('tip'),wrap=$('canvasWrap');\n"
              "var W,H,dpr,currentMode='portfolio';\n"
              "var chartData=[],priceMin=0,priceMax=1;\n"
              "var PAD_L=90,PAD_R=30,PAD_T=30,PAD_B=30;\n"
              "var lastEntryResult=null,lastSerialResult=null;\n";
        pg << "function resize(){dpr=window.devicePixelRatio||1;"
              "W=wrap.clientWidth;H=wrap.clientHeight;"
              "canvas.width=W*dpr;canvas.height=H*dpr;"
              "canvas.style.width=W+'px';canvas.style.height=H+'px';"
              "ctx.setTransform(dpr,0,0,dpr,0,0);draw();"
              "if(hmVisible)drawH();}\n"
              "window.addEventListener('resize',resize);\n";
        pg << "function priceToY(p){var r=priceMax-priceMin;if(r<=0)r=1;"
              "return PAD_T+(1-(p-priceMin)/r)*(H-PAD_T-PAD_B);}\n"
              "function yToPrice(y){var r=priceMax-priceMin;if(r<=0)r=1;"
              "return priceMin+(1-(y-PAD_T)/(H-PAD_T-PAD_B))*r;}\n"
              "function fp(p){if(Math.abs(p)>=1)return p.toFixed(2);"
              "if(Math.abs(p)>=0.01)return p.toFixed(4);return p.toFixed(8);}\n";
        // draw function
        pg << "function draw(){ctx.clearRect(0,0,W,H);ctx.fillStyle='#0b1426';ctx.fillRect(0,0,W,H);\n"
              "if(!chartData.length){ctx.fillStyle='#475569';ctx.font='14px monospace';"
              "ctx.textAlign='center';ctx.fillText('Select a mode and load data',W/2,H/2);return;}\n"
              "var prices=chartData.map(function(d){return d.price;}).filter(function(p){return p>0&&isFinite(p);});\n"
              "if(!prices.length)return;\n"
              "var pMin=Math.min.apply(null,prices),pMax=Math.max.apply(null,prices);\n"
              "var pad=(pMax-pMin)*0.1||pMax*0.1||1;priceMin=pMin-pad;priceMax=pMax+pad;\n";
        pg << "var gs=10,gst=(priceMax-priceMin)/gs;\n"
              "ctx.strokeStyle='#152238';ctx.lineWidth=1;ctx.font='10px monospace';ctx.fillStyle='#475569';ctx.textAlign='right';\n"
              "for(var i=0;i<=gs;i++){var p=priceMin+gst*i,y=priceToY(p);"
              "ctx.beginPath();ctx.moveTo(PAD_L,y);ctx.lineTo(W-PAD_R,y);ctx.stroke();"
              "ctx.fillText(fp(p),PAD_L-4,y+3);}\n";
        pg << "var groups={};chartData.forEach(function(d){var k=d.group||'default';"
              "if(!groups[k])groups[k]=[];groups[k].push(d);});\n"
              "var gk=Object.keys(groups),barW=Math.max(20,Math.min(80,(W-PAD_L-PAD_R)/(gk.length+1))),barGap=8;\n";
        pg << "gk.forEach(function(g,gi){var items=groups[g];"
              "var cx=PAD_L+barW/2+gi*(barW+barGap)+barGap;if(cx>W-PAD_R)return;\n"
              "ctx.fillStyle='#64748b';ctx.textAlign='center';ctx.font='10px monospace';ctx.fillText(g,cx,H-8);\n"
              "items.forEach(function(d){var y=priceToY(d.price);if(y<PAD_T||y>H-PAD_B)return;\n"
              "ctx.save();ctx.strokeStyle=d.color;ctx.lineWidth=d.width||2;\n"
              "if(d.dash)ctx.setLineDash(d.dash);else ctx.setLineDash([]);\n"
              "var x1=cx-barW/2+2,x2=cx+barW/2-2;\n"
              "ctx.beginPath();ctx.moveTo(x1,y);ctx.lineTo(x2,y);ctx.stroke();\n"
              "ctx.fillStyle=d.color;ctx.textAlign='left';ctx.font='9px monospace';\n"
              "ctx.fillText(d.shortLabel||d.type,x2+3,y+3);ctx.restore();});\n";
        pg << "var ei=items.find(function(d){return d.type==='Entry';});\n"
              "if(ei&&ei.funding>0){var mf=Math.max.apply(null,chartData.filter(function(d){return d.funding>0;}).map(function(d){return d.funding;}).concat([1]));\n"
              "var maxBH=Math.max(80,(H-PAD_T-PAD_B)*0.18),bh=(ei.funding/mf)*maxBH,ey=priceToY(ei.price);\n"
              "var alpha=(0.08+0.10*(ei.funding/mf)).toFixed(2);\n"
              "ctx.fillStyle='rgba(96,165,250,'+alpha+')';ctx.fillRect(cx-barW/2+2,ey-bh,barW-4,bh);\n"
              "ctx.fillStyle='#60a5facc';ctx.textAlign='center';ctx.font='bold 9px monospace';\n"
              "var pct=ei.fundPct?ei.fundPct.toFixed(1)+'%':'';\n"
              "ctx.fillText(pct,cx,ey-bh-10);\n"
              "ctx.font='8px monospace';ctx.fillStyle='#60a5fa88';\n"
              "ctx.fillText(fp(ei.qty||0)+' qty',cx,ey-bh-1);}});\n";
        pg << "var cp=chartData.find(function(d){return d.type==='Current';});\n"
              "if(cp){var cy=priceToY(cp.price);ctx.save();ctx.strokeStyle='#eab308';ctx.lineWidth=1.5;\n"
              "ctx.setLineDash([8,4]);ctx.beginPath();ctx.moveTo(PAD_L,cy);ctx.lineTo(W-PAD_R,cy);ctx.stroke();\n"
              "ctx.fillStyle='#eab308';ctx.textAlign='left';ctx.font='11px monospace';\n"
              "ctx.fillText('Current: '+fp(cp.price),PAD_L+4,cy-6);ctx.restore();}}\n";
        // tooltip
        pg << "canvas.addEventListener('mousemove',function(e){\n"
              "var r=canvas.getBoundingClientRect(),mx=e.clientX-r.left,my=e.clientY-r.top;\n"
              "var closest=null,minD=999;\n"
              "chartData.forEach(function(d){if(d.type==='Current')return;\n"
              "var dist=Math.abs(priceToY(d.price)-my);if(dist<minD&&dist<12){minD=dist;closest=d;}});\n"
              "if(closest){var ln=closest.label+'\\nPrice: '+fp(closest.price);\n"
              "if(closest.fundPct)ln+='\\nFund: '+closest.fundPct.toFixed(1)+'%';\n"
              "if(closest.qty)ln+='\\nQty: '+fp(closest.qty);\n"
              "if(closest.funding)ln+='\\nFunding: '+fp(closest.funding);\n"
              "if(closest.feeCost)ln+='\\nFee Cost: '+fp(closest.feeCost);\n"
              "tip.textContent=ln;tip.style.display='block';\n"
              "tip.style.left=(mx+14)+'px';tip.style.top=(my-10)+'px';\n"
              "}else{tip.style.display='none';}});\n"
              "canvas.addEventListener('mouseleave',function(){tip.style.display='none';});\n";
        // tabs
        pg << "$('modeTabs').addEventListener('click',function(e){\n"
              "if(e.target.tagName!=='BUTTON')return;\n"
              "document.querySelectorAll('#modeTabs button').forEach(function(b){b.classList.remove('active');});\n"
              "e.target.classList.add('active');\n"
              "document.querySelectorAll('.mode-panel').forEach(function(p){p.classList.remove('active');});\n"
              "currentMode=e.target.dataset.mode;\n"
              "$('panel-'+currentMode).classList.add('active');\n"
              "if(currentMode==='portfolio')loadPortfolio();\n"
              "hmVisible=false;hmCanvas.style.display='none';$('hmToggle').textContent='\u{1F525} Show Heatmap';});\n";
        // portfolio
        pg << "var pTrades=[],pEntries=[],pPending=[],pHorizons={},symFilter={};\n"
              "function loadPortfolio(){\n"
              "Promise.all([fetch('/api/trades').then(function(r){return r.json();}),\n"
              "fetch('/api/entry-points').then(function(r){return r.json();}),\n"
              "fetch('/api/pending-exits').then(function(r){return r.json();})])\n"
              ".then(function(arr){pTrades=arr[0];pEntries=arr[1];pPending=arr[2];pHorizons={};\n"
              "var buys=pTrades.filter(function(t){return t.type==='Buy';});\n"
              "var chain=Promise.resolve();\n"
              "buys.forEach(function(t){chain=chain.then(function(){\n"
              "return fetch('/api/horizons?tradeId='+t.id).then(function(r){return r.json();}).then(function(h){\n"
              "if(h.length>0)pHorizons[t.id]=h;});});});\n"
              "chain.then(function(){\n";
        pg << "var syms=[];pTrades.forEach(function(t){if(syms.indexOf(t.symbol)<0)syms.push(t.symbol);});\n"
              "pEntries.forEach(function(e){if(syms.indexOf(e.symbol)<0)syms.push(e.symbol);});\n"
              "var fd=$('portfolio-filters');fd.innerHTML='<h3>Symbols</h3>';\n"
              "syms.forEach(function(s){if(!(s in symFilter))symFilter[s]=true;\n"
              "var lbl=document.createElement('label');lbl.className='filter-row';\n"
              "var cb=document.createElement('input');cb.type='checkbox';cb.checked=symFilter[s];\n"
              "cb.addEventListener('change',function(){symFilter[s]=cb.checked;drawP();});\n"
              "lbl.appendChild(cb);lbl.appendChild(document.createTextNode(' '+s));fd.appendChild(lbl);});\n"
              "var sd=$('portfolio-stats');sd.innerHTML="
              "'<div><span class=lbl>Trades: </span><span class=val>'+buys.length+'</span></div>'+\n"
              "'<div><span class=lbl>Entries: </span><span class=val>'+pEntries.filter(function(e){return !e.traded;}).length+'</span></div>'+\n"
              "'<div><span class=lbl>Pending: </span><span class=val>'+pPending.length+'</span></div>';\n"
              "drawP();});});}\n";
        // drawP
        pg << "function drawP(){chartData=[];\n"
              "var buys=pTrades.filter(function(t){return t.type==='Buy'&&symFilter[t.symbol]!==false;});\n"
              "buys.forEach(function(t){var g='#'+t.id+' '+t.symbol;\n"
              "chartData.push({label:'Entry #'+t.id+' '+t.symbol,price:t.price,color:'#60a5fa',type:'Entry',"
              "group:g,shortLabel:'E',width:2.5,qty:t.remaining});\n"
              "if(t.tpPrice>0)chartData.push({label:'TP #'+t.id,price:t.tpPrice,color:'#22c55e',type:'TP',"
              "group:g,shortLabel:'TP',width:2,dash:[6,3]});\n"
              "if(t.slPrice>0)chartData.push({label:'SL #'+t.id+(t.slActive?' ON':' OFF'),price:t.slPrice,"
              "color:t.slActive?'#ef4444':'#ef444466',type:'SL',group:g,shortLabel:'SL',width:2,"
              "dash:t.slActive?[]:[4,4]});\n"
              "if(pHorizons[t.id])pHorizons[t.id].forEach(function(h){\n"
              "if(h.tpPrice>0)chartData.push({label:'H'+h.index+' TP',price:h.tpPrice,color:'#22c55e88',"
              "type:'HTP',group:g,shortLabel:'H'+h.index,width:1.5,dash:[4,2]});\n"
              "if(h.slPrice>0)chartData.push({label:'H'+h.index+' SL',price:h.slPrice,color:'#ef444488',"
              "type:'HSL',group:g,shortLabel:'H'+h.index,width:1.5,dash:[4,2]});});});\n";
        pg << "pEntries.filter(function(e){return !e.traded&&symFilter[e.symbol]!==false;}).forEach(function(ep){\n"
              "var g='EP#'+ep.id+' '+ep.symbol;\n"
              "chartData.push({label:'EntryPt #'+ep.id+' L'+ep.level,price:ep.entry,color:'#60a5fa',"
              "type:'Entry',group:g,shortLabel:'E',width:2,dash:[8,3],qty:ep.qty,funding:ep.funding||0,"
              "feeCost:(ep.breakEven>0&&ep.entry>0)?(ep.breakEven-ep.entry)*ep.qty:0});\n"
              "if(ep.breakEven>0)chartData.push({label:'BE #'+ep.id,price:ep.breakEven,color:'#f59e0b',"
              "type:'BE',group:g,shortLabel:'BE',width:1.5,dash:[3,3]});\n"
              "if(ep.tp>0)chartData.push({label:'TP #'+ep.id,price:ep.tp,color:'#22c55e',"
              "type:'TP',group:g,shortLabel:'TP',width:1.5,dash:[6,3]});\n"
              "if(ep.sl>0)chartData.push({label:'SL #'+ep.id,price:ep.sl,color:'#ef4444',"
              "type:'SL',group:g,shortLabel:'SL',width:1.5,dash:[6,3]});});\n";
        pg << "pPending.filter(function(pe){return symFilter[pe.symbol]!==false;}).forEach(function(pe){\n"
              "var mt=pTrades.find(function(t){return t.id===pe.tradeId;});\n"
              "var g=mt?('#'+mt.id+' '+mt.symbol):('PE#'+pe.orderId);\n"
              "chartData.push({label:'PendExit #'+pe.orderId+' L'+pe.level,price:pe.trigger,"
              "color:'#64748b',type:'Pend',group:g,shortLabel:'PX',width:1.5,dash:[3,5]});});\n"
              "draw();}\n";
        // entry calc
        pg << "var eTimer=null;\n"
              "function setupE(){var ids=['e_symbol','e_price','e_qty','e_levels','e_risk','e_steepness','e_feeHedging','e_pump',"
              "'e_symCount','e_coeffK','e_feeSpread','e_deltaTime','e_surplus','e_maxRisk','e_minRisk','e_isShort','e_fundMode','e_rangeAbove','e_rangeBelow'];\n"
              "ids.forEach(function(id){$(id).addEventListener('input',function(){\n"
              "clearTimeout(eTimer);eTimer=setTimeout(calcE,200);});});}\n";
        pg << "function calcE(){var body=new URLSearchParams({"
              "symbol:$('e_symbol').value,currentPrice:$('e_price').value,"
              "quantity:$('e_qty').value,levels:$('e_levels').value,"
              "risk:$('e_risk').value,steepness:$('e_steepness').value,feeHedgingCoefficient:$('e_feeHedging').value,"
              "portfolioPump:$('e_pump').value,symbolCount:$('e_symCount').value,"
              "coefficientK:$('e_coeffK').value,feeSpread:$('e_feeSpread').value,"
              "deltaTime:$('e_deltaTime').value,surplusRate:$('e_surplus').value,"
              "isShort:$('e_isShort').value,fundMode:$('e_fundMode').value,maxRisk:$('e_maxRisk').value,"
              "minRisk:$('e_minRisk').value,"
              "rangeAbove:$('e_rangeAbove').value,rangeBelow:$('e_rangeBelow').value});\n"
              "fetch('/api/calc/entry',{method:'POST',body:body}).then(function(r){return r.json();}).then(function(d){\n"
              "if(d.error)return;lastEntryResult=d;$('saveEntryBtn').style.display='block';chartData=[];\n"
              "chartData.push({label:'Current',price:d.currentPrice,color:'#eab308',type:'Current',group:'_'});\n"
              "var efs=parseFloat($('e_feeSpread').value)||0,efh=parseFloat($('e_feeHedging').value)||0,"
              "edt=parseFloat($('e_deltaTime').value)||1,efc=efs*efh*edt;\n"
              "$('entry-stats').innerHTML="
              "'<div><span class=lbl>OH: </span><span class=val>'+(d.overhead*100).toFixed(4)+'%</span></div>'+\n"
              "'<div><span class=lbl>Eff: </span><span class=val>'+(d.effective*100).toFixed(4)+'%</span></div>'+\n"
              "'<div><span class=lbl>Lvls: </span><span class=val>'+d.levels.length+'</span></div>'+\n"
              "'<div><span class=lbl>Spread: </span><span class=val>'+fp(efs)+'</span></div>'+\n"
              "'<div><span class=lbl>Hedging: </span><span class=val>'+fp(efh)+'</span></div>'+\n"
              "'<div><span class=lbl>Fee/Trade: </span><span class=val>'+fp(efc)+'</span></div>';\n"
              "d.levels.forEach(function(lv){var g='L'+lv.index;\n"
              "chartData.push({label:'L'+lv.index+' Entry',price:lv.entry,color:'#60a5fa',type:'Entry',"
              "group:g,shortLabel:'E',width:2.5,qty:lv.qty,funding:lv.funding,feeCost:(lv.breakEven-lv.entry)*lv.qty});\n"
              "chartData.push({label:'L'+lv.index+' BE',price:lv.breakEven,color:'#f59e0b',type:'BE',"
              "group:g,shortLabel:'BE',width:1.5,dash:[3,3]});\n"
              "if(lv.tp>0)chartData.push({label:'L'+lv.index+' TP',price:lv.tp,color:'#22c55e',type:'TP',"
              "group:g,shortLabel:'TP',width:2,dash:[6,3]});\n"
              "if(lv.sl>0)chartData.push({label:'L'+lv.index+' SL',price:lv.sl,color:'#ef4444',type:'SL',"
              "group:g,shortLabel:'SL',width:2,dash:[6,3]});});\n"
              "draw();}).catch(function(){});}\n";
        // serial calc
        pg << "var sTimer=null;\n"
              "function setupS(){var ids=['s_symbol','s_price','s_qty','s_levels','s_risk','s_steepness','s_feeHedging','s_pump',"
              "'s_symCount','s_coeffK','s_feeSpread','s_deltaTime','s_surplus','s_maxRisk','s_minRisk','s_isShort','s_fundMode','s_genSL','s_rangeAbove','s_rangeBelow'];\n"
              "ids.forEach(function(id){$(id).addEventListener('input',function(){\n"
              "clearTimeout(sTimer);sTimer=setTimeout(calcS,200);});});}\n";
        pg << "function calcS(){var body=new URLSearchParams({"
              "symbol:$('s_symbol').value,currentPrice:$('s_price').value,"
              "quantity:$('s_qty').value,levels:$('s_levels').value,"
              "risk:$('s_risk').value,steepness:$('s_steepness').value,"
              "feeHedgingCoefficient:$('s_feeHedging').value,portfolioPump:$('s_pump').value,"
              "symbolCount:$('s_symCount').value,coefficientK:$('s_coeffK').value,"
              "feeSpread:$('s_feeSpread').value,deltaTime:$('s_deltaTime').value,"
              "surplusRate:$('s_surplus').value,maxRisk:$('s_maxRisk').value,minRisk:$('s_minRisk').value,isShort:$('s_isShort').value,"
              "fundMode:$('s_fundMode').value,generateStopLosses:$('s_genSL').value,"
              "rangeAbove:$('s_rangeAbove').value,rangeBelow:$('s_rangeBelow').value});\n"
              "fetch('/api/calc/serial',{method:'POST',body:body}).then(function(r){return r.json();}).then(function(d){\n"
              "if(d.error)return;lastSerialResult=d;$('saveSerialBtn').style.display='block';chartData=[];\n"
              "chartData.push({label:'Current',price:d.currentPrice,color:'#eab308',type:'Current',group:'_'});\n"
              "var sfs=parseFloat($('s_feeSpread').value)||0,sfh=parseFloat($('s_feeHedging').value)||0,"
              "sdt=parseFloat($('s_deltaTime').value)||1,sfc=sfs*sfh*sdt;\n"
              "$('serial-stats').innerHTML="
              "'<div><span class=lbl>OH: </span><span class=val>'+(d.overhead*100).toFixed(4)+'%</span></div>'+\n"
              "'<div><span class=lbl>Eff: </span><span class=val>'+(d.effective*100).toFixed(4)+'%</span></div>'+\n"
              "'<div><span class=lbl>Lvls: </span><span class=val>'+d.levels.length+'</span></div>'+\n"
              "'<div><span class=lbl>Spread: </span><span class=val>'+fp(sfs)+'</span></div>'+\n"
              "'<div><span class=lbl>Hedging: </span><span class=val>'+fp(sfh)+'</span></div>'+\n"
              "'<div><span class=lbl>Fee/Trade: </span><span class=val>'+fp(sfc)+'</span></div>';\n"
              "d.levels.forEach(function(lv){var g='L'+lv.index;\n"
              "chartData.push({label:'L'+lv.index+' Entry',price:lv.entry,color:'#60a5fa',type:'Entry',"
              "group:g,shortLabel:'E',width:2.5,qty:lv.qty,funding:lv.funding,feeCost:(lv.breakEven-lv.entry)*lv.qty});\n"
              "chartData.push({label:'L'+lv.index+' BE',price:lv.breakEven,color:'#f59e0b',type:'BE',"
              "group:g,shortLabel:'BE',width:1.5,dash:[3,3]});\n"
              "if(lv.tp>0)chartData.push({label:'L'+lv.index+' TP',price:lv.tp,color:'#22c55e',type:'TP',"
              "group:g,shortLabel:'TP',width:2,dash:[6,3]});\n"
              "if(lv.sl>0)chartData.push({label:'L'+lv.index+' SL',price:lv.sl,color:'#ef4444',type:'SL',"
              "group:g,shortLabel:'SL',width:2,dash:[6,3]});});\n"
              "draw();}).catch(function(){});}\n";
        // save functions
        pg << "function saveEntry(){\n"
              "if(!lastEntryResult)return;\n"
              "var f=document.createElement('form');f.method='POST';f.action='/execute-entries';\n"
              "function add(n,v){var i=document.createElement('input');i.type='hidden';i.name=n;i.value=v;f.appendChild(i);}\n"
              "add('symbol',$('e_symbol').value);add('currentPrice',$('e_price').value);\n"
              "add('quantity',$('e_qty').value);add('risk',$('e_risk').value);\n"
              "add('isShort',$('e_isShort').value);add('fundMode',$('e_fundMode').value);\n"
              "add('levels',$('e_levels').value);add('steepness',$('e_steepness').value);add('feeHedgingCoefficient',$('e_feeHedging').value);\n"
              "add('portfolioPump',$('e_pump').value);add('symbolCount',$('e_symCount').value);\n"
              "add('coefficientK',$('e_coeffK').value);add('feeSpread',$('e_feeSpread').value);\n"
              "add('deltaTime',$('e_deltaTime').value);add('surplusRate',$('e_surplus').value);\n"
              "add('maxRisk',$('e_maxRisk').value);add('minRisk',$('e_minRisk').value);\n"
              "add('rangeAbove',$('e_rangeAbove').value);add('rangeBelow',$('e_rangeBelow').value);\n"
              "document.body.appendChild(f);f.submit();}\n";
        pg << "function saveSerial(){\n"
              "if(!lastSerialResult)return;var d=lastSerialResult;\n"
              "var f=document.createElement('form');f.method='POST';f.action='/save-serial';\n"
              "function add(n,v){var i=document.createElement('input');i.type='hidden';i.name=n;i.value=v;f.appendChild(i);}\n"
              "add('symbol',$('s_symbol').value);add('isShort',$('s_isShort').value);\n"
              "add('pump',$('s_pump').value);add('entryCount',d.levels.length);\n"
              "d.levels.forEach(function(lv){\n"
              "add('ep_'+lv.index,lv.entry);add('eq_'+lv.index,lv.qty);\n"
              "add('eb_'+lv.index,lv.breakEven);add('ef_'+lv.index,lv.funding);\n"
              "add('eov_'+lv.index,d.effective);add('etp_'+lv.index,lv.tp);\n"
              "add('esl_'+lv.index,lv.sl);});\n"
              "document.body.appendChild(f);f.submit();}\n";
        // param model functions
        pg << "var paramModels=[];\n"
              "function refreshModels(){\n"
              "fetch('/api/param-models').then(function(r){\n"
              "if(!r.ok)throw new Error('HTTP '+r.status);return r.json();}).then(function(arr){\n"
              "paramModels=arr;\n"
              "['e','s'].forEach(function(p){\n"
              "var sel=$(p+'_modelSelect');sel.innerHTML='<option value=\\'\\'>-- load --</option>';\n"
              "arr.forEach(function(m){var o=document.createElement('option');o.value=m.name;o.textContent=m.name;sel.appendChild(o);});\n"
              "});}).catch(function(e){console.warn('refreshModels:',e);});}\n";
        pg << "function saveModel(prefix){\n"
              "try{\n"
              "var name=$(prefix+'_modelName').value.trim();\n"
              "if(!name){alert('Enter a model name');return;}\n"
              "var btn=event&&event.target;if(btn){btn.textContent='Saving...';btn.disabled=true;}\n"
              "var body=new URLSearchParams({\n"
              "name:name,levels:$(prefix+'_levels').value,risk:$(prefix+'_risk').value,\n"
              "steepness:$(prefix+'_steepness').value,feeHedgingCoefficient:$(prefix+'_feeHedging').value,\n"
              "portfolioPump:$(prefix+'_pump').value,symbolCount:$(prefix+'_symCount').value,\n"
              "coefficientK:$(prefix+'_coeffK').value,feeSpread:$(prefix+'_feeSpread').value,\n"
              "deltaTime:$(prefix+'_deltaTime').value,surplusRate:$(prefix+'_surplus').value,\n"
              "maxRisk:$(prefix+'_maxRisk').value,minRisk:$(prefix+'_minRisk').value,\n"
              "isShort:$(prefix+'_isShort').value,\n"
              "fundMode:$(prefix+'_fundMode').value,\n"
              "rangeAbove:$(prefix+'_rangeAbove').value,rangeBelow:$(prefix+'_rangeBelow').value});\n"
              "if(prefix==='s'&&$(prefix+'_genSL')){body.set('generateStopLosses',$(prefix+'_genSL').value);}\n"
              "fetch('/api/param-models',{method:'POST',\n"
              "headers:{'Content-Type':'application/x-www-form-urlencoded'},\n"
              "body:body.toString()})\n"
              ".then(function(r){if(!r.ok)return r.text().then(function(t){throw new Error('HTTP '+r.status+': '+t);});return r.json();})\n"
              ".then(function(d){if(btn){btn.textContent='Save';btn.disabled=false;}\n"
              "if(d.ok){refreshModels();\n"
              "var sel=$(prefix+'_modelSelect');\n"
              "setTimeout(function(){sel.value=name;},300);\n"
              "}else{alert('Save failed: '+(d.error||'unknown'));}})\n"
              ".catch(function(e){if(btn){btn.textContent='Save';btn.disabled=false;}alert('Save error: '+e);});\n"
              "}catch(ex){alert('saveModel exception: '+ex.message);}}\n";
        pg << "function loadModel(prefix){\n"
              "var name=$(prefix+'_modelSelect').value;\n"
              "if(!name)return;\n"
              "var m=paramModels.find(function(x){return x.name===name;});\n"
              "if(!m)return;\n"
              "$(prefix+'_levels').value=m.levels;\n"
              "$(prefix+'_risk').value=m.risk;\n"
              "$(prefix+'_steepness').value=m.steepness;\n"
              "$(prefix+'_feeHedging').value=m.feeHedgingCoefficient;\n"
              "$(prefix+'_pump').value=m.portfolioPump;\n"
              "$(prefix+'_symCount').value=m.symbolCount;\n"
              "$(prefix+'_coeffK').value=m.coefficientK;\n"
              "$(prefix+'_feeSpread').value=m.feeSpread;\n"
              "$(prefix+'_deltaTime').value=m.deltaTime;\n"
              "$(prefix+'_surplus').value=m.surplusRate;\n"
              "$(prefix+'_maxRisk').value=m.maxRisk;\n"
              "$(prefix+'_minRisk').value=m.minRisk;\n"
              "$(prefix+'_isShort').value=m.isShort?'1':'0';\n"
              "$(prefix+'_fundMode').value=m.fundMode;\n"
              "$(prefix+'_rangeAbove').value=m.rangeAbove;\n"
              "$(prefix+'_rangeBelow').value=m.rangeBelow;\n"
              "if(prefix==='s'&&$(prefix+'_genSL'))$(prefix+'_genSL').value=m.generateStopLosses?'1':'0';\n"
              "$(prefix+'_modelName').value=m.name;\n"
              "if(prefix==='e')calcE();else calcS();}\n";
        pg << "function deleteModel(prefix){\n"
              "var name=$(prefix+'_modelName').value.trim()||($(prefix+'_modelSelect').value);\n"
              "if(!name){alert('Enter or select a model name');return;}\n"
              "if(!confirm('Delete model: '+name+'?'))return;\n"
              "fetch('/api/param-models?name='+encodeURIComponent(name),{method:'DELETE'})\n"
              ".then(function(r){if(!r.ok)throw new Error('HTTP '+r.status);return r.json();})\n"
              ".then(function(){$(prefix+'_modelName').value='';refreshModels();})\n"
              ".catch(function(e){alert('Delete error: '+e);});}\n";
        // heatmap (integrated into serial gen)
        pg << "var hmCanvas=$('heatmapCanvas'),hmCtx=hmCanvas.getContext('2d');\n"
              "var hmTip=$('htip'),hmData=null,hmVisible=false,hmTiles=[],hmFlatMode=false,hmBaseline=0;\n";
        pg << "function toggleHM(){\n"
              "hmVisible=!hmVisible;\n"
              "$('hmToggle').textContent=hmVisible?'\\u{1F525} Hide Heatmap':'\\u{1F525} Show Heatmap';\n"
              "if(hmVisible){calcH();}else{hmCanvas.style.display='none';hmCanvas.style.pointerEvents='none';}\n"
              "}\n";
        pg << "function calcH(){\n"
              "var body=new URLSearchParams({"
              "currentPrice:$('s_price').value,"
              "quantity:$('s_qty').value,"
              "portfolioPump:$('s_pump').value,"
              "feeHedgingCoefficient:$('s_feeHedging').value,"
              "symbolCount:$('s_symCount').value,"
              "coefficientK:$('s_coeffK').value,"
              "feeSpread:$('s_feeSpread').value,"
              "deltaTime:$('s_deltaTime').value,"
              "surplusRate:$('s_surplus').value,"
              "gridSize:$('h_gridSize').value,"
              "axisX:$('h_axisX').value,axisY:$('h_axisY').value,"
              "xLo:$('h_xLo').value,xHi:$('h_xHi').value,"
              "yLo:$('h_yLo').value,yHi:$('h_yHi').value,"
              "axis3:$('h_axis3').value,axis4:$('h_axis4').value,"
              "z3Steps:$('h_z3Steps').value,z3Lo:$('h_z3Lo').value,z3Hi:$('h_z3Hi').value,"
              "z4Steps:$('h_z4Steps').value,z4Lo:$('h_z4Lo').value,z4Hi:$('h_z4Hi').value});\n"
              "fetch('/api/calc/heatmap',{method:'POST',body:body})"
              ".then(function(r){return r.json();})"
              ".then(function(d){\n"
              "if(d.error)return;hmData=d;\n"
              "var minEo=Infinity,maxEo=0;\n"
              "d.slices.forEach(function(sl){sl.rows.forEach(function(row){row.forEach(function(c){\n"
              "if(c.eo<minEo)minEo=c.eo;if(c.eo>maxEo)maxEo=c.eo;});});});\n"
              "var flat=(maxEo-minEo)<0.0001;\n"
              "$('heatmap-stats').innerHTML="
              "'<div><span class=lbl>Min OH: </span><span class=val>'+minEo.toFixed(4)+'%</span></div>'+\n"
              "'<div><span class=lbl>Max OH: </span><span class=val>'+maxEo.toFixed(4)+'%</span></div>'+\n"
              "'<div><span class=lbl>Tiles: </span><span class=val>'+d.slices.length+'</span></div>'+\n"
              "'<div><span class=lbl>Grid: </span><span class=val>'+d.gridSize+'\\u00D7'+d.gridSize+'</span></div>'+\n"
              "(flat?'<div style=\"color:#f59e0b;width:100%\">Low variation \\u2014 showing delta from baseline</div>':'');\n"
              "drawH();}).catch(function(e){console.warn('heatmap:',e);});}\n";
        // heatmap color: low overhead = green (easy TP), high overhead = red (hard TP)
        pg << "function eoColor(eo,mn,mx){\n"
              "var t=(mx>mn)?(eo-mn)/(mx-mn):0.5;t=Math.max(0,Math.min(1,t));\n"
              "var r,g,b;\n"
              "if(t<0.5){var s=t*2;r=Math.round(40+s*180);g=Math.round(180-s*80);b=Math.round(80-s*40);}\n"
              "else{var s=(t-0.5)*2;r=Math.round(220+s*35);g=Math.round(100-s*70);b=Math.round(40-s*20);}\n"
              "return 'rgb('+r+','+g+','+b+')';}\n"
              "function fmtD(v){var a=Math.abs(v);"
              "if(a<1e-6)return v.toExponential(2);"
              "if(a<0.01)return v.toFixed(6);"
              "return v.toFixed(4);}\n";
        // drawH ï¿½ renders single tile or small-multiples trellis
        pg << "function drawH(){\n"
              "if(!hmData||!hmVisible||currentMode!=='serial'){hmCanvas.style.display='none';hmCanvas.style.pointerEvents='none';return;}\n"
              "hmCanvas.style.display='block';hmCanvas.style.pointerEvents='auto';\n"
              "var dpr=window.devicePixelRatio||1;\n"
              "hmCanvas.width=W*dpr;hmCanvas.height=H*dpr;\n"
              "hmCanvas.style.width=W+'px';hmCanvas.style.height=H+'px';\n"
              "hmCtx.setTransform(dpr,0,0,dpr,0,0);\n"
              "hmCtx.clearRect(0,0,W,H);hmCtx.fillStyle='#0b1426';hmCtx.fillRect(0,0,W,H);\n"
              "var d=hmData,N=d.gridSize;\n"
              "var nC=d.z3Steps,nR=d.z4Steps,multi=(nC>1||nR>1);\n"
              "var AN={pump:'Pump',qty:'Qty',feeSpread:'FeeSprd',feeHedging:'FeeHdg',"
              "deltaTime:'DeltaT',surplus:'Surplus',coeffK:'CoeffK',symbols:'Syms',none:''};\n"
              "var xN=AN[d.axisX]||d.axisX,yN=AN[d.axisY]||d.axisY;\n"
              "var a3N=AN[d.axis3]||'',a4N=AN[d.axis4]||'';\n"
              "var xAbs=Math.abs(d.baseX)<1e-12,yAbs=Math.abs(d.baseY)<1e-12;\n"
              "var a3Abs=Math.abs(d.base3)<1e-12,a4Abs=Math.abs(d.base4)<1e-12;\n";
        // global min/max + layout
        pg << "var gMin=Infinity,gMax=0;\n"
              "d.slices.forEach(function(sl){sl.rows.forEach(function(r){r.forEach(function(c){\n"
              "if(c.eo<gMin)gMin=c.eo;if(c.eo>gMax)gMax=c.eo;});});});\n"
              "hmFlatMode=(gMax-gMin)<0.01;hmBaseline=0;\n"
              "if(hmFlatMode){var sum=0,cnt=0;\n"
              "d.slices.forEach(function(sl){sl.rows.forEach(function(r){r.forEach(function(c){sum+=c.eo;cnt++;});});});\n"
              "hmBaseline=cnt>0?sum/cnt:0;gMin=Infinity;gMax=-Infinity;\n"
              "d.slices.forEach(function(sl){sl.rows.forEach(function(r){r.forEach(function(c){var dv=c.eo-hmBaseline;\n"
              "if(dv<gMin)gMin=dv;if(dv>gMax)gMax=dv;});});});\n"
              "var mxA=Math.max(Math.abs(gMin),Math.abs(gMax),1e-10);gMin=-mxA;gMax=mxA;}\n"
              "var chH=nC>1?16:0,rhW=nR>1?52:0;\n"
              "var P={l:(multi?28:55)+rhW,r:55,t:26+chH,b:multi?28:45};\n"
              "var gap=multi?5:0;\n"
              "var aW=W-P.l-P.r,aH=H-P.t-P.b;\n"
              "var tW=(aW-(nC-1)*gap)/nC,tH=(aH-(nR-1)*gap)/nR;\n"
              "hmTiles=[];\n";
        // render each slice tile
        pg << "d.slices.forEach(function(sl,si){\n"
              "var c3=si%nC,r4=Math.floor(si/nC);\n"
              "var tx=P.l+c3*(tW+gap),ty=P.t+r4*(tH+gap);\n"
              "var cw=tW/N,ch=tH/N;\n"
              "hmTiles.push({x:tx,y:ty,w:tW,h:tH,si:si,cw:cw,ch:ch});\n"
              "if(multi){hmCtx.strokeStyle='#1a2744';hmCtx.lineWidth=0.5;hmCtx.strokeRect(tx,ty,tW,tH);}\n"
              "for(var yi=0;yi<N;yi++){var row=sl.rows[N-1-yi];\n"
              "for(var xi=0;xi<N;xi++){\n"
              "var val=hmFlatMode?(row[xi].eo-hmBaseline):row[xi].eo;\n"
              "hmCtx.fillStyle=eoColor(val,gMin,gMax);\n"
              "hmCtx.globalAlpha=0.82;\n"
              "hmCtx.fillRect(tx+xi*cw,ty+yi*ch,cw-(multi?0.3:0.8),ch-(multi?0.3:0.8));\n"
              "hmCtx.globalAlpha=1.0;\n"
              "if(!multi&&cw>30&&ch>18){\n"
              "hmCtx.fillStyle='#fff';hmCtx.font='bold 9px monospace';hmCtx.textAlign='center';\n"
              "hmCtx.fillText(hmFlatMode?((val>=0?'+':'')+fmtD(val)+'%'):(val.toFixed(2)+'%'),tx+xi*cw+cw/2,ty+yi*ch+ch/2+3);}}}\n"
              "if(r4===0&&nC>1){hmCtx.fillStyle='#c9a44a';hmCtx.font='bold 8px monospace';hmCtx.textAlign='center';\n"
              "hmCtx.fillText(a3N+'='+(a3Abs?sl.z3v.toFixed(1):sl.z3m.toFixed(1)+'x'),tx+tW/2,ty-3);}\n"
              "if(c3===0&&nR>1){hmCtx.fillStyle='#c9a44a';hmCtx.font='bold 8px monospace';hmCtx.textAlign='right';\n"
              "hmCtx.fillText(a4N+'='+(a4Abs?sl.z4v.toFixed(1):sl.z4m.toFixed(1)+'x'),tx-4,ty+tH/2+3);}\n"
              "});\n";
        // axis ticks
        pg << "hmCtx.fillStyle='#64748b';hmCtx.font=(multi?'7':'9')+'px monospace';\n"
              "var nt=multi?2:Math.min(N,6);\n"
              // x ticks (bottom row)
              "hmCtx.textAlign='center';\n"
              "for(var c3=0;c3<nC;c3++){var tx=P.l+c3*(tW+gap),bty=P.t+(nR-1)*(tH+gap)+tH;\n"
              "for(var ti=0;ti<nt;ti++){var xi=Math.round(ti*(N-1)/Math.max(1,nt-1));\n"
              "var xm=d.xLo+(d.xHi-d.xLo)*(N>1?xi/(N-1):0);\n"
              "hmCtx.fillText(xAbs?xm.toFixed(1):xm.toFixed(1)+'x',tx+xi*(tW/N)+(tW/N)/2,bty+(multi?8:12));}}\n"
              // y ticks (leftmost column)
              "hmCtx.textAlign='right';\n"
              "for(var r4=0;r4<nR;r4++){var ty=P.t+r4*(tH+gap);\n"
              "for(var ti=0;ti<nt;ti++){var yi=Math.round(ti*(N-1)/Math.max(1,nt-1));\n"
              "var ym=d.yLo+(d.yHi-d.yLo)*(N>1?(N-1-yi)/(N-1):0);\n"
              "hmCtx.fillText(yAbs?ym.toFixed(1):ym.toFixed(1)+'x',P.l-3,ty+yi*(tH/N)+(tH/N)/2+3);}}\n";
        // axis labels + title + legend
        pg << "hmCtx.fillStyle='#cbd5e1';hmCtx.font='9px monospace';hmCtx.textAlign='center';\n"
              "hmCtx.fillText('\\u2190 '+xN+(xAbs?' (abs)':'')+' \\u2192',W/2,H-3);\n"
              "hmCtx.save();hmCtx.translate(10,H/2);hmCtx.rotate(-Math.PI/2);\n"
              "hmCtx.fillText('\\u2190 '+yN+(yAbs?' (abs)':'')+' \\u2192',0,0);hmCtx.restore();\n"
              "hmCtx.textAlign='center';hmCtx.font='bold 11px monospace';hmCtx.fillStyle='#c9a44a';\n"
              "var ttl=hmFlatMode?('OH \\u0394 from '+hmBaseline.toFixed(2)+'%: '+xN+' vs '+yN):('Eff OH: '+xN+' vs '+yN);\n"
              "if(d.axis3!=='none')ttl+=' | '+a3N;\n"
              "if(d.axis4!=='none')ttl+=' \\u00D7 '+a4N;\n"
              "hmCtx.fillText(ttl,W/2,13);\n"
              "var lx=W-P.r+8,ly=P.t,lh=H-P.t-P.b;\n"
              "for(var i=0;i<lh;i++){hmCtx.fillStyle=eoColor(gMin+(i/lh)*(gMax-gMin),gMin,gMax);hmCtx.fillRect(lx,ly+i,12,1);}\n"
              "hmCtx.fillStyle='#cbd5e1';hmCtx.font='7px monospace';hmCtx.textAlign='left';\n"
              "hmCtx.fillText((hmFlatMode?(gMin>=0?'+':'')+fmtD(gMin):gMin.toFixed(2))+'%',lx+14,ly+7);\n"
              "hmCtx.fillText((hmFlatMode?(gMax>=0?'+':'')+fmtD(gMax):gMax.toFixed(2))+'%',lx+14,ly+lh);\n"
              "hmCtx.fillText(hmFlatMode?'better':'easy',lx+14,ly+17);hmCtx.fillText(hmFlatMode?'worse':'hard',lx+14,ly+lh-8);\n";
        // crosshair (single tile only)
        pg << "if(!multi&&!xAbs&&!yAbs&&hmTiles.length){\n"
              "var cx1=(d.xHi>d.xLo)?(1-d.xLo)/(d.xHi-d.xLo):0.5;\n"
              "var cy1=(d.yHi>d.yLo)?(1-d.yLo)/(d.yHi-d.yLo):0.5;\n"
              "if(cx1>=0&&cx1<=1&&cy1>=0&&cy1<=1){\n"
              "var t0=hmTiles[0],crX=t0.x+cx1*t0.w,crY=t0.y+(1-cy1)*t0.h;\n"
              "hmCtx.save();hmCtx.strokeStyle='#c9a44a';hmCtx.lineWidth=1.5;hmCtx.setLineDash([6,4]);\n"
              "hmCtx.beginPath();hmCtx.moveTo(crX,t0.y);hmCtx.lineTo(crX,t0.y+t0.h);hmCtx.stroke();\n"
              "hmCtx.beginPath();hmCtx.moveTo(t0.x,crY);hmCtx.lineTo(t0.x+t0.w,crY);hmCtx.stroke();\n"
              "hmCtx.setLineDash([]);hmCtx.fillStyle='#c9a44a';hmCtx.beginPath();\n"
              "hmCtx.arc(crX,crY,4,0,Math.PI*2);hmCtx.fill();\n"
              "hmCtx.font='bold 9px monospace';hmCtx.textAlign='left';\n"
              "hmCtx.fillText('1x,1x',crX+6,crY-6);hmCtx.restore();}}\n"
              // TP markers
              "if(lastSerialResult&&lastSerialResult.levels){\n"
              "hmCtx.font='bold 8px monospace';hmCtx.textAlign='right';\n"
              "lastSerialResult.levels.forEach(function(lv){\n"
              "if(lv.tp<=0||lv.entry<=0)return;hmCtx.fillStyle='#22c55e';\n"
              "hmCtx.fillText('L'+lv.index+': '+((lv.tp-lv.entry)/lv.entry*100).toFixed(1)+'%',W-P.r-2,P.t+10+lv.index*10);});}\n"
              "}\n";
        // trellis-aware tooltip
        pg << "hmCanvas.addEventListener('mousemove',function(e){\n"
              "if(!hmData||!hmVisible||currentMode!=='serial'||!hmTiles){hmTip.style.display='none';return;}\n"
              "var r=hmCanvas.getBoundingClientRect(),mx=e.clientX-r.left,my=e.clientY-r.top;\n"
              "var d=hmData,N=d.gridSize,tile=null;\n"
              "for(var i=0;i<hmTiles.length;i++){var t=hmTiles[i];\n"
              "if(mx>=t.x&&mx<t.x+t.w&&my>=t.y&&my<t.y+t.h){tile=t;break;}}\n"
              "if(!tile){hmTip.style.display='none';return;}\n"
              "var xi=Math.floor((mx-tile.x)/tile.cw),yi=Math.floor((my-tile.y)/tile.ch);\n"
              "if(xi<0||xi>=N||yi<0||yi>=N){hmTip.style.display='none';return;}\n"
              "var sl=d.slices[tile.si],c=sl.rows[N-1-yi][xi];\n"
              "var fmt=function(b,m,v){return Math.abs(b)<1e-12?v.toFixed(4):(m.toFixed(2)+'x = '+v.toFixed(4));};\n"
              "var txt=d.axisX+': '+fmt(d.baseX,c.xm,c.xv)+'\\n'+d.axisY+': '+fmt(d.baseY,c.ym,c.yv);\n"
              "if(d.axis3!=='none')txt+='\\n'+d.axis3+': '+fmt(d.base3,sl.z3m,sl.z3v);\n"
              "if(d.axis4!=='none')txt+='\\n'+d.axis4+': '+fmt(d.base4,sl.z4m,sl.z4v);\n"
              "txt+='\\nEff OH: '+c.eo.toFixed(4)+'%';\n"
              "if(hmFlatMode){var dv=c.eo-hmBaseline;txt+='\\n\\u0394: '+(dv>=0?'+':'')+fmtD(dv)+'%';}\n"
              "txt+='\\nRaw OH: '+fmtD(c.oh)+'%';\n"
              "hmTip.textContent=txt;hmTip.style.display='block';\n"
              "hmTip.style.left=(mx+14)+'px';hmTip.style.top=(my-10)+'px';});\n"
              "hmCanvas.addEventListener('mouseleave',function(){hmTip.style.display='none';});\n";
        // expose functions used by inline onclick handlers to global scope
        pg << "window.loadPortfolio=loadPortfolio;window.calcE=calcE;window.calcS=calcS;\n"
              "window.saveModel=saveModel;window.loadModel=loadModel;window.deleteModel=deleteModel;\n"
              "window.toggleHM=toggleHM;window.calcH=calcH;\n";
        // init
        pg << "$('saveEntryBtn').addEventListener('click',saveEntry);\n"
              "$('saveSerialBtn').addEventListener('click',saveSerial);\n"
              "setupE();setupS();resize();loadPortfolio();refreshModels();\n"
              "})();\n</script></body></html>";
        res.set_content(pg.str(), "text/html");
    });
}
===== Routes_Core.h ===== 
#pragma once

#include "AppContext.h"
#include "HtmlHelpers.h"
#include "ProfitCalculator.h"
#include <mutex>
#include <algorithm>

inline void registerCoreRoutes(httplib::Server& svr, AppContext& ctx)
{
    auto& db = ctx.defaultDb;
    auto& dbMutex = ctx.dbMutex;

    // ========== GET / — Dashboard ==========
    svr.Get("/", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << html::msgBanner(req) << html::errBanner(req);
        h << "<h1>Quant Trade Manager</h1>";

        double wal = db.loadWalletBalance();
        double dep = db.deployedCapital();
        auto trades = db.loadTrades();
        int buys = 0, sells = 0;
        for (const auto& t : trades) { if (t.type == TradeType::Buy) ++buys; else ++sells; }

        h << "<div class='row'>"
             "<div class='stat'><div class='lbl'>Liquid</div><div class='val'>" << wal << "</div></div>"
             "<div class='stat'><div class='lbl'>Deployed</div><div class='val'>" << dep << "</div></div>"
             "<div class='stat'><div class='lbl'>Total</div><div class='val'>" << (wal + dep) << "</div></div>"
             "<div class='stat'><div class='lbl'>Buys</div><div class='val'>" << buys << "</div></div>"
             "<div class='stat'><div class='lbl'>Sells</div><div class='val'>" << sells << "</div></div>"
             "</div>";

        if (!trades.empty())
        {
            // collect parents, then render tree
            std::vector<const Trade*> parents;
            for (const auto& t : trades)
                if (t.type == TradeType::Buy) parents.push_back(&t);

            h << "<h2>Trades</h2><table><tr>"
                 "<th>ID</th><th>Symbol</th><th>Type</th><th>Price</th><th>Qty</th>"
                 "<th>Cost</th><th>Fees</th><th>TP</th><th>SL</th><th>SL?</th>"
                 "<th>Sold</th><th>Rem</th><th>Realized</th>"
                 "</tr>";

            for (const auto* bp : parents)
            {
                const Trade& b = *bp;
                double sold = db.soldQuantityForParent(b.tradeId);
                double remaining = b.quantity - sold;
                double grossCost = b.value * b.quantity;
                double totalFees = b.buyFee + b.sellFee;
                double realized = 0;
                std::vector<const Trade*> children;
                for (const auto& c : trades)
                {
                    if (c.type == TradeType::CoveredSell && c.parentTradeId == b.tradeId)
                    {
                        children.push_back(&c);
                        auto cp = ProfitCalculator::childProfit(c, b.value);
                        realized += cp.netProfit;
                    }
                }

                h << "<tr>"
                  << "<td><strong>" << b.tradeId << "</strong></td>"
                  << "<td><strong>" << html::esc(b.symbol) << "</strong></td>"
                  << "<td class='buy'>BUY</td>"
                  << "<td>" << b.value << "</td><td>" << b.quantity << "</td>"
                  << "<td>" << grossCost << "</td>"
                  << "<td>" << totalFees << "</td>"
                  << "<td>" << b.takeProfit << "</td><td>" << b.stopLoss << "</td>"
                  << "<td class='" << (b.stopLossActive ? "on" : "off") << "'>"
                  << (b.stopLossActive ? "ON" : "OFF") << "</td>"
                  << "<td>" << sold << "</td><td>" << remaining << "</td>"
                  << "<td class='" << (realized >= 0 ? "buy" : "sell") << "'>" << realized << "</td>"
                  << "</tr>";

                for (const auto* cp : children)
                {
                    const Trade& c = *cp;
                    auto profit = ProfitCalculator::childProfit(c, b.value);
                    h << "<tr class='child-row'>"
                      << "<td><span class='child-indent'>&#9492;&#9472;</span>" << c.tradeId << "</td>"
                      << "<td>" << html::esc(c.symbol) << "</td>"
                      << "<td class='sell'>SELL</td>"
                      << "<td>" << c.value << "</td><td>" << c.quantity << "</td>"
                      << "<td>" << (c.value * c.quantity) << "</td>"
                      << "<td>" << c.sellFee << "</td>"
                      << "<td>-</td><td>-</td><td>-</td>"
                      << "<td>-</td><td>-</td>"
                      << "<td class='" << (profit.netProfit >= 0 ? "buy" : "sell") << "'>"
                      << profit.netProfit << "</td></tr>";
                }
            }
            h << "</table>";
        }
        res.set_content(html::wrap("Dashboard", h.str()), "text/html");
    });

    // ========== GET /wallet ==========
    svr.Get("/wallet", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << html::msgBanner(req) << html::errBanner(req);
        h << "<h1>Wallet</h1>";
        double bal = db.loadWalletBalance();
        double dep = db.deployedCapital();
        h << "<div class='row'>"
             "<div class='stat'><div class='lbl'>Liquid</div><div class='val'>" << bal << "</div></div>"
             "<div class='stat'><div class='lbl'>Deployed</div><div class='val'>" << dep << "</div></div>"
             "<div class='stat'><div class='lbl'>Total</div><div class='val'>" << (bal + dep) << "</div></div>"
             "</div>";
        h << "<div class='forms-row'>"
             "<form class='card' method='POST' action='/deposit'><h3>Deposit</h3>"
             "<label>Amount</label><input type='number' name='amount' step='any' required> "
             "<button>Deposit</button></form>"
             "<form class='card' method='POST' action='/withdraw'><h3>Withdraw</h3>"
             "<label>Amount</label><input type='number' name='amount' step='any' required> "
             "<button class='btn-warn'>Withdraw</button></form>"
             "</div>";
        {
            auto trades = db.loadTrades();
            std::vector<std::string> syms;
            for (const auto& t : trades)
                if (std::find(syms.begin(), syms.end(), t.symbol) == syms.end())
                    syms.push_back(t.symbol);
            if (!syms.empty())
            {
                h << "<h2>Allocated (In Trades)</h2>"
                     "<table><tr><th>Symbol</th><th>Qty</th><th>Avg Entry</th>"
                     "<th>Value</th><th>Trades</th></tr>";
                for (const auto& sym : syms)
                {
                    double allocQty = 0, allocValue = 0;
                    int tradeCount = 0;
                    for (const auto& t : trades)
                    {
                        if (t.symbol != sym || t.type != TradeType::Buy) continue;
                        double sold = db.soldQuantityForParent(t.tradeId);
                        double released = db.releasedForTrade(t.tradeId);
                        double rem = t.quantity - sold - released;
                        if (rem <= 0) continue;
                        allocQty += rem;
                        allocValue += t.value * rem;
                        ++tradeCount;
                    }
                    if (allocQty <= 0) continue;
                    double avgEntry = allocValue / allocQty;
                    h << "<tr><td>" << html::esc(sym) << "</td>"
                      << "<td>" << allocQty << "</td>"
                      << "<td>" << avgEntry << "</td>"
                      << "<td>" << allocValue << "</td>"
                      << "<td>" << tradeCount << "</td></tr>";
                }
                h << "</table>";
                h << "<h2>Not Allocated (Free Holdings)</h2>"
                     "<table><tr><th>Symbol</th><th>Net Holdings</th>"
                     "<th>In Trades</th><th>Free</th></tr>";
                for (const auto& sym : syms)
                {
                    double net = db.holdingsForSymbol(sym);
                    double allocQty = 0;
                    for (const auto& t : trades)
                    {
                        if (t.symbol != sym || t.type != TradeType::Buy) continue;
                        double sold = db.soldQuantityForParent(t.tradeId);
                        double released = db.releasedForTrade(t.tradeId);
                        double rem = t.quantity - sold - released;
                        if (rem > 0) allocQty += rem;
                    }
                    double free = net - allocQty;
                    h << "<tr><td>" << html::esc(sym) << "</td>"
                      << "<td>" << net << "</td>"
                      << "<td>" << allocQty << "</td>"
                      << "<td>" << free << "</td></tr>";
                }
                h << "</table>";
                h << "<h2>Deallocate</h2>"
                     "<form class='card' method='POST' action='/deallocate'>"
                     "<h3>Release holdings from a trade to free pool</h3>"
                     "<label>Trade ID</label><input type='number' name='tradeId' required><br>"
                     "<label>Quantity</label><input type='number' name='quantity' step='any' required><br>"
                     "<button class='btn-warn'>Deallocate</button></form>";
            }
        }
        res.set_content(html::wrap("Wallet", h.str()), "text/html");
    });

    // ========== POST /deposit ==========
    svr.Post("/deposit", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        double amt = fd(f, "amount");
        if (amt <= 0) { res.set_redirect("/wallet?err=Amount+must+be+positive", 303); return; }
        db.deposit(amt);
        res.set_redirect("/wallet?msg=Deposited+successfully", 303);
    });

    // ========== POST /withdraw ==========
    svr.Post("/withdraw", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        double amt = fd(f, "amount");
        if (amt <= 0) { res.set_redirect("/wallet?err=Amount+must+be+positive", 303); return; }
        double bal = db.loadWalletBalance();
        if (amt > bal) { res.set_redirect("/wallet?err=Insufficient+balance", 303); return; }
        db.withdraw(amt);
        res.set_redirect("/wallet?msg=Withdrawn+successfully", 303);
    });

    // ========== POST /deallocate ==========
    svr.Post("/deallocate", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        int id = fi(f, "tradeId");
        double qty = fd(f, "quantity");
        if (qty <= 0) { res.set_redirect("/wallet?err=Quantity+must+be+positive", 303); return; }
        if (!db.releaseFromTrade(id, qty))
        {
            res.set_redirect("/wallet?err=Deallocate+failed+(invalid+trade+or+qty+exceeds+allocated)", 303);
            return;
        }
        res.set_redirect("/wallet?msg=Deallocated+from+trade+" + std::to_string(id), 303);
    });

    // ========== GET /portfolio ==========
    svr.Get("/portfolio", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << html::msgBanner(req);
        h << "<h1>Portfolio</h1>";
        auto trades = db.loadTrades();
        double totalCost = 0;
        int buyCount = 0, sellCount = 0;
        std::vector<std::string> seen;
        h << "<table><tr><th>Symbol</th><th>Buys</th><th>Sells</th>"
             "<th>Qty</th><th>Cost</th></tr>";
        for (const auto& t : trades)
        {
            if (std::find(seen.begin(), seen.end(), t.symbol) != seen.end()) continue;
            seen.push_back(t.symbol);
            double sc = 0, sq = 0; int b = 0, s = 0;
            for (const auto& u : trades)
            {
                if (u.symbol != t.symbol) continue;
                if (u.type == TradeType::Buy) { sc += u.value * u.quantity; sq += u.quantity; ++b; }
                else ++s;
            }
            h << "<tr><td>" << html::esc(t.symbol) << "</td><td>" << b << "</td><td>" << s
              << "</td><td>" << sq << "</td><td>" << sc << "</td></tr>";
            totalCost += sc; buyCount += b; sellCount += s;
        }
        h << "</table>";
        double wal = db.loadWalletBalance();
        h << "<div class='row'>"
             "<div class='stat'><div class='lbl'>Total Cost</div><div class='val'>" << totalCost << "</div></div>"
             "<div class='stat'><div class='lbl'>Buys</div><div class='val'>" << buyCount << "</div></div>"
             "<div class='stat'><div class='lbl'>Sells</div><div class='val'>" << sellCount << "</div></div>"
             "<div class='stat'><div class='lbl'>Wallet</div><div class='val'>" << wal << "</div></div>"
             "<div class='stat'><div class='lbl'>Total</div><div class='val'>" << (wal + totalCost) << "</div></div>"
             "</div>";
        res.set_content(html::wrap("Portfolio", h.str()), "text/html");
    });

    // ========== GET /dca ==========
    svr.Get("/dca", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << "<h1>DCA Tracker</h1>";
        auto trades = db.loadTrades();
        std::vector<std::string> seen;
        h << "<table><tr><th>Symbol</th><th>Buys</th><th>Qty</th><th>Cost</th>"
             "<th>Avg Entry</th><th>Low</th><th>High</th><th>Spread</th></tr>";
        for (const auto& t : trades)
        {
            if (t.type != TradeType::Buy) continue;
            if (std::find(seen.begin(), seen.end(), t.symbol) != seen.end()) continue;
            seen.push_back(t.symbol);
            double cost = 0, qty = 0, lo = 1e18, hi = 0; int cnt = 0;
            for (const auto& u : trades)
            {
                if (u.symbol != t.symbol || u.type != TradeType::Buy) continue;
                cost += u.value * u.quantity; qty += u.quantity;
                if (u.value < lo) lo = u.value;
                if (u.value > hi) hi = u.value;
                ++cnt;
            }
            double avg = qty != 0 ? cost / qty : 0;
            h << "<tr><td>" << html::esc(t.symbol) << "</td><td>" << cnt
              << "</td><td>" << qty << "</td><td>" << cost << "</td><td>" << avg
              << "</td><td>" << lo << "</td><td>" << hi << "</td><td>" << (hi - lo) << "</td></tr>";
        }
        h << "</table>";
        if (seen.empty()) h << "<p class='empty'>(no buy trades)</p>";
        res.set_content(html::wrap("DCA", h.str()), "text/html");
    });

    // ========== GET /pnl — P&L Curve ==========
    svr.Get("/pnl", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto pnl = db.loadPnl();
        // also build synthetic entries from existing child sells if ledger is empty
        auto trades = db.loadTrades();

        std::ostringstream pg;
        pg << "<!DOCTYPE html><html><head><meta charset='utf-8'>"
              "<meta name='viewport' content='width=device-width,initial-scale=1'>"
              "<title>P&amp;L - Quant</title>" << html::css()
           << "<style>"
              ".pnl-wrap{position:relative;width:100%;height:500px;margin:16px 0;background:#0f1b2d;"
              "border:1px solid #1a2744;border-radius:8px;overflow:hidden;}"
              ".pnl-wrap canvas{display:block;width:100%;height:100%;}"
              ".pnl-tip{position:absolute;background:#0f1b2dee;border:1px solid #1a2744;border-radius:6px;"
              "padding:6px 10px;font-size:0.78em;color:#cbd5e1;pointer-events:none;display:none;white-space:pre;z-index:10;}"
              "</style></head><body>" << html::nav()
           << "<div class='container'>"
              << html::msgBanner(req) << html::errBanner(req)
              << "<h1>P&amp;L Curve</h1>";

        // stats
        double totalNet = 0, totalGross = 0;
        int tradeCount = 0;
        if (!pnl.empty())
        {
            totalNet = pnl.back().cumProfit;
            for (const auto& e : pnl) { totalGross += e.grossProfit; ++tradeCount; }
        }
        pg << std::fixed << std::setprecision(2);
        pg << "<div class='row'>"
              "<div class='stat'><div class='lbl'>Total Net P&amp;L</div>"
              "<div class='val " << (totalNet >= 0 ? "buy" : "sell") << "'>" << totalNet << "</div></div>"
              "<div class='stat'><div class='lbl'>Total Gross</div><div class='val'>" << totalGross << "</div></div>"
              "<div class='stat'><div class='lbl'>Trades</div><div class='val'>" << tradeCount << "</div></div>"
              "</div>";

        pg << "<div class='pnl-wrap' id='pnlWrap'>"
              "<canvas id='pnlCanvas'></canvas>"
              "<div class='pnl-tip' id='pnlTip'></div></div>";

        // trade log table
        if (!pnl.empty())
        {
            pg << std::fixed << std::setprecision(17);
            pg << "<h2>Realized Trades</h2>"
                  "<table><tr><th>Time</th><th>Symbol</th><th>Sell</th><th>Parent</th>"
                  "<th>Entry</th><th>Exit</th><th>Qty</th><th>Gross</th><th>Net</th><th>Cumulative</th></tr>";
            for (const auto& e : pnl)
            {
                // format timestamp
                std::time_t tt = static_cast<std::time_t>(e.timestamp);
                std::tm tm;
#ifdef _WIN32
                localtime_s(&tm, &tt);
#else
                localtime_r(&tt, &tm);
#endif
                char tbuf[32];
                std::strftime(tbuf, sizeof(tbuf), "%Y-%m-%d %H:%M", &tm);
                pg << "<tr><td>" << tbuf << "</td>"
                   << "<td>" << html::esc(e.symbol) << "</td>"
                   << "<td>" << e.sellTradeId << "</td><td>" << e.parentTradeId << "</td>"
                   << "<td>" << e.entryPrice << "</td><td>" << e.sellPrice << "</td>"
                   << "<td>" << e.quantity << "</td>"
                   << "<td>" << e.grossProfit << "</td>"
                   << "<td class='" << (e.netProfit >= 0 ? "buy" : "sell") << "'>" << e.netProfit << "</td>"
                   << "<td class='" << (e.cumProfit >= 0 ? "buy" : "sell") << "'>" << e.cumProfit << "</td></tr>";
            }
            pg << "</table>";
        }
        else
        {
            pg << "<p class='empty'>(no realized P&amp;L yet &mdash; execute sells from the exit strategy to record P&amp;L)</p>";
        }

        pg << "</div>"; // container

        // JavaScript chart
        pg << "<script>\n(function(){\n'use strict';\n";
        // embed data
        pg << "var data=[";
        {
            bool first = true;
            pg << std::fixed << std::setprecision(8);
            for (const auto& e : pnl)
            {
                if (!first) pg << ",";
                first = false;
                pg << "{ts:" << e.timestamp
                   << ",sym:'" << e.symbol << "'"
                   << ",net:" << e.netProfit
                   << ",cum:" << e.cumProfit
                   << ",qty:" << e.quantity
                   << ",entry:" << e.entryPrice
                   << ",sell:" << e.sellPrice
                   << "}";
            }
        }
        pg << "];\n";

        pg << "var canvas=document.getElementById('pnlCanvas');\n"
              "var ctx=canvas.getContext('2d');\n"
              "var wrap=document.getElementById('pnlWrap');\n"
              "var tip=document.getElementById('pnlTip');\n"
              "var dpr=window.devicePixelRatio||1;\n"
              "var W,H;\n"
              "var pad={t:30,r:30,b:50,l:80};\n";

        pg << "function resize(){\n"
              "  W=wrap.clientWidth;H=wrap.clientHeight;\n"
              "  canvas.width=W*dpr;canvas.height=H*dpr;\n"
              "  canvas.style.width=W+'px';canvas.style.height=H+'px';\n"
              "  ctx.setTransform(dpr,0,0,dpr,0,0);\n"
              "  draw();\n"
              "}\n";

        pg << "function draw(){\n"
              "  ctx.clearRect(0,0,W,H);\n"
              "  if(data.length<1){ctx.fillStyle='#475569';ctx.font='14px monospace';"
              "ctx.fillText('No P&L data yet',W/2-60,H/2);return;}\n"
              "  var pw=W-pad.l-pad.r, ph=H-pad.t-pad.b;\n"
              // time range
              "  var tsMin=data[0].ts,tsMax=data[data.length-1].ts;\n"
              "  if(tsMax===tsMin) tsMax=tsMin+1;\n"
              // value range — always include 0
              "  var vMin=0,vMax=0;\n"
              "  for(var i=0;i<data.length;i++){var c=data[i].cum;if(c<vMin)vMin=c;if(c>vMax)vMax=c;}\n"
              "  var vPad=(vMax-vMin)*0.1||1;\n"
              "  vMin-=vPad;vMax+=vPad;\n"
              // mapping functions
              "  function tx(ts){return pad.l+((ts-tsMin)/(tsMax-tsMin))*pw;}\n"
              "  function ty(v){return pad.t+ph-((v-vMin)/(vMax-vMin))*ph;}\n"
              // grid
              "  ctx.strokeStyle='#152238';ctx.lineWidth=1;\n"
              "  var ySteps=6;\n"
              "  for(var i=0;i<=ySteps;i++){\n"
              "    var v=vMin+(vMax-vMin)*(i/ySteps);\n"
              "    var y=ty(v);\n"
              "    ctx.beginPath();ctx.moveTo(pad.l,y);ctx.lineTo(W-pad.r,y);ctx.stroke();\n"
              "    ctx.fillStyle='#64748b';ctx.font='11px monospace';ctx.textAlign='right';\n"
              "    ctx.fillText(v.toFixed(2),pad.l-6,y+4);\n"
              "  }\n"
              // time labels
              "  var xSteps=Math.min(data.length,8);\n"
              "  ctx.textAlign='center';\n"
              "  for(var i=0;i<xSteps;i++){\n"
              "    var idx=Math.floor(i*(data.length-1)/(xSteps-1||1));\n"
              "    var d=new Date(data[idx].ts*1000);\n"
              "    var lbl=d.toLocaleDateString(undefined,{month:'short',day:'numeric'});\n"
              "    var x=tx(data[idx].ts);\n"
              "    ctx.beginPath();ctx.moveTo(x,pad.t);ctx.lineTo(x,H-pad.b);ctx.strokeStyle='#152238';ctx.stroke();\n"
              "    ctx.fillStyle='#64748b';ctx.fillText(lbl,x,H-pad.b+16);\n"
              "  }\n"
              // zero line
              "  if(vMin<0&&vMax>0){\n"
              "    ctx.strokeStyle='#475569';ctx.lineWidth=1;ctx.setLineDash([4,4]);\n"
              "    ctx.beginPath();ctx.moveTo(pad.l,ty(0));ctx.lineTo(W-pad.r,ty(0));ctx.stroke();\n"
              "    ctx.setLineDash([]);\n"
              "  }\n"
              // area fill
              "  ctx.beginPath();ctx.moveTo(tx(data[0].ts),ty(0));\n"
              "  for(var i=0;i<data.length;i++) ctx.lineTo(tx(data[i].ts),ty(data[i].cum));\n"
              "  ctx.lineTo(tx(data[data.length-1].ts),ty(0));ctx.closePath();\n"
              "  var last=data[data.length-1].cum;\n"
              "  ctx.fillStyle=last>=0?'rgba(34,197,94,0.12)':'rgba(239,68,68,0.12)';\n"
              "  ctx.fill();\n"
              // line
              "  ctx.beginPath();\n"
              "  for(var i=0;i<data.length;i++){\n"
              "    var x=tx(data[i].ts),y=ty(data[i].cum);\n"
              "    if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);\n"
              "  }\n"
              "  ctx.strokeStyle=last>=0?'#22c55e':'#ef4444';ctx.lineWidth=2;ctx.stroke();\n"
              // dots
              "  for(var i=0;i<data.length;i++){\n"
              "    var x=tx(data[i].ts),y=ty(data[i].cum);\n"
              "    ctx.beginPath();ctx.arc(x,y,4,0,Math.PI*2);\n"
              "    ctx.fillStyle=data[i].net>=0?'#22c55e':'#ef4444';ctx.fill();\n"
              "    ctx.strokeStyle='#0b1426';ctx.lineWidth=1;ctx.stroke();\n"
              "  }\n"
              // axis labels
              "  ctx.save();ctx.translate(14,pad.t+ph/2);ctx.rotate(-Math.PI/2);\n"
              "  ctx.fillStyle='#64748b';ctx.font='12px monospace';ctx.textAlign='center';\n"
              "  ctx.fillText('Cumulative P&L',0,0);ctx.restore();\n"
              "  ctx.fillStyle='#64748b';ctx.font='12px monospace';ctx.textAlign='center';\n"
              "  ctx.fillText('Time',pad.l+pw/2,H-4);\n"
              // title
              "  ctx.fillStyle='#c9a44a';ctx.font='bold 14px monospace';ctx.textAlign='left';\n"
              "  ctx.fillText('P&L: '+(last>=0?'+':'')+last.toFixed(2),pad.l,18);\n"
              "}\n";

        // tooltip
        pg << "canvas.addEventListener('mousemove',function(ev){\n"
              "  if(data.length<1){tip.style.display='none';return;}\n"
              "  var rect=canvas.getBoundingClientRect();\n"
              "  var mx=ev.clientX-rect.left,my=ev.clientY-rect.top;\n"
              "  var pw=W-pad.l-pad.r;\n"
              "  var tsMin=data[0].ts,tsMax=data[data.length-1].ts;\n"
              "  if(tsMax===tsMin)tsMax=tsMin+1;\n"
              "  var best=-1,bestD=1e9;\n"
              "  for(var i=0;i<data.length;i++){\n"
              "    var x=pad.l+((data[i].ts-tsMin)/(tsMax-tsMin))*pw;\n"
              "    var d=Math.abs(x-mx);if(d<bestD){bestD=d;best=i;}\n"
              "  }\n"
              "  if(best<0||bestD>30){tip.style.display='none';return;}\n"
              "  var e=data[best];\n"
              "  var d=new Date(e.ts*1000);\n"
              "  tip.textContent=d.toLocaleString()+'\\n'"
              "+e.sym+' | '+e.qty.toFixed(4)+' qty\\n'"
              "+'Entry: '+e.entry.toFixed(4)+'  Exit: '+e.sell.toFixed(4)+'\\n'"
              "+'Net: '+(e.net>=0?'+':'')+e.net.toFixed(4)+'\\n'"
              "+'Cumulative: '+(e.cum>=0?'+':'')+e.cum.toFixed(4);\n"
              "  tip.style.display='block';\n"
              "  tip.style.left=(mx+14)+'px';tip.style.top=(my-10)+'px';\n"
              "});\n"
              "canvas.addEventListener('mouseleave',function(){tip.style.display='none';});\n";

        pg << "window.addEventListener('resize',resize);\n"
              "resize();\n"
              "})();\n</script></body></html>";

        res.set_content(pg.str(), "text/html");
    });

    // ========== GET /wipe ==========
    svr.Get("/wipe", [&](const httplib::Request& req, httplib::Response& res) {
        std::ostringstream h;
        h << html::msgBanner(req);
        h << "<h1>Wipe Database</h1>"
             "<p style='color:#ef4444;'>This will delete ALL trades, wallet balance, "
             "pending exits, entry points, and history.</p>"
             "<form class='card' method='POST' action='/do-wipe'>"
             "<button class='btn-danger'>Wipe Everything</button></form>"
             "<br><a class='btn' href='/'>Cancel</a>";
        res.set_content(html::wrap("Wipe", h.str()), "text/html");
    });

    // ========== POST /do-wipe ==========
    svr.Post("/do-wipe", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        db.clearAll();
        res.set_redirect("/?msg=Database+wiped", 303);
    });
}
===== Routes_Entry.h ===== 
#pragma once

#include "AppContext.h"
#include "HtmlHelpers.h"
#include "MarketEntryCalculator.h"
#include <mutex>
#include <algorithm>
#include <cmath>

inline void registerEntryRoutes(httplib::Server& svr, AppContext& ctx)
{
    auto& db = ctx.defaultDb;
    auto& dbMutex = ctx.dbMutex;

    // ========== GET /market-entry ï¿½ form ==========
    svr.Get("/market-entry", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << html::msgBanner(req) << html::errBanner(req);
        double walBal = db.loadWalletBalance();
        { bool canH = db.hasBuyTrades(); h << html::workflow(0, canH, canH); }
        h << "<h1>Market Entry Calculator</h1>"
             "<div class='row'><div class='stat'><div class='lbl'>Wallet</div><div class='val'>" << walBal << "</div></div></div><br>"
             "<form class='card' method='POST' action='/market-entry'><h3>Parameters</h3>"
             "<label>Symbol</label><input type='text' name='symbol' required><br>"
             "<label>Current Price</label><input type='number' name='currentPrice' step='any' required><br>"
             "<label>Quantity</label><input type='number' name='quantity' step='any' required><br>"
             "<label>Levels</label><input type='number' name='levels' value='4'><br>"
             "<label>Fee Hedging</label><input type='number' name='feeHedgingCoefficient' step='any' value='1'><br>"
             "<label>Pump</label><input type='number' name='portfolioPump' step='any' value='0'><br>"
             "<label>Symbol Count</label><input type='number' name='symbolCount' value='1'><br>"
             "<label>Coefficient K</label><input type='number' name='coefficientK' step='any' value='0'><br>"
             "<label>Fee Spread</label><input type='number' name='feeSpread' step='any' value='0'><br>"
             "<label>Delta Time</label><input type='number' name='deltaTime' step='any' value='1'><br>"
             "<label>Surplus Rate</label><input type='number' name='surplusRate' step='any' value='0.02'><br>"
             "<label>Max Risk</label><input type='number' name='maxRisk' step='any' value='0'><br>"
             "<label>Min Risk</label><input type='number' name='minRisk' step='any' value='0'><br>"
             "<label>Risk</label><input type='number' name='risk' step='any' value='0.5'><br>"
             "<label>Steepness</label><input type='number' name='steepness' step='any' value='6'><br>"
             "<label>Direction</label><select name='isShort'><option value='0'>LONG</option><option value='1'>SHORT</option></select><br>"
             "<label>Funding</label><select name='fundMode'><option value='1'>Pump only</option><option value='2'>Pump + Wallet</option></select><br>"
             "<label>Range Above</label><input type='number' name='rangeAbove' step='any' value='0'><br>"
             "<label>Range Below</label><input type='number' name='rangeBelow' step='any' value='0'><br>"
             "<button>Calculate</button></form>";
        res.set_content(html::wrap("Market Entry", h.str()), "text/html");
    });

    // ========== POST /market-entry ï¿½ compute + show results + execute form ==========
    svr.Post("/market-entry", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        std::string sym = normalizeSymbol(fv(f, "symbol"));
        double cur = fd(f, "currentPrice");
        double qty = fd(f, "quantity");
        double risk = fd(f, "risk");
        double steepness = fd(f, "steepness", 6.0);
        bool isShort = (fv(f, "isShort") == "1");
        int fundMode = fi(f, "fundMode", 1);
        double rangeAbove = fd(f, "rangeAbove");
        double rangeBelow = fd(f, "rangeBelow");
        HorizonParams p;
        p.horizonCount = fi(f, "levels", 4);
        p.feeHedgingCoefficient = fd(f, "feeHedgingCoefficient", 1.0);
        p.portfolioPump = fd(f, "portfolioPump");
        p.symbolCount = fi(f, "symbolCount", 1);
        p.coefficientK = fd(f, "coefficientK");
        p.feeSpread = fd(f, "feeSpread");
        p.deltaTime = fd(f, "deltaTime", 1.0);
        p.surplusRate = fd(f, "surplusRate");
        p.maxRisk = fd(f, "maxRisk");
        p.minRisk = fd(f, "minRisk");
        double walBal = db.loadWalletBalance();
        double availableFunds = p.portfolioPump;
        if (fundMode == 2) availableFunds += walBal;
        HorizonParams entryParams = p;
        entryParams.portfolioPump = availableFunds;
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        if (sym.empty() || cur <= 0 || qty <= 0)
        { h << "<div class='msg err'>Symbol, price, and quantity are required</div><br><a class='btn' href='/market-entry'>Back</a>";
          res.set_content(html::wrap("Market Entry", h.str()), "text/html"); return; }
        auto levels = MarketEntryCalculator::generate(cur, qty, entryParams, risk, steepness, rangeAbove, rangeBelow);
        double eo = MultiHorizonEngine::effectiveOverhead(cur, qty, p);
        double overhead = MultiHorizonEngine::computeOverhead(cur, qty, p);
        double posDelta = MultiHorizonEngine::positionDelta(cur, qty, p.portfolioPump);
        db.saveParamsSnapshot(TradeDatabase::ParamsRow::from("entry", sym, -1, cur, qty, p, risk));
        h << "<h1>Entry Strategy: " << html::esc(sym) << " @ " << std::setprecision(17) << cur << "</h1>";
        { bool canH = db.hasBuyTrades(); h << html::workflow(0, canH, canH); }
        h << std::fixed << std::setprecision(17);
        h << "<div class='row'>"
             "<div class='stat'><div class='lbl'>Overhead</div><div class='val'>" << (overhead * 100) << "%</div></div>"
             "<div class='stat'><div class='lbl'>Surplus</div><div class='val'>" << (p.surplusRate * 100) << "%</div></div>"
             "<div class='stat'><div class='lbl'>Effective</div><div class='val'>" << (eo * 100) << "%</div></div>"
             "<div class='stat'><div class='lbl'>Pos Delta</div><div class='val'>" << (posDelta * 100) << "%</div></div>"
             "</div>";
        h << std::fixed << std::setprecision(17);
        h << "<div class='row'>"
             "<div class='stat'><div class='lbl'>Pump</div><div class='val'>" << p.portfolioPump << "</div></div>"
             "<div class='stat'><div class='lbl'>Wallet</div><div class='val'>" << walBal << "</div></div>"
             "<div class='stat'><div class='lbl'>Available</div><div class='val'>" << availableFunds << "</div></div>"
             "<div class='stat'><div class='lbl'>Direction</div><div class='val'>" << (isShort ? "SHORT" : "LONG") << "</div></div>"
             "</div>";
        {
            double lvlOh = MultiHorizonEngine::computeOverhead(cur, qty, entryParams);
            std::ostringstream con;
            con << std::fixed << std::setprecision(8);
            con << "<details><summary style='cursor:pointer;color:#c9a44a;font-size:0.85em;margin:8px 0;'>"
                   "&#9654; Calculation Steps</summary><div class='calc-console'>";
            con << html::traceOverhead(cur, qty, entryParams);
            con << "<span class='hd'>Sigmoid Distribution</span>"
                << "steepness = <span class='vl'>" << steepness << "</span>\n"
                << "Level 0 = near 0, Level N-1 = currentPrice, sigmoid-interpolated.\n"
                << "Funding = inverse sigmoid warped by risk (risk=1: most at low prices, risk=0: most at high prices).\n"
                << "BreakEven uses overhead. TP/SL use effective overhead.\n";
            con << "<span class='hd'>Position</span>"
                << "positionDelta = (" << cur << " &times; " << qty << ") / " << p.portfolioPump
                << " = <span class='vl'>" << posDelta << " (" << (posDelta * 100) << "%)</span>\n"
                << "availableFunds = <span class='vl'>" << availableFunds << "</span>\n";
            {
                int cN = p.horizonCount;
                double cSteep = (steepness < 0.1) ? 0.1 : steepness;
                auto csig = [](double x) { return 1.0 / (1.0 + std::exp(-x)); };
                double cs0 = csig(-cSteep * 0.5);
                double cs1 = csig( cSteep * 0.5);
                double csR = (cs1 - cs0 > 0) ? cs1 - cs0 : 1.0;
                con << "<span class='hd'>Entry Levels (overhead=" << lvlOh << ")</span>";
                for (const auto& el : levels)
                {
                    double ct = (cN > 1) ? static_cast<double>(el.index) / static_cast<double>(cN - 1) : 1.0;
                    double cv = csig(cSteep * (ct - 0.5));
                    double cn = (cv - cs0) / csR;
                    con << "\n<span class='vl'>Level " << el.index << "</span>\n"
                        << "  t          = " << el.index << " / " << (cN - 1) << " = " << ct << "\n"
                        << "  sigmoid    = <span class='vl'>" << cn << "</span>\n"
                        << "  entryPrice = " << cur << " &times; " << cn << " = <span class='vl'>" << el.entryPrice << "</span>\n"
                        << "  breakEven  = " << el.entryPrice << " &times; (1 + " << lvlOh << ") = <span class='vl'>" << el.breakEven << "</span>\n"
                        << "  fundFrac   = <span class='vl'>" << (el.fundingFraction * 100) << "%</span>"
                        << "  funding = <span class='vl'>" << el.funding << "</span>"
                        << "  qty = <span class='vl'>" << el.fundingQty << "</span>\n"
                        << "  <span class='rs'>potentialNet</span> = (" << cur << " - " << el.entryPrice << ") &times; " << el.fundingQty
                        << " = <span class='rs'>" << el.potentialNet << "</span>\n";
                }
            }
            con << "</div></details>";
            h << con.str();
        }
        double tpRef = (rangeAbove > 0.0 || rangeBelow > 0.0) ? cur + rangeAbove : cur;
        h << "<h2>Entry Levels</h2>"
             "<table><tr><th>Lvl</th><th>Entry Price</th><th>Discount</th>"
             "<th>Break Even</th><th>Net Profit</th><th>Funding</th><th>Fund %</th>"
             "<th>Qty</th><th>Cost</th><th>Coverage</th><th>Exit TP</th><th>Exit SL</th></tr>";
        for (const auto& el : levels)
        {
            double disc = cur > 0 ? ((cur - el.entryPrice) / cur * 100) : 0;
            double exitTP = MultiHorizonEngine::levelTP(el.entryPrice, overhead, eo, p, steepness, el.index, p.horizonCount, isShort, risk, tpRef);
            double exitSL = MultiHorizonEngine::levelSL(el.entryPrice, eo, isShort);
            double cost = el.entryPrice * el.fundingQty;
            h << "<tr><td>" << el.index << "</td><td>" << el.entryPrice << "</td><td>" << disc << "%</td>"
              << "<td>" << el.breakEven << "</td><td>" << el.potentialNet << "</td><td>" << el.funding << "</td>"
              << "<td>" << (el.fundingFraction * 100) << "%</td><td>" << el.fundingQty << "</td><td>" << cost << "</td>"
              << "<td>" << el.costCoverage << "x</td><td class='buy'>" << exitTP << "</td><td class='sell'>" << exitSL << "</td></tr>";
        }
        h << "</table>";
        h << "<h2>Save Entry Strategy</h2>"
             "<form class='card' method='POST' action='/execute-entries'>"
             "<h3>Save as pending entries (buy fees entered when price hits)</h3>"
             "<input type='hidden' name='symbol' value='" << html::esc(sym) << "'>"
             "<input type='hidden' name='currentPrice' value='" << cur << "'>"
             "<input type='hidden' name='quantity' value='" << qty << "'>"
             "<input type='hidden' name='risk' value='" << risk << "'>"
             "<input type='hidden' name='steepness' value='" << steepness << "'>"
             "<input type='hidden' name='isShort' value='" << (isShort ? "1" : "0") << "'>"
             "<input type='hidden' name='fundMode' value='" << fundMode << "'>"
             "<input type='hidden' name='levels' value='" << p.horizonCount << "'>"
             "<input type='hidden' name='feeHedgingCoefficient' value='" << p.feeHedgingCoefficient << "'>"
             "<input type='hidden' name='portfolioPump' value='" << p.portfolioPump << "'>"
             "<input type='hidden' name='symbolCount' value='" << p.symbolCount << "'>"
             "<input type='hidden' name='coefficientK' value='" << p.coefficientK << "'>"
             "<input type='hidden' name='feeSpread' value='" << p.feeSpread << "'>"
             "<input type='hidden' name='deltaTime' value='" << p.deltaTime << "'>"
             "<input type='hidden' name='surplusRate' value='" << p.surplusRate << "'>"
             "<input type='hidden' name='maxRisk' value='" << p.maxRisk << "'>"
             "<input type='hidden' name='minRisk' value='" << p.minRisk << "'>"
             "<input type='hidden' name='rangeAbove' value='" << rangeAbove << "'>"
             "<input type='hidden' name='rangeBelow' value='" << rangeBelow << "'>"
             "<table><tr><th>Lvl</th><th>Entry</th><th>Qty</th><th>Cost</th></tr>";
        for (const auto& el : levels)
        {
            if (el.fundingQty <= 0) continue;
            double cost = el.entryPrice * el.fundingQty;
            h << "<tr><td>" << el.index << "</td><td>" << el.entryPrice << "</td><td>" << el.fundingQty << "</td><td>" << cost << "</td></tr>";
        }
        h << "</table><button>Save Entry Points</button></form>";
        h << "<br><a class='btn' href='/market-entry'>Back</a>";
        res.set_content(html::wrap("Market Entry Results", h.str()), "text/html");
    });

    // ========== POST /execute-entries ï¿½ save pending entry points ==========
    svr.Post("/execute-entries", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        std::string sym = normalizeSymbol(fv(f, "symbol"));
        double cur = fd(f, "currentPrice");
        double qty = fd(f, "quantity");
        double risk = fd(f, "risk");
        double steepness = fd(f, "steepness", 6.0);
        bool isShort = (fv(f, "isShort") == "1");
        int fundMode = fi(f, "fundMode", 1);
        double rangeAbove = fd(f, "rangeAbove");
        double rangeBelow = fd(f, "rangeBelow");
        HorizonParams p;
        p.horizonCount = fi(f, "levels", 4);
        p.feeHedgingCoefficient = fd(f, "feeHedgingCoefficient", 1.0);
        p.portfolioPump = fd(f, "portfolioPump");
        p.symbolCount = fi(f, "symbolCount", 1);
        p.coefficientK = fd(f, "coefficientK");
        p.feeSpread = fd(f, "feeSpread");
        p.deltaTime = fd(f, "deltaTime", 1.0);
        p.surplusRate = fd(f, "surplusRate");
        p.maxRisk = fd(f, "maxRisk");
        p.minRisk = fd(f, "minRisk");
        double walBal = db.loadWalletBalance();
        double availableFunds = p.portfolioPump;
        if (fundMode == 2) availableFunds += walBal;
        HorizonParams entryParams = p;
        entryParams.portfolioPump = availableFunds;
        if (sym.empty() || cur <= 0 || qty <= 0)
        { res.set_redirect("/market-entry?err=Invalid+parameters", 303); return; }
        auto levels = MarketEntryCalculator::generate(cur, qty, entryParams, risk, steepness, rangeAbove, rangeBelow);
        double eo = MultiHorizonEngine::effectiveOverhead(cur, qty, p);
        double overhead = MultiHorizonEngine::computeOverhead(cur, qty, p);
        if (p.portfolioPump > 0) db.deposit(p.portfolioPump);
        int nextEpId = db.nextEntryId();
        std::vector<TradeDatabase::EntryPoint> entryPoints;
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << "<h1>Entry Points Saved: " << html::esc(sym) << "</h1>";
        if (p.portfolioPump > 0)
            h << "<div class='msg'>Deposited pump " << p.portfolioPump << " into wallet. Balance: " << db.loadWalletBalance() << "</div>";
        double tpRef = (rangeAbove > 0.0 || rangeBelow > 0.0) ? cur + rangeAbove : cur;
        h << "<table><tr><th>Lvl</th><th>Entry</th><th>Qty</th><th>Cost</th><th>Exit TP</th><th>Exit SL</th><th>Status</th></tr>";
        for (size_t i = 0; i < levels.size(); ++i)
        {
            const auto& el = levels[i];
            if (el.fundingQty <= 0) continue;
            double cost = el.entryPrice * el.fundingQty;
            double exitTP = MultiHorizonEngine::levelTP(el.entryPrice, overhead, eo, p, steepness, el.index, p.horizonCount, isShort, risk, tpRef);
            double exitSL = MultiHorizonEngine::levelSL(el.entryPrice, eo, isShort);
            TradeDatabase::EntryPoint ep;
            ep.symbol = sym; ep.entryId = nextEpId++; ep.levelIndex = el.index;
            ep.entryPrice = el.entryPrice; ep.breakEven = el.breakEven;
            ep.funding = el.funding; ep.fundingQty = el.fundingQty;
            ep.effectiveOverhead = eo; ep.isShort = isShort;
            ep.exitTakeProfit = exitTP; ep.exitStopLoss = exitSL;
            ep.traded = false; ep.linkedTradeId = -1;
            entryPoints.push_back(ep);
            h << "<tr><td>" << el.index << "</td><td>" << el.entryPrice << "</td><td>" << el.fundingQty << "</td>"
              << "<td>" << cost << "</td><td>" << exitTP << "</td><td>" << exitSL << "</td><td class='buy'>PENDING</td></tr>";
        }
        h << "</table>";
        auto existingEp = db.loadEntryPoints();
        for (const auto& ep : entryPoints) existingEp.push_back(ep);
        db.saveEntryPoints(existingEp);
        h << "<div class='row'><div class='stat'><div class='lbl'>Saved</div><div class='val'>" << entryPoints.size() << "</div></div>"
             "<div class='stat'><div class='lbl'>Wallet</div><div class='val'>" << db.loadWalletBalance() << "</div></div></div>";
        h << "<div class='msg'>" << entryPoints.size() << " entry point(s) saved as pending. Use Price Check to execute when price hits entry levels.</div>";
        h << "<br><a class='btn' href='/entry-points'>Entry Points</a> <a class='btn' href='/price-check'>Price Check</a> <a class='btn' href='/market-entry'>New Entry</a>";
        res.set_content(html::wrap("Entry Points Saved", h.str()), "text/html");
    });

    // ========== GET /entry-points ==========
    svr.Get("/entry-points", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << html::msgBanner(req) << html::errBanner(req);
        h << "<h1>Entry Points</h1>";
        auto pts = db.loadEntryPoints();
        if (pts.empty()) { h << "<p class='empty'>(no entry points)</p>"; }
        else
        {
            h << "<table><tr><th>ID</th><th>Symbol</th><th>Lvl</th><th>Entry</th><th>BE</th><th>Qty</th><th>Funding</th><th>Dir</th><th>Status</th><th>TP</th><th>SL</th><th>Actions</th></tr>";
            for (const auto& ep : pts)
            {
                h << "<tr><td>" << ep.entryId << "</td><td>" << html::esc(ep.symbol) << "</td><td>" << ep.levelIndex << "</td>"
                  << "<td>" << ep.entryPrice << "</td><td>" << ep.breakEven << "</td><td>" << ep.fundingQty << "</td>"
                  << "<td>" << ep.funding << "</td><td>" << (ep.isShort ? "SHORT" : "LONG") << "</td>"
                  << "<td class='" << (ep.traded ? "buy" : "off") << "'>" << (ep.traded ? "TRADED" : "OPEN") << "</td>"
                  << "<td>" << ep.exitTakeProfit << "</td><td>" << ep.exitStopLoss << "</td><td>";
                if (!ep.traded)
                    h << "<a class='btn btn-sm' href='/edit-entry?id=" << ep.entryId << "'>Edit</a> "
                      << "<form class='iform' method='POST' action='/delete-entry'>"
                      << "<input type='hidden' name='id' value='" << ep.entryId << "'><button class='btn-sm btn-danger'>Del</button></form>";
                h << "</td></tr>";
            }
            h << "</table>";
            std::vector<std::string> openSyms;
            for (const auto& ep : pts)
                if (!ep.traded && ep.funding > 0 && std::find(openSyms.begin(), openSyms.end(), ep.symbol) == openSyms.end())
                    openSyms.push_back(ep.symbol);
            if (!openSyms.empty())
            {
                h << "<h2>Check Price &amp; Execute</h2><form class='card' method='POST' action='/entry-points'>"
                     "<h3>Enter current market prices to find triggered entries</h3>";
                for (const auto& sym : openSyms)
                    h << "<label>" << html::esc(sym) << "</label><input type='number' name='price_" << html::esc(sym) << "' step='any' required><br>";
                h << "<br><button>Check Triggers</button></form>";
            }
        }
        h << "<div class='row'><div class='stat'><div class='lbl'>Wallet</div><div class='val'>" << db.loadWalletBalance() << "</div></div></div>";
        res.set_content(html::wrap("Entry Points", h.str()), "text/html");
    });

    // ========== POST /entry-points ï¿½ show triggered entries for execution ==========
    svr.Post("/entry-points", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        auto pts = db.loadEntryPoints();
        auto priceFor = [&](const std::string& sym) -> double { return fd(f, "price_" + sym, 0.0); };
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << "<h1>Entry Points ï¿½ Trigger Check</h1>";
        std::vector<std::string> openSyms;
        for (const auto& ep : pts)
            if (!ep.traded && ep.funding > 0 && std::find(openSyms.begin(), openSyms.end(), ep.symbol) == openSyms.end())
                openSyms.push_back(ep.symbol);
        h << "<form class='card' method='POST' action='/entry-points'><h3>Update prices</h3>";
        for (const auto& sym : openSyms)
        { double p = priceFor(sym); h << "<label>" << html::esc(sym) << "</label><input type='number' name='price_" << html::esc(sym) << "' step='any' value='" << p << "' required><br>"; }
        h << "<br><button>Check Triggers</button></form>";
        h << "<table><tr><th>ID</th><th>Symbol</th><th>Lvl</th><th>Entry</th><th>Market</th><th>Qty</th><th>Dir</th><th>Status</th><th>Trigger</th></tr>";
        for (const auto& ep : pts)
        {
            if (ep.traded || ep.funding <= 0) continue;
            double cur = priceFor(ep.symbol);
            bool hit = false;
            if (cur >= 0) hit = ep.isShort ? (cur >= ep.entryPrice) : (cur <= ep.entryPrice);
            h << "<tr><td>" << ep.entryId << "</td><td>" << html::esc(ep.symbol) << "</td><td>" << ep.levelIndex << "</td>"
              << "<td>" << ep.entryPrice << "</td><td>" << cur << "</td><td>" << ep.fundingQty << "</td>"
              << "<td>" << (ep.isShort ? "SHORT" : "LONG") << "</td><td class='off'>OPEN</td>"
              << "<td class='" << (hit ? "buy" : "off") << "'>" << (hit ? "HIT" : "BELOW") << "</td></tr>";
        }
        h << "</table>";
        struct Triggered { int entryId; std::string symbol; double entryPrice; double fundingQty; double exitTP; double exitSL; bool isShort; double marketPrice; };
        std::vector<Triggered> hits;
        for (const auto& ep : pts)
        {
            if (ep.traded || ep.funding <= 0) continue;
            double cur = priceFor(ep.symbol);
            if (cur < 0) continue;
            double eqty = (ep.fundingQty > 0) ? ep.fundingQty : (ep.entryPrice > 0) ? ep.funding / ep.entryPrice : 0;
            bool hit = ep.isShort ? (cur >= ep.entryPrice) : (cur <= ep.entryPrice);
            if (hit) hits.push_back({ep.entryId, ep.symbol, ep.entryPrice, eqty, ep.exitTakeProfit, ep.exitStopLoss, ep.isShort, cur});
        }
        if (!hits.empty())
        {
            double walBal = db.loadWalletBalance();
            h << "<h2>Triggered Entries (" << hits.size() << ")</h2><form class='card' method='POST' action='/execute-entry-points'>"
                 "<table><tr><th>ID</th><th>Symbol</th><th>Entry</th><th>Market</th><th>Qty</th><th>Cost</th><th>TP</th><th>SL</th><th>Buy Fee</th></tr>";
            double totalCost = 0;
            for (const auto& te : hits)
            {
                double cost = te.entryPrice * te.fundingQty; totalCost += cost;
                h << "<tr><td>" << te.entryId << "</td><td>" << html::esc(te.symbol) << "</td><td>" << te.entryPrice << "</td>"
                  << "<td class='buy'>" << te.marketPrice << "</td><td>" << te.fundingQty << "</td><td>" << cost << "</td>"
                  << "<td>" << te.exitTP << "</td><td>" << te.exitSL << "</td>"
                  << "<td><input type='number' name='fee_" << te.entryId << "' step='any' value='0' style='width:80px;'>"
                  << "<input type='hidden' name='exec_" << te.entryId << "' value='1'></td></tr>";
            }
            h << "</table><div class='row'>"
                 "<div class='stat'><div class='lbl'>Total Cost</div><div class='val'>" << totalCost << "</div></div>"
                 "<div class='stat'><div class='lbl'>Wallet</div><div class='val'>" << walBal << "</div></div>"
                 "<div class='stat'><div class='lbl'>After</div><div class='val'>" << (walBal - totalCost) << "</div></div></div>";
            h << "<br><button>Execute " << hits.size() << " Triggered Entries</button></form>";
        }
        else { h << "<div class='msg'>No entries triggered at current prices</div>"; }
        h << "<div class='row'><div class='stat'><div class='lbl'>Wallet</div><div class='val'>" << db.loadWalletBalance() << "</div></div></div>";
        h << "<br><a class='btn' href='/entry-points'>Back</a>";
        res.set_content(html::wrap("Entry Triggers", h.str()), "text/html");
    });

    // ========== POST /execute-entry-points ==========
    svr.Post("/execute-entry-points", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        auto entryPts = db.loadEntryPoints();
        int executed = 0, failed = 0;
        for (auto& ep : entryPts)
        {
            if (ep.traded) continue;
            if (fv(f, "exec_" + std::to_string(ep.entryId)).empty()) continue;
            if (ep.funding <= 0) continue;
            double execQty = (ep.fundingQty > 0) ? ep.fundingQty : (ep.entryPrice > 0) ? ep.funding / ep.entryPrice : 0;
            if (execQty <= 0) continue;
            double buyFee = fd(f, "fee_" + std::to_string(ep.entryId));
            double cost = ep.entryPrice * execQty + buyFee;
            double walBal = db.loadWalletBalance();
            if (cost > walBal) { ++failed; continue; }
            int bid = db.executeBuy(ep.symbol, ep.entryPrice, execQty, buyFee);
            ep.traded = true; ep.linkedTradeId = bid; ++executed;
        }
        if (executed > 0)
        {
            auto trades = db.loadTrades();
            for (const auto& ep : entryPts)
            {
                if (ep.linkedTradeId < 0) continue;
                auto* tradePtr = db.findTradeById(trades, ep.linkedTradeId);
                if (!tradePtr) continue;
                tradePtr->takeProfit = ep.exitTakeProfit * tradePtr->quantity;
                tradePtr->stopLoss = ep.exitStopLoss * tradePtr->quantity;
                tradePtr->stopLossActive = false;
                db.updateTrade(*tradePtr);
            }
        }
        db.saveEntryPoints(entryPts);
        if (failed > 0)
            res.set_redirect("/entry-points?msg=" + std::to_string(executed) + "+executed,+" + std::to_string(failed) + "+failed+(insufficient+funds)", 303);
        else
            res.set_redirect("/entry-points?msg=" + std::to_string(executed) + "+entries+executed+as+trades", 303);
    });

    // ========== GET /edit-entry ==========
    svr.Get("/edit-entry", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << html::msgBanner(req) << html::errBanner(req);
        int id = 0;
        try { id = std::stoi(req.get_param_value("id")); } catch (...) {}
        auto pts = db.loadEntryPoints();
        TradeDatabase::EntryPoint* found = nullptr;
        for (auto& ep : pts) if (ep.entryId == id) { found = &ep; break; }
        if (!found || found->traded)
        { h << "<h1>Edit Entry</h1><div class='msg err'>Entry not found or already traded</div>"; }
        else
        {
            auto& ep = *found;
            double eo = ep.effectiveOverhead;
            h << "<h1>Edit Entry #" << ep.entryId << " " << html::esc(ep.symbol) << "</h1>"
                 "<form class='card' method='POST' action='/edit-entry'>"
                 "<input type='hidden' name='id' value='" << ep.entryId << "'>"
                 "<label>Entry Price</label><input type='number' name='entryPrice' step='any' value='" << ep.entryPrice << "'><br>"
                 "<label>Funding</label><input type='number' name='funding' step='any' value='" << ep.funding << "'><br>"
                 "<label>Qty</label><input type='number' name='fundingQty' step='any' value='" << ep.fundingQty << "'>"
                 "<div style='color:#475569;font-size:0.78em;'>Leave 0 to auto-compute from funding/price</div>"
                 "<label>TP/unit</label><input type='number' name='exitTP' step='any' value='" << ep.exitTakeProfit << "'><br>"
                 "<label>SL/unit</label><input type='number' name='exitSL' step='any' value='" << ep.exitStopLoss << "'><br>"
                 "<label>Break Even</label><input type='number' name='breakEven' step='any' value='" << ep.breakEven << "'><br>"
                 "<div style='color:#475569;font-size:0.78em;margin:8px 0;'>Effective overhead: " << (eo * 100) << "% &mdash; for auto TP/SL set price and leave TP/SL at 0</div>"
                 "<button>Save Changes</button></form>";
        }
        h << "<br><a class='btn' href='/entry-points'>Back</a>";
        res.set_content(html::wrap("Edit Entry", h.str()), "text/html");
    });

    // ========== POST /edit-entry ==========
    svr.Post("/edit-entry", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        int id = fi(f, "id");
        auto pts = db.loadEntryPoints();
        TradeDatabase::EntryPoint* found = nullptr;
        for (auto& ep : pts) if (ep.entryId == id) { found = &ep; break; }
        if (!found || found->traded) { res.set_redirect("/entry-points?err=Entry+not+found+or+already+traded", 303); return; }
        auto& ep = *found;
        double newPrice = fd(f, "entryPrice", ep.entryPrice);
        double newFunding = fd(f, "funding", ep.funding);
        double newQty = fd(f, "fundingQty");
        double newTP = fd(f, "exitTP");
        double newSL = fd(f, "exitSL");
        double newBE = fd(f, "breakEven");
        if (newPrice > 0) ep.entryPrice = newPrice;
        if (newFunding > 0) ep.funding = newFunding;
        if (newQty > 0) ep.fundingQty = newQty;
        else if (ep.entryPrice > 0) ep.fundingQty = ep.funding / ep.entryPrice;
        double eo = ep.effectiveOverhead;
        if (newTP > 0) ep.exitTakeProfit = newTP;
        else if (ep.entryPrice > 0) ep.exitTakeProfit = ep.isShort ? ep.entryPrice * (1.0 - eo) : ep.entryPrice * (1.0 + eo);
        if (newSL > 0) ep.exitStopLoss = newSL;
        else if (ep.entryPrice > 0) ep.exitStopLoss = ep.isShort ? ep.entryPrice * (1.0 + eo) : ep.entryPrice * (1.0 - eo);
        if (newBE > 0) ep.breakEven = newBE;
        else if (ep.entryPrice > 0) ep.breakEven = ep.entryPrice * (1.0 + ep.effectiveOverhead);
        db.saveEntryPoints(pts);
        res.set_redirect("/entry-points?msg=Entry+" + std::to_string(id) + "+updated", 303);
    });

    // ========== POST /delete-entry ==========
    svr.Post("/delete-entry", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        int id = fi(f, "id");
        auto pts = db.loadEntryPoints();
        std::vector<TradeDatabase::EntryPoint> remaining;
        for (const auto& ep : pts) if (ep.entryId != id) remaining.push_back(ep);
        db.saveEntryPoints(remaining);
        res.set_redirect("/entry-points?msg=Entry+" + std::to_string(id) + "+deleted", 303);
    });
}
===== Routes_Exit.h ===== 
#pragma once

#include "AppContext.h"
#include "HtmlHelpers.h"
#include "ExitStrategyCalculator.h"
#include <mutex>
#include <algorithm>

inline void registerExitRoutes(httplib::Server& svr, AppContext& ctx)
{
    auto& db = ctx.defaultDb;
    auto& dbMutex = ctx.dbMutex;

    // ========== GET /exit-strategy ï¿½ form ==========
    svr.Get("/exit-strategy", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        if (!db.hasBuyTrades())
        {
            res.set_redirect("/market-entry?err=Add+buy+trades+first", 303);
            return;
        }
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << html::msgBanner(req) << html::errBanner(req);
        { bool canH = db.hasBuyTrades();
          h << html::workflow(2, canH, canH); }
        h << "<h1>Exit Strategy Calculator</h1>"
             "<form class='card' method='POST' action='/exit-strategy'><h3>Parameters</h3>"
             "<label>Trade IDs</label><input type='text' name='tradeIds' placeholder='1,2,3' required><br>"
             "<label>Risk</label><input type='number' name='risk' step='any' value='0.5'><br>"
             "<label>Exit Fraction</label><input type='number' name='exitFraction' step='any' value='1.0'><br>"
             "<label>Steepness</label><input type='number' name='steepness' step='any' value='4.0'><br>"
             "<label>Fee Hedging</label><input type='number' name='feeHedgingCoefficient' step='any' value='1'><br>"
             "<label>Symbol Count</label><input type='number' name='symbolCount' value='1'><br>"
             "<label>Coefficient K</label><input type='number' name='coefficientK' step='any' value='0'><br>"
             "<label>Fee Spread</label><input type='number' name='feeSpread' step='any' value='0'><br>"
             "<label>Delta Time</label><input type='number' name='deltaTime' step='any' value='1'><br>"
             "<label>Surplus Rate</label><input type='number' name='surplusRate' step='any' value='0.02'><br>"
             "<label>Max Risk</label><input type='number' name='maxRisk' step='any' value='0'><br>"
             "<label>Min Risk</label><input type='number' name='minRisk' step='any' value='0'><br>"
             "<button>Calculate</button></form>";
        auto trades = db.loadTrades();
        bool any = false;
        for (const auto& t : trades) if (t.type == TradeType::Buy) { any = true; break; }
        if (any)
        {
            h << "<h2>Buy Trades</h2><table><tr><th>ID</th><th>Symbol</th><th>Price</th>"
                 "<th>Qty</th><th>Buy Fee</th><th>Sold</th><th>Pending</th><th>Remaining</th></tr>";
            auto pending = db.loadPendingExits();
            for (const auto& t : trades)
            {
                if (t.type != TradeType::Buy) continue;
                double sold = db.soldQuantityForParent(t.tradeId);
                double pQty = 0;
                for (const auto& pe : pending)
                    if (pe.tradeId == t.tradeId) pQty += pe.sellQty;
                h << "<tr><td>" << t.tradeId << "</td><td>" << html::esc(t.symbol) << "</td>"
                  << "<td>" << t.value << "</td><td>" << t.quantity << "</td>"
                  << "<td>" << t.buyFee << "</td>"
                  << "<td>" << sold << "</td><td>" << pQty << "</td>"
                  << "<td>" << (t.quantity - sold - pQty) << "</td></tr>";
            }
            h << "</table>";
        }
        res.set_content(html::wrap("Exit Strategy", h.str()), "text/html");
    });

    // ========== POST /exit-strategy ï¿½ show results + confirm form ==========
    svr.Post("/exit-strategy", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        std::string idsStr = fv(f, "tradeIds");
        double risk = fd(f, "risk");
        double exitFrac = fd(f, "exitFraction", 1.0);
        double steep = fd(f, "steepness", 4.0);
        HorizonParams p;
        p.horizonCount = 1;
        p.feeHedgingCoefficient = fd(f, "feeHedgingCoefficient", 1.0);
        p.symbolCount = fi(f, "symbolCount", 1);
        p.coefficientK = fd(f, "coefficientK");
        p.feeSpread = fd(f, "feeSpread");
        p.deltaTime = fd(f, "deltaTime", 1.0);
        p.surplusRate = fd(f, "surplusRate");
        p.maxRisk = fd(f, "maxRisk");
        p.minRisk = fd(f, "minRisk");
        std::vector<int> ids;
        { std::istringstream ss(idsStr); std::string tok;
          while (std::getline(ss, tok, ',')) { try { ids.push_back(std::stoi(tok)); } catch (...) {} } }
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        if (ids.empty()) { h << "<div class='msg err'>No trade IDs entered</div>"; }
        else
        {
            auto trades = db.loadTrades();
            auto existingPending = db.loadPendingExits();
            int levelCounter = 0;
            bool anyLevels = false;
            std::vector<std::string> exitSymbols;
            { bool canH = db.hasBuyTrades(); h << html::workflow(2, canH, canH); }
            h << "<h1>Exit Strategy</h1>";
            h << "<form class='card' method='POST' action='/confirm-exits'>"
                 "<input type='hidden' name='tradeIds' value='" << html::esc(idsStr) << "'>"
                 "<input type='hidden' name='risk' value='" << risk << "'>"
                 "<input type='hidden' name='exitFraction' value='" << exitFrac << "'>"
                 "<input type='hidden' name='steepness' value='" << steep << "'>"
                 "<input type='hidden' name='feeHedgingCoefficient' value='" << p.feeHedgingCoefficient << "'>"
                 "<input type='hidden' name='symbolCount' value='" << p.symbolCount << "'>"
                 "<input type='hidden' name='coefficientK' value='" << p.coefficientK << "'>"
                 "<input type='hidden' name='feeSpread' value='" << p.feeSpread << "'>"
                 "<input type='hidden' name='deltaTime' value='" << p.deltaTime << "'>"
                 "<input type='hidden' name='surplusRate' value='" << p.surplusRate << "'>";
            for (int id : ids)
            {
                auto* tp = db.findTradeById(trades, id);
                if (!tp || tp->type != TradeType::Buy)
                { h << "<div class='msg err'>#" << id << " is not a Buy trade</div>"; continue; }
                double sold = db.soldQuantityForParent(tp->tradeId);
                double pendingQty = 0;
                for (const auto& pe : existingPending)
                    if (pe.tradeId == tp->tradeId) pendingQty += pe.sellQty;
                double remaining = tp->quantity - sold - pendingQty;
                if (remaining <= 0)
                { h << "<div class='msg err'>#" << id << " " << html::esc(tp->symbol)
                     << " fully committed (sold=" << sold << " pending=" << pendingQty << ")</div>"; continue; }
                Trade tempTrade = *tp;
                double remainFrac = (tp->quantity > 0) ? remaining / tp->quantity : 0.0;
                tempTrade.quantity = remaining;
                tempTrade.buyFee = tp->buyFee * remainFrac;
                auto levels = ExitStrategyCalculator::generate(tempTrade, p, risk, exitFrac, steep);
                double clampedFrac = (exitFrac < 0) ? 0 : (exitFrac > 1) ? 1 : exitFrac;
                double sellableQty = remaining * clampedFrac;
                h << "<h2>Exit #" << tp->tradeId << " " << html::esc(tp->symbol)
                  << " (entry=" << tp->value << ")</h2>"
                     "<div class='row'>"
                     "<div class='stat'><div class='lbl'>Total</div><div class='val'>" << tp->quantity << "</div></div>"
                     "<div class='stat'><div class='lbl'>Sold</div><div class='val'>" << sold << "</div></div>"
                     "<div class='stat'><div class='lbl'>Pending</div><div class='val'>" << pendingQty << "</div></div>"
                     "<div class='stat'><div class='lbl'>Available</div><div class='val'>" << remaining << "</div></div>"
                     "<div class='stat'><div class='lbl'>Selling</div><div class='val'>" << sellableQty << "</div></div>"
                     "</div>";
                {
                    double tradeEo = MultiHorizonEngine::effectiveOverhead(tempTrade, p);
                    std::ostringstream con;
                    con << std::fixed << std::setprecision(8);
                    con << "<details><summary style='cursor:pointer;color:#c9a44a;font-size:0.85em;margin:4px 0;'>"
                           "&#9654; Calculation Steps</summary><div class='calc-console'>";
                    con << html::traceOverhead(tempTrade.value, tempTrade.quantity, p);
                    con << "<span class='hd'>Sigmoid Distribution</span>"
                        << "risk = <span class='vl'>" << risk << "</span>"
                        << "  steepness = <span class='vl'>" << steep << "</span>"
                        << "  exitFraction = <span class='vl'>" << exitFrac << "</span>\n"
                        << "sellableQty = " << remaining << " &times; " << clampedFrac
                        << " = <span class='vl'>" << sellableQty << "</span>\n"
                        << "buyFee (pro-rated) = <span class='vl'>" << tempTrade.buyFee << "</span>\n";
                    con << "<span class='hd'>Exit Levels</span>";
                    for (const auto& el : levels)
                    {
                        if (el.sellQty <= 0) continue;
                        double factor = tradeEo * (el.index + 1);
                        con << "\n<span class='vl'>Level " << el.index << "</span>\n"
                            << "  tpPrice      = " << tp->value << " &times; (1 + " << factor << ") = <span class='vl'>" << el.tpPrice << "</span>\n"
                            << "  sellFraction = <span class='vl'>" << (el.sellFraction * 100) << "%</span>"
                            << "  sellQty = <span class='vl'>" << el.sellQty << "</span>\n"
                            << "  grossProfit  = (" << el.tpPrice << " - " << tp->value << ") &times; " << el.sellQty
                            << " = <span class='vl'>" << el.grossProfit << "</span>\n"
                            << "  levelBuyFee  = " << tempTrade.buyFee << " &times; " << el.sellFraction
                            << " = <span class='vl'>" << el.levelBuyFee << "</span>\n"
                            << "  <span class='rs'>netProfit</span>    = " << el.grossProfit << " - " << el.levelBuyFee
                            << " = <span class='rs'>" << el.netProfit << "</span>\n";
                    }
                    con << "</div></details>";
                    h << con.str();
                }
                h << "<table><tr><th>Lvl</th><th>TP Price</th><th>Sell Qty</th>"
                     "<th>Fraction</th><th>Value</th><th>Gross</th>"
                     "<th>Buy Fee</th><th>Sell Fee</th></tr>";
                std::ostringstream hiddenFields;
                hiddenFields << std::fixed << std::setprecision(17);
                for (const auto& el : levels)
                {
                    if (el.sellQty <= 0) continue;
                    double pct = tp->value > 0 ? ((el.tpPrice - tp->value) / tp->value * 100) : 0;
                    h << "<tr><td>" << el.index << "</td>"
                      << "<td>" << el.tpPrice << " (+" << pct << "%)</td>"
                      << "<td>" << el.sellQty << "</td>"
                      << "<td>" << (el.sellFraction * 100) << "%</td>"
                      << "<td>" << el.sellValue << "</td>"
                      << "<td>" << el.grossProfit << "</td>"
                      << "<td><input type='number' name='buyFee_" << levelCounter
                      << "' step='any' value='" << el.levelBuyFee << "' style='width:80px;'></td>"
                      << "<td><input type='number' name='sellFee_" << levelCounter
                      << "' step='any' value='" << el.levelSellFee << "' style='width:80px;'></td></tr>";
                    hiddenFields << "<input type='hidden' name='tid_" << levelCounter << "' value='" << tp->tradeId << "'>"
                      << "<input type='hidden' name='sym_" << levelCounter << "' value='" << html::esc(tp->symbol) << "'>"
                      << "<input type='hidden' name='tp_" << levelCounter << "' value='" << el.tpPrice << "'>"
                      << "<input type='hidden' name='qty_" << levelCounter << "' value='" << el.sellQty << "'>"
                      << "<input type='hidden' name='gross_" << levelCounter << "' value='" << el.grossProfit << "'>"
                      << "<input type='hidden' name='lvl_" << levelCounter << "' value='" << el.index << "'>";
                    ++levelCounter;
                    anyLevels = true;
                }
                h << "</table>";
                h << hiddenFields.str();
                if (std::find(exitSymbols.begin(), exitSymbols.end(), tp->symbol) == exitSymbols.end())
                    exitSymbols.push_back(tp->symbol);
                h << "<div style='color:#475569;font-size:0.82em;'>Remaining after exit: "
                  << (remaining - sellableQty) << "</div>";
                db.saveParamsSnapshot(
                    TradeDatabase::ParamsRow::from("exit", tp->symbol, tp->tradeId,
                                                   tp->value, tp->quantity, p, risk,
                                                   tp->buyFee, tp->sellFee));
            }
            h << "<input type='hidden' name='levelCount' value='" << levelCounter << "'>";
            if (anyLevels)
            {
                h << "<br><h3 style='color:#c9a44a;'>Confirm Exits</h3>";
                for (const auto& es : exitSymbols)
                {
                    h << "<label>" << html::esc(es) << " Price</label>"
                      << "<input type='number' name='price_" << html::esc(es)
                      << "' step='any' required><br>";
                }
                h << "<br><button>Confirm &amp; Execute</button>";
            }
            h << "</form>";
        }
        h << "<br><a class='btn' href='/exit-strategy'>Back</a>";
        res.set_content(html::wrap("Exit Results", h.str()), "text/html");
    });

    // ========== POST /confirm-exits ï¿½ execute triggered + save pending ==========
    svr.Post("/confirm-exits", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        int levelCount = fi(f, "levelCount");
        auto priceFor = [&](const std::string& sym) -> double { return fd(f, "price_" + sym, 0.0); };
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << "<h1>Exit Execution</h1>";
        if (levelCount <= 0)
        { h << "<div class='msg err'>Invalid parameters</div><br><a class='btn' href='/exit-strategy'>Back</a>";
          res.set_content(html::wrap("Exit Execution", h.str()), "text/html"); return; }
        struct ExitOrder { int tradeId; std::string symbol; double triggerPrice; double sellQty;
            double grossProfit; double buyFee; double sellFee; double netProfit; int levelIndex; };
        std::vector<ExitOrder> allOrders;
        double totalNet = 0;
        for (int i = 0; i < levelCount; ++i)
        {
            std::string si = std::to_string(i);
            ExitOrder eo;
            eo.tradeId = fi(f, "tid_" + si); eo.symbol = fv(f, "sym_" + si);
            eo.triggerPrice = fd(f, "tp_" + si); eo.sellQty = fd(f, "qty_" + si);
            eo.grossProfit = fd(f, "gross_" + si); eo.buyFee = fd(f, "buyFee_" + si);
            eo.sellFee = fd(f, "sellFee_" + si); eo.levelIndex = fi(f, "lvl_" + si);
            eo.netProfit = eo.grossProfit - eo.buyFee - eo.sellFee;
            totalNet += eo.netProfit;
            allOrders.push_back(eo);
        }
        h << "<h2>Fee Summary</h2>"
             "<table><tr><th>Trade</th><th>Symbol</th><th>Lvl</th><th>Trigger</th>"
             "<th>Qty</th><th>Gross</th><th>Buy Fee</th><th>Sell Fee</th><th>Net</th></tr>";
        for (const auto& eo : allOrders)
        {
            h << "<tr><td>" << eo.tradeId << "</td><td>" << html::esc(eo.symbol) << "</td>"
              << "<td>" << eo.levelIndex << "</td><td>" << eo.triggerPrice << "</td>"
              << "<td>" << eo.sellQty << "</td><td>" << eo.grossProfit << "</td>"
              << "<td>" << eo.buyFee << "</td><td>" << eo.sellFee << "</td>"
              << "<td class='" << (eo.netProfit >= 0 ? "buy" : "sell") << "'>" << eo.netProfit << "</td></tr>";
        }
        h << "</table>";
        std::vector<std::string> exitSyms;
        for (const auto& eo : allOrders)
            if (std::find(exitSyms.begin(), exitSyms.end(), eo.symbol) == exitSyms.end())
                exitSyms.push_back(eo.symbol);
        h << "<div class='row'><div class='stat'><div class='lbl'>Total Net</div><div class='val'>" << totalNet << "</div></div>";
        for (const auto& es : exitSyms)
            h << "<div class='stat'><div class='lbl'>" << html::esc(es) << "</div><div class='val'>" << priceFor(es) << "</div></div>";
        h << "</div>";
        std::vector<ExitOrder> hitOrders, pendingOrders;
        for (const auto& eo : allOrders)
        { double cp = priceFor(eo.symbol); if (cp > 0 && cp >= eo.triggerPrice) hitOrders.push_back(eo); else pendingOrders.push_back(eo); }
        int executed = 0;
        if (!hitOrders.empty())
        {
            h << "<h2>Executed (" << hitOrders.size() << " at/above trigger)</h2>"
                 "<table><tr><th>Trade</th><th>Symbol</th><th>Trigger</th><th>Qty</th><th>Sell ID</th><th>Status</th></tr>";
            for (const auto& eo : hitOrders)
            {
                int sid = db.executeSellForTrade(eo.symbol, eo.triggerPrice, eo.sellQty, eo.sellFee, eo.tradeId);
                if (sid >= 0)
                { h << "<tr><td>" << eo.tradeId << "</td><td>" << html::esc(eo.symbol) << "</td><td>" << eo.triggerPrice << "</td>"
                     << "<td>" << eo.sellQty << "</td><td class='buy'>#" << sid << "</td><td class='buy'>OK</td></tr>"; ++executed; }
                else
                { h << "<tr><td>" << eo.tradeId << "</td><td>" << html::esc(eo.symbol) << "</td><td>" << eo.triggerPrice << "</td>"
                     << "<td>" << eo.sellQty << "</td><td>-</td><td class='sell'>FAILED</td></tr>"; }
            }
            h << "</table>";
        }
        int saved = 0;
        if (!pendingOrders.empty())
        {
            int nextId = db.nextPendingId();
            std::vector<TradeDatabase::PendingExit> peList;
            for (const auto& eo : pendingOrders)
            {
                TradeDatabase::PendingExit pe;
                pe.symbol = eo.symbol; pe.orderId = nextId++; pe.tradeId = eo.tradeId;
                pe.triggerPrice = eo.triggerPrice; pe.sellQty = eo.sellQty; pe.levelIndex = eo.levelIndex;
                peList.push_back(pe);
            }
            db.addPendingExits(peList);
            saved = (int)peList.size();
            h << "<h2>Pending (" << saved << " below trigger)</h2>"
                 "<table><tr><th>Order</th><th>Trade</th><th>Symbol</th><th>Trigger</th><th>Qty</th><th>Away</th></tr>";
            for (const auto& pe : peList)
                h << "<tr><td>" << pe.orderId << "</td><td>" << pe.tradeId << "</td><td>" << html::esc(pe.symbol) << "</td>"
                  << "<td>" << pe.triggerPrice << "</td><td>" << pe.sellQty << "</td><td>" << (pe.triggerPrice - priceFor(pe.symbol)) << "</td></tr>";
            h << "</table>";
        }
        h << "<div class='row'>"
             "<div class='stat'><div class='lbl'>Executed</div><div class='val'>" << executed << "</div></div>"
             "<div class='stat'><div class='lbl'>Pending</div><div class='val'>" << saved << "</div></div>"
             "<div class='stat'><div class='lbl'>Wallet</div><div class='val'>" << db.loadWalletBalance() << "</div></div>"
             "</div>";
        h << "<div class='msg'>" << executed << " exit(s) executed, " << saved << " pending exit(s) saved.</div>";
        h << "<br><a class='btn' href='/trades'>Trades</a> "
             "<a class='btn' href='/pending-exits'>Pending Exits</a> "
             "<a class='btn' href='/exit-strategy'>New Exit</a>";
        res.set_content(html::wrap("Exit Execution", h.str()), "text/html");
    });

    // ========== GET /pending-exits ==========
    svr.Get("/pending-exits", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << html::msgBanner(req) << html::errBanner(req);
        h << "<h1>Pending Exits</h1>";
        auto orders = db.loadPendingExits();
        if (orders.empty()) { h << "<p class='empty'>(no pending exits)</p>"; }
        else
        {
            h << "<table><tr><th>Order</th><th>Symbol</th><th>Trade</th>"
                 "<th>Trigger</th><th>Qty</th><th>Level</th><th>Action</th></tr>";
            for (const auto& pe : orders)
                h << "<tr><td>" << pe.orderId << "</td><td>" << html::esc(pe.symbol) << "</td><td>" << pe.tradeId << "</td>"
                  << "<td>" << pe.triggerPrice << "</td><td>" << pe.sellQty << "</td><td>" << pe.levelIndex << "</td>"
                  << "<td><form class='iform' method='POST' action='/remove-pending'>"
                  << "<input type='hidden' name='id' value='" << pe.orderId << "'>"
                  << "<button class='btn-sm btn-danger'>Remove</button></form></td></tr>";
            h << "</table>";
            std::vector<std::string> peSyms;
            for (const auto& pe : orders)
                if (std::find(peSyms.begin(), peSyms.end(), pe.symbol) == peSyms.end()) peSyms.push_back(pe.symbol);
            h << "<form class='card' method='POST' action='/confirm-pending-exits'><h3>Confirm Pending Exits</h3>";
            for (const auto& sym : peSyms)
                h << "<label>" << html::esc(sym) << " Price</label><input type='number' name='price_" << html::esc(sym) << "' step='any' required><br>";
            h << "<table><tr><th>Order</th><th>Symbol</th><th>Trigger</th><th>Qty</th><th>Sell Fee</th></tr>";
            for (const auto& pe : orders)
                h << "<tr><td>" << pe.orderId << "</td><td>" << html::esc(pe.symbol) << "</td><td>" << pe.triggerPrice << "</td>"
                  << "<td>" << pe.sellQty << "</td><td><input type='number' name='sellFee_" << pe.orderId << "' step='any' value='0' style='width:80px;'></td></tr>";
            h << "</table><button>Confirm &amp; Execute</button></form>";
        }
        res.set_content(html::wrap("Pending Exits", h.str()), "text/html");
    });

    // ========== POST /remove-pending ==========
    svr.Post("/remove-pending", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        int id = fi(f, "id");
        db.removePendingExit(id);
        res.set_redirect("/pending-exits?msg=Order+" + std::to_string(id) + "+removed", 303);
    });

    // ========== POST /confirm-pending-exits ==========
    svr.Post("/confirm-pending-exits", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        auto orders = db.loadPendingExits();
        auto priceFor = [&](const std::string& sym) -> double { return fd(f, "price_" + sym, 0.0); };
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << "<h1>Pending Exit Execution</h1>";
        int executed = 0, skipped = 0;
        std::vector<int> executedIds;
        h << "<table><tr><th>Order</th><th>Symbol</th><th>Trigger</th><th>Market</th><th>Qty</th><th>Fee</th><th>Sell ID</th><th>Status</th></tr>";
        for (const auto& pe : orders)
        {
            double cur = priceFor(pe.symbol);
            double sellFee = fd(f, "sellFee_" + std::to_string(pe.orderId));
            if (cur > 0 && cur >= pe.triggerPrice)
            {
                int sid = (pe.tradeId > 0) ? db.executeSellForTrade(pe.symbol, pe.triggerPrice, pe.sellQty, sellFee, pe.tradeId)
                                           : db.executeSell(pe.symbol, pe.triggerPrice, pe.sellQty, sellFee);
                if (sid >= 0)
                { h << "<tr><td>" << pe.orderId << "</td><td>" << html::esc(pe.symbol) << "</td><td>" << pe.triggerPrice << "</td>"
                     << "<td class='buy'>" << cur << "</td><td>" << pe.sellQty << "</td><td>" << sellFee << "</td>"
                     << "<td class='buy'>#" << sid << "</td><td class='buy'>EXECUTED</td></tr>";
                  executedIds.push_back(pe.orderId); ++executed; }
                else
                { h << "<tr><td>" << pe.orderId << "</td><td>" << html::esc(pe.symbol) << "</td><td>" << pe.triggerPrice << "</td>"
                     << "<td>" << cur << "</td><td>" << pe.sellQty << "</td><td>" << sellFee << "</td>"
                     << "<td>-</td><td class='sell'>FAILED</td></tr>"; }
            }
            else
            { h << "<tr><td>" << pe.orderId << "</td><td>" << html::esc(pe.symbol) << "</td><td>" << pe.triggerPrice << "</td>"
                 << "<td>" << cur << "</td><td>" << pe.sellQty << "</td><td>" << sellFee << "</td>"
                 << "<td>-</td><td class='off'>BELOW TRIGGER</td></tr>"; ++skipped; }
        }
        h << "</table>";
        for (int oid : executedIds) db.removePendingExit(oid);
        h << "<div class='row'>"
             "<div class='stat'><div class='lbl'>Executed</div><div class='val'>" << executed << "</div></div>"
             "<div class='stat'><div class='lbl'>Skipped</div><div class='val'>" << skipped << "</div></div>"
             "<div class='stat'><div class='lbl'>Wallet</div><div class='val'>" << db.loadWalletBalance() << "</div></div>"
             "</div>";
        h << "<br><a class='btn' href='/trades'>Trades</a> <a class='btn' href='/pending-exits'>Pending Exits</a>";
        res.set_content(html::wrap("Pending Exit Execution", h.str()), "text/html");
    });
}
===== Routes_Horizons.h ===== 
#pragma once

#include "AppContext.h"
#include "HtmlHelpers.h"
#include <mutex>
#include <algorithm>

inline void registerHorizonRoutes(httplib::Server& svr, AppContext& ctx)
{
    auto& db = ctx.defaultDb;
    auto& dbMutex = ctx.dbMutex;

    // ========== GET /horizons ==========
    svr.Get("/horizons", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << "<h1>Horizon Levels</h1>"
             "<form class='card' method='GET' action='/horizons'><h3>View Horizons</h3>"
             "<label>Trade ID</label><input type='number' name='tradeId' value='"
          << req.get_param_value("tradeId") << "' required> "
             "<button>View</button></form>";
        if (req.has_param("tradeId"))
        {
            int id = 0;
            try { id = std::stoi(req.get_param_value("tradeId")); } catch (...) {}
            auto trades = db.loadTrades();
            auto* tp = db.findTradeById(trades, id);
            if (!tp) { h << "<div class='msg err'>Trade not found</div>"; }
            else
            {
                auto levels = db.loadHorizonLevels(tp->symbol, id);
                h << "<h2>" << html::esc(tp->symbol) << " #" << id
                  << " (price=" << tp->value << " qty=" << tp->quantity << ")</h2>";
                if (levels.empty()) { h << "<p class='empty'>(no horizons)</p>"; }
                else
                {
                    h << "<table><tr><th>Index</th><th>Take Profit</th><th>TP/unit</th>"
                         "<th>Stop Loss</th><th>SL/unit</th><th>SL?</th></tr>";
                    for (const auto& lv : levels)
                    {
                        double tpu = tp->quantity > 0 ? lv.takeProfit / tp->quantity : 0;
                        double slu = (tp->quantity > 0 && lv.stopLoss > 0) ? lv.stopLoss / tp->quantity : 0;
                        h << "<tr><td>" << lv.index << "</td>"
                          << "<td>" << lv.takeProfit << "</td><td>" << tpu << "</td>"
                          << "<td>" << lv.stopLoss << "</td><td>" << slu << "</td>"
                          << "<td class='" << (lv.stopLossActive ? "on" : "off") << "'>"
                          << (lv.stopLossActive ? "ON" : "OFF") << "</td></tr>";
                    }
                    h << "</table>";
                }
            }
        }
        res.set_content(html::wrap("Horizons", h.str()), "text/html");
    });

    // ========== GET /generate-horizons ==========
    svr.Get("/generate-horizons", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        if (!db.hasBuyTrades())
        {
            res.set_redirect("/market-entry?err=Add+buy+trades+before+generating+horizons", 303);
            return;
        }
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << html::msgBanner(req) << html::errBanner(req);
        { bool canH = db.hasBuyTrades();
          h << html::workflow(1, canH, canH); }
        h << "<h1>Generate TP/SL Horizons</h1>";
        auto trades = db.loadTrades();
        bool any = false;
        for (const auto& t : trades) if (t.type == TradeType::Buy) { any = true; break; }
        h << "<form class='card' method='POST' action='/generate-horizons'><h3>Shared Parameters</h3>"
             "<label>Symbol</label><input type='text' name='symbol' required><br>"
             "<label>Trade IDs</label><input type='text' name='tradeIds' placeholder='1,2,3 or 0=all' value='0'><br>"
             "<label>Fee Hedging</label><input type='number' name='feeHedgingCoefficient' step='any' value='1'><br>"
             "<label>Pump</label><input type='number' name='portfolioPump' step='any' value='0'><br>"
             "<label>Symbol Count</label><input type='number' name='symbolCount' value='1'><br>"
             "<label>Coefficient K</label><input type='number' name='coefficientK' step='any' value='0'><br>"
             "<label>Fee Spread</label><input type='number' name='feeSpread' step='any' value='0'><br>"
             "<label>Delta Time</label><input type='number' name='deltaTime' step='any' value='1'><br>"
             "<label>Surplus Rate</label><input type='number' name='surplusRate' step='any' value='0.02'><br>"
             "<label>Max Risk</label><input type='number' name='maxRisk' step='any' value='0'><br>"
             "<label>Min Risk</label><input type='number' name='minRisk' step='any' value='0'><br>"
             "<label>Stop Losses</label><select name='generateStopLosses'>"
             "<option value='0'>No</option><option value='1'>Yes</option></select><br>";
        if (any)
        {
            h << "<h3 style='margin-top:12px;'>Buy Trades</h3>"
                 "<table><tr><th>ID</th><th>Symbol</th><th>Price</th>"
                 "<th>Qty</th><th>Cost</th><th>TP</th><th>SL</th>"
                 "<th>Buy Fee</th></tr>";
            for (const auto& t : trades)
            {
                if (t.type != TradeType::Buy) continue;
                h << "<tr><td>" << t.tradeId << "</td><td>" << html::esc(t.symbol)
                  << "</td><td>" << t.value << "</td><td>" << t.quantity
                  << "</td><td>" << (t.value * t.quantity) << "</td><td>" << t.takeProfit
                  << "</td><td>" << t.stopLoss << "</td>"
                  << "<td>" << t.buyFee << "</td></tr>";
            }
            h << "</table>";
        }
        h << "<button>Generate</button></form>";
        res.set_content(html::wrap("Generate Horizons", h.str()), "text/html");
    });

    // ========== POST /generate-horizons ==========
    svr.Post("/generate-horizons", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        std::string sym = normalizeSymbol(fv(f, "symbol"));
        std::string idsStr = fv(f, "tradeIds", "0");
        HorizonParams baseP;
        baseP.horizonCount = 1;
        baseP.feeHedgingCoefficient = fd(f, "feeHedgingCoefficient", 1.0);
        baseP.portfolioPump = fd(f, "portfolioPump");
        baseP.symbolCount = fi(f, "symbolCount", 1);
        baseP.coefficientK = fd(f, "coefficientK");
        baseP.feeSpread = fd(f, "feeSpread");
        baseP.deltaTime = fd(f, "deltaTime", 1.0);
        baseP.surplusRate = fd(f, "surplusRate");
        baseP.maxRisk = fd(f, "maxRisk");
        baseP.minRisk = fd(f, "minRisk");
        baseP.generateStopLosses = (fv(f, "generateStopLosses") == "1");
        auto trades = db.loadTrades();
        bool selectAll = (idsStr == "0" || idsStr.empty());
        std::vector<int> selectedIds;
        if (!selectAll)
        {
            std::istringstream ss(idsStr);
            std::string tok;
            while (std::getline(ss, tok, ','))
            {
                try { selectedIds.push_back(std::stoi(tok)); } catch (...) {}
            }
        }
        std::vector<Trade*> buyTrades;
        for (auto& t : trades)
        {
            if (t.symbol != sym || t.type != TradeType::Buy) continue;
            if (selectAll || std::find(selectedIds.begin(), selectedIds.end(), t.tradeId) != selectedIds.end())
                buyTrades.push_back(&t);
        }
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        if (buyTrades.empty())
        {
            h << "<div class='msg err'>No Buy trades found for " << html::esc(sym) << "</div>";
        }
        else
        {
            { bool canH = db.hasBuyTrades();
              h << html::workflow(1, canH, canH); }
            h << "<h1>Horizons for " << html::esc(sym) << "</h1>";
            for (auto* bt : buyTrades)
            {
                HorizonParams tp = baseP;
                auto levels = MultiHorizonEngine::generate(*bt, tp);
                MultiHorizonEngine::applyFirstHorizon(*bt, levels, false);
                db.updateTrade(*bt);
                db.saveHorizonLevels(sym, bt->tradeId, levels);
                db.saveParamsSnapshot(
                    TradeDatabase::ParamsRow::from("horizon", sym, bt->tradeId,
                                                   bt->value, bt->quantity, tp, 0.0,
                                                   bt->buyFee, bt->sellFee));
                double overhead = MultiHorizonEngine::computeOverhead(*bt, tp);
                double eo = MultiHorizonEngine::effectiveOverhead(*bt, tp);
                h << "<h2>Trade #" << bt->tradeId
                  << " (price=" << bt->value << " qty=" << bt->quantity
                  << " buyFee=" << bt->buyFee << ")</h2>"
                  << "<div class='row'>"
                     "<div class='stat'><div class='lbl'>Overhead</div><div class='val'>"
                  << std::fixed << std::setprecision(17) << (overhead * 100) << "%</div></div>"
                     "<div class='stat'><div class='lbl'>Effective</div><div class='val'>"
                  << (eo * 100) << "%</div></div></div>"
                  << std::fixed << std::setprecision(17);
                {
                    double base = bt->value * bt->quantity;
                    std::ostringstream con;
                    con << std::fixed << std::setprecision(8);
                    con << "<details><summary style='cursor:pointer;color:#c9a44a;font-size:0.85em;margin:4px 0;'>"
                           "&#9654; Calculation Steps</summary><div class='calc-console'>";
                    con << html::traceOverhead(bt->value, bt->quantity, tp);
                    con << "<span class='hd'>Horizon Levels</span>"
                        << "base = price &times; qty = " << bt->value << " &times; " << bt->quantity
                        << " = <span class='vl'>" << base << "</span>\n";
                    for (const auto& lv : levels)
                    {
                        double factor = eo * (lv.index + 1);
                        con << "\n<span class='vl'>Level " << lv.index << "</span>\n"
                            << "  factor = " << eo << " &times; " << (lv.index + 1) << " = " << factor << "\n"
                            << "  TP = " << base << " &times; (1 + " << factor << ") = <span class='rs'>" << lv.takeProfit << "</span>\n";
                        if (lv.stopLoss > 0)
                            con << "  SL = " << base << " &times; (1 - " << factor << ") = <span class='rs'>" << lv.stopLoss << "</span>\n";
                    }
                    con << "</div></details>";
                    h << con.str();
                }
                h << "<table><tr><th>Lvl</th><th>Take Profit</th><th>TP/unit</th>"
                     "<th>Stop Loss</th><th>SL/unit</th><th>SL?</th></tr>";
                for (const auto& lv : levels)
                {
                    double tpu = bt->quantity > 0 ? lv.takeProfit / bt->quantity : 0;
                    double slu = (bt->quantity > 0 && lv.stopLoss > 0) ? lv.stopLoss / bt->quantity : 0;
                    h << "<tr><td>" << lv.index << "</td>"
                      << "<td>" << lv.takeProfit << "</td><td>" << tpu << "</td>"
                      << "<td>" << lv.stopLoss << "</td><td>" << slu << "</td>"
                      << "<td class='" << (lv.stopLossActive ? "on" : "off") << "'>"
                      << (lv.stopLossActive ? "ON" : "OFF") << "</td></tr>";
                }
                h << "</table>";
            }
            h << "<div class='msg'>Generated and saved for " << buyTrades.size() << " trade(s). SL is OFF by default.</div>";
        }
        h << "<br><a class='btn' href='/generate-horizons'>Back</a> "
             "<a class='btn' href='/trades'>Trades</a>";
        res.set_content(html::wrap("Horizon Results", h.str()), "text/html");
    });
}
===== Routes_Premium.h ===== 
#pragma once

#include "AppContext.h"
#include "HtmlHelpers.h"
#include <sstream>
#include <cstdio>
#include <array>

// Run a command and capture its stdout
static inline std::string execCmd(const std::string& cmd)
{
    std::string result;
#ifdef _WIN32
    FILE* pipe = _popen(cmd.c_str(), "r");
#else
    FILE* pipe = popen(cmd.c_str(), "r");
#endif
    if (!pipe) return "";
    std::array<char, 256> buf;
    while (fgets(buf.data(), (int)buf.size(), pipe))
        result += buf.data();
#ifdef _WIN32
    _pclose(pipe);
#else
    pclose(pipe);
#endif
    // trim trailing whitespace
    while (!result.empty() && (result.back() == '\n' || result.back() == '\r' || result.back() == ' '))
        result.pop_back();
    return result;
}

inline void registerPremiumRoutes(httplib::Server& svr, AppContext& ctx)
{
    // ========== GET /premium ==========
    svr.Get("/premium", [&](const httplib::Request& req, httplib::Response& res) {
        auto user = ctx.currentUser(req);
        if (user.empty()) { res.set_redirect("/login", 303); return; }

        std::ostringstream pg;
        pg << std::fixed << std::setprecision(8);
        pg << html::msgBanner(req) << html::errBanner(req);
        pg << "<h1>Premium</h1>";

        if (ctx.users.isAdmin(user))
        {
            pg << "<div class='msg'>Admin accounts have permanent premium access.</div>";
            res.set_content(html::wrap("Premium", pg.str()), "text/html");
            return;
        }

        if (ctx.users.isPremium(user))
        {
            pg << "<div class='msg'>You have premium access! Unlimited trades enabled.</div>";
            res.set_content(html::wrap("Premium", pg.str()), "text/html");
            return;
        }

        double priceMbtc = ctx.config.premiumPriceMbtc;
        double priceBtc  = ctx.config.premiumPriceBtc();
        int freeLimit    = ctx.config.freeTradeLimit;
        int tradeCount   = (int)ctx.defaultDb.loadTrades().size();
        int remaining    = freeLimit - tradeCount;
        if (remaining < 0) remaining = 0;

        pg << "<div class='row'>"
              "<div class='stat'><div class='lbl'>Price</div><div class='val'>"
           << priceMbtc << " mBTC</div></div>"
              "<div class='stat'><div class='lbl'>Free Limit</div><div class='val'>"
           << freeLimit << "</div></div>"
              "<div class='stat'><div class='lbl'>Your Trades</div><div class='val'>"
           << tradeCount << "</div></div>"
              "<div class='stat'><div class='lbl'>Remaining</div><div class='val'>"
           << remaining << "</div></div>"
              "</div>";

        pg << "<div class='card' style='margin-top:16px;'>"
              "<h3>Buy Premium</h3>"
              "<p style='color:#64748b;font-size:0.85em;'>"
              "Premium unlocks unlimited trades. Payment is via Bitcoin (Electrum).</p>"
              "<p style='color:#c9a44a;font-size:1.1em;font-weight:bold;'>"
           << priceMbtc << " mBTC (" << priceBtc << " BTC)</p>";

        // check for existing pending payment
        auto* pending = ctx.users.findPendingPayment(user);
        if (pending)
        {
            pg << "<div style='margin:12px 0;padding:12px;background:#0b1426;border:1px solid #1a2744;border-radius:6px;'>"
                  "<div style='color:#64748b;font-size:0.8em;margin-bottom:4px;'>Send exactly:</div>"
                  "<div style='color:#c9a44a;font-size:1.1em;font-weight:bold;'>"
               << pending->requiredBtc << " BTC</div>"
                  "<div style='color:#64748b;font-size:0.8em;margin:8px 0 4px;'>To address:</div>"
                  "<div style='font-family:monospace;color:#58a6ff;font-size:0.95em;word-break:break-all;'>"
               << html::esc(pending->btcAddress) << "</div>"
                  "</div>"
                  "<form method='POST' action='/premium/check'>"
                  "<button style='background:#166534;color:#fff;border:none;padding:8px 20px;"
                  "border-radius:4px;cursor:pointer;font-family:inherit;margin-top:8px;'>"
                  "Check Payment</button></form>"
                  "<form method='POST' action='/premium/cancel' style='margin-top:6px;'>"
                  "<button style='background:#7f1d1d;color:#fca5a5;border:none;padding:6px 16px;"
                  "border-radius:4px;cursor:pointer;font-family:inherit;font-size:0.82em;'>"
                  "Cancel</button></form>";
        }
        else
        {
            pg << "<form method='POST' action='/premium/buy'>"
                  "<button style='background:#1e40af;color:#fff;border:none;padding:10px 24px;"
                  "border-radius:4px;cursor:pointer;font-family:inherit;font-size:0.95em;'>"
                  "Generate Payment Address</button></form>";
        }
        pg << "</div>";
        res.set_content(html::wrap("Premium", pg.str()), "text/html");
    });

    // ========== POST /premium/buy — generate address ==========
    svr.Post("/premium/buy", [&](const httplib::Request& req, httplib::Response& res) {
        auto user = ctx.currentUser(req);
        if (user.empty()) { res.set_redirect("/login", 303); return; }
        if (ctx.users.isPremium(user) || ctx.users.isAdmin(user))
        {
            res.set_redirect("/premium?msg=Already+premium", 303);
            return;
        }

        // remove any existing pending for this user
        ctx.users.removePendingPayment(user);

        // generate new address via electrum CLI
        std::string cmd = ctx.config.electrumCmd() + " createnewaddress";
        std::string address = execCmd(cmd);

        if (address.empty() || address.find("Error") != std::string::npos ||
            address.find("error") != std::string::npos)
        {
            res.set_redirect("/premium?err=" + urlEnc(
                "Electrum error: " + (address.empty() ? "no output" : address)), 303);
            return;
        }

        UserManager::PendingPayment pp;
        pp.username    = user;
        pp.btcAddress  = address;
        pp.requiredBtc = ctx.config.premiumPriceBtc();
        pp.createdAt   = std::chrono::system_clock::now().time_since_epoch().count() > 0
                         ? [&]() {
                             auto now = std::chrono::system_clock::now();
                             auto t = std::chrono::system_clock::to_time_t(now);
                             std::tm tm{};
#ifdef _WIN32
                             localtime_s(&tm, &t);
#else
                             localtime_r(&t, &tm);
#endif
                             std::ostringstream ss;
                             ss << std::put_time(&tm, "%Y-%m-%dT%H:%M:%S");
                             return ss.str();
                         }() : "";
        ctx.users.addPendingPayment(pp);

        res.set_redirect("/premium?msg=Address+generated", 303);
    });

    // ========== POST /premium/check — verify payment ==========
    svr.Post("/premium/check", [&](const httplib::Request& req, httplib::Response& res) {
        auto user = ctx.currentUser(req);
        if (user.empty()) { res.set_redirect("/login", 303); return; }

        auto* pending = ctx.users.findPendingPayment(user);
        if (!pending)
        {
            res.set_redirect("/premium?err=No+pending+payment", 303);
            return;
        }

        // check balance via electrum CLI
        std::string cmd = ctx.config.electrumCmd() + " getaddressbalance " + pending->btcAddress;
        std::string output = execCmd(cmd);

        // parse confirmed balance from electrum output
        // output format: {"confirmed": "0.005", "unconfirmed": "0.0"}
        double confirmed = 0.0;
        auto cpos = output.find("\"confirmed\"");
        if (cpos != std::string::npos)
        {
            auto qstart = output.find('"', cpos + 11);
            if (qstart != std::string::npos)
            {
                qstart++;
                auto qend = output.find('"', qstart);
                if (qend != std::string::npos)
                {
                    try { confirmed = std::stod(output.substr(qstart, qend - qstart)); }
                    catch (...) {}
                }
            }
        }

        if (confirmed >= pending->requiredBtc)
        {
            ctx.users.setPremium(user, true);
            ctx.users.removePendingPayment(user);
            res.set_redirect("/premium?msg=Payment+confirmed!+Premium+activated.", 303);
        }
        else
        {
            std::ostringstream msg;
            msg << std::fixed << std::setprecision(8);
            msg << "Not enough confirmed yet. Got " << confirmed
                << " BTC, need " << pending->requiredBtc << " BTC";
            res.set_redirect("/premium?err=" + urlEnc(msg.str()), 303);
        }
    });

    // ========== POST /premium/cancel ==========
    svr.Post("/premium/cancel", [&](const httplib::Request& req, httplib::Response& res) {
        auto user = ctx.currentUser(req);
        if (!user.empty())
            ctx.users.removePendingPayment(user);
        res.set_redirect("/premium?msg=Payment+cancelled", 303);
    });
}
===== Routes_PriceCheck.h ===== 
#pragma once

#include "AppContext.h"
#include "HtmlHelpers.h"
#include <mutex>
#include <algorithm>

inline void registerPriceCheckRoutes(httplib::Server& svr, AppContext& ctx)
{
    auto& db = ctx.defaultDb;
    auto& dbMutex = ctx.dbMutex;

    // ========== GET /price-check ==========
    svr.Get("/price-check", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << html::msgBanner(req) << html::errBanner(req);
        h << "<h1>Price Check (TP/SL vs Market)</h1>";
        auto trades = db.loadTrades();
        std::vector<std::string> symbols;
        for (const auto& t : trades)
            if (t.type == TradeType::Buy && std::find(symbols.begin(), symbols.end(), t.symbol) == symbols.end())
                symbols.push_back(t.symbol);
        if (symbols.empty()) { h << "<p class='empty'>(no Buy trades)</p>"; }
        else
        {
            h << "<form class='card' method='POST' action='/price-check'><h3>Enter current market prices</h3>";
            for (const auto& sym : symbols)
                h << "<label>" << html::esc(sym) << "</label><input type='number' name='price_" << html::esc(sym) << "' step='any' required><br>";
            h << "<br><button>Check</button></form>";
        }
        res.set_content(html::wrap("Price Check", h.str()), "text/html");
    });

    // ========== POST /price-check ==========
    svr.Post("/price-check", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        auto trades = db.loadTrades();
        std::vector<std::string> symbols;
        for (const auto& t : trades)
            if (t.type == TradeType::Buy && std::find(symbols.begin(), symbols.end(), t.symbol) == symbols.end())
                symbols.push_back(t.symbol);
        auto priceFor = [&](const std::string& sym) -> double { return fd(f, "price_" + sym, 0.0); };
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << "<h1>Price Check Results</h1>";
        h << "<form class='card' method='POST' action='/price-check'><h3>Update prices</h3>";
        for (const auto& sym : symbols)
        { double p = priceFor(sym); h << "<label>" << html::esc(sym) << "</label><input type='number' name='price_" << html::esc(sym) << "' step='any' value='" << p << "' required><br>"; }
        h << "<br><button>Check</button></form>";
        h << "<table><tr><th>ID</th><th>Symbol</th><th>Entry</th><th>Qty</th><th>Market</th><th>Gross P&amp;L</th><th>Net P&amp;L</th><th>ROI%</th>"
             "<th>TP Price</th><th>TP?</th><th>SL Price</th><th>SL?</th></tr>";
        struct Trigger { int id; std::string sym; double price; double qty; std::string tag; };
        std::vector<Trigger> triggers;
        for (const auto& t : trades)
        {
            if (t.type != TradeType::Buy) continue;
            double remaining = t.quantity - db.soldQuantityForParent(t.tradeId);
            if (remaining <= 0) continue;
            double cur = priceFor(t.symbol);
            if (cur <= 0) continue;
            double gross = (cur - t.value) * remaining;
            double remainFrac = (t.quantity > 0) ? remaining / t.quantity : 0.0;
            double net = gross - t.buyFee * remainFrac;
            double cost = (t.value * remaining) + (t.buyFee * remainFrac);
            double roi = (cost != 0.0) ? (net / cost) * 100.0 : 0.0;
            double tpPrice = 0, slPrice = 0;
            bool tpHit = false, slHit = false;
            if (t.takeProfit > 0) { tpPrice = t.takeProfit / t.quantity; tpHit = (cur >= tpPrice); }
            if (t.stopLossActive && t.stopLoss > 0) { slPrice = t.stopLoss / t.quantity; slHit = (cur <= slPrice); }
            h << "<tr><td>" << t.tradeId << "</td><td>" << html::esc(t.symbol) << "</td><td>" << t.value << "</td><td>" << remaining << "</td>"
              << "<td>" << cur << "</td><td class='" << (gross >= 0 ? "buy" : "sell") << "'>" << gross << "</td>"
              << "<td class='" << (net >= 0 ? "buy" : "sell") << "'>" << net << "</td>"
              << "<td class='" << (roi >= 0 ? "buy" : "sell") << "'>" << roi << "</td>"
              << "<td>" << tpPrice << "</td><td class='" << (tpHit ? "buy" : "off") << "'>" << (tpHit ? "HIT" : "-") << "</td>"
              << "<td>" << slPrice << "</td><td class='" << (slHit ? "sell" : "off") << "'>" << (slHit ? "BREACHED" : "-") << "</td></tr>";
            auto levels = db.loadHorizonLevels(t.symbol, t.tradeId);
            for (const auto& lv : levels)
            {
                double htp = t.quantity > 0 ? lv.takeProfit / t.quantity : 0;
                double hsl = (t.quantity > 0 && lv.stopLoss > 0) ? lv.stopLoss / t.quantity : 0;
                bool htpHit = (cur >= htp);
                bool hslHit = (lv.stopLossActive && hsl > 0 && cur <= hsl);
                h << "<tr style='color:#64748b;'><td></td><td>[" << lv.index << "]</td><td></td><td></td><td></td><td></td><td></td><td></td>"
                  << "<td>" << htp << "</td><td class='" << (htpHit ? "buy" : "off") << "'>" << (htpHit ? "HIT" : (htp > 0 ? std::to_string(htp - cur) + " away" : "-")) << "</td>"
                  << "<td>" << hsl << "</td><td class='" << (hslHit ? "sell" : "off") << "'>";
                if (hsl > 0 && lv.stopLossActive) h << (hslHit ? "BREACHED" : "OK");
                else if (hsl > 0) h << "OFF";
                else h << "-";
                h << "</td></tr>";
            }
            if (tpHit) triggers.push_back({t.tradeId, t.symbol, cur, remaining, "TP"});
            if (slHit) triggers.push_back({t.tradeId, t.symbol, cur, remaining, "SL"});
        }
        h << "</table>";
        auto pending = db.loadPendingExits();
        std::vector<TradeDatabase::PendingExit> triggered;
        for (const auto& pe : pending)
        { double cur = priceFor(pe.symbol); if (cur > 0 && cur >= pe.triggerPrice) triggered.push_back(pe); }
        if (!triggered.empty())
        {
            h << "<h2>Pending Exits Triggered</h2><table><tr><th>Order</th><th>Symbol</th><th>Trade</th><th>Trigger</th><th>Market</th><th>Qty</th></tr>";
            for (const auto& pe : triggered)
                h << "<tr><td>" << pe.orderId << "</td><td>" << html::esc(pe.symbol) << "</td><td>" << pe.tradeId << "</td>"
                  << "<td>" << pe.triggerPrice << "</td><td>" << priceFor(pe.symbol) << "</td><td>" << pe.sellQty << "</td></tr>";
            h << "</table>";
        }
        if (!triggers.empty())
        {
            h << "<h2>TP/SL Triggers</h2><table><tr><th>Tag</th><th>ID</th><th>Symbol</th><th>Qty</th><th>Market</th></tr>";
            for (const auto& tr : triggers)
                h << "<tr><td class='" << (tr.tag == "TP" ? "buy" : "sell") << "'>" << tr.tag << "</td>"
                  << "<td>" << tr.id << "</td><td>" << html::esc(tr.sym) << "</td><td>" << tr.qty << "</td><td>" << tr.price << "</td></tr>";
            h << "</table>";
        }
        {
            auto entryPts = db.loadEntryPoints();
            struct TriggeredEP { int entryId; std::string symbol; double entryPrice; double fundingQty; double exitTP; double exitSL; bool isShort; double marketPrice; };
            std::vector<TriggeredEP> hitEntries;
            for (const auto& ep : entryPts)
            {
                if (ep.traded) continue;
                double cur = priceFor(ep.symbol);
                if (cur < 0) continue;
                bool hit = ep.isShort ? (cur >= ep.entryPrice) : (cur <= ep.entryPrice);
                if (hit) hitEntries.push_back({ep.entryId, ep.symbol, ep.entryPrice, ep.fundingQty, ep.exitTakeProfit, ep.exitStopLoss, ep.isShort, cur});
            }
            if (!hitEntries.empty())
            {
                h << "<h2>Entry Points Triggered (" << hitEntries.size() << ")</h2>"
                     "<form class='card' method='POST' action='/execute-triggered-entries'>"
                     "<table><tr><th>ID</th><th>Symbol</th><th>Entry</th><th>Market</th><th>Qty</th><th>Cost</th><th>TP</th><th>SL</th><th>Buy Fee</th></tr>";
                for (const auto& te : hitEntries)
                {
                    double cost = te.entryPrice * te.fundingQty;
                    h << "<tr><td>" << te.entryId << "</td><td>" << html::esc(te.symbol) << "</td><td>" << te.entryPrice << "</td>"
                      << "<td class='buy'>" << te.marketPrice << "</td><td>" << te.fundingQty << "</td><td>" << cost << "</td>"
                      << "<td>" << te.exitTP << "</td><td>" << te.exitSL << "</td>"
                      << "<td><input type='number' name='fee_" << te.entryId << "' step='any' value='0' style='width:80px;'>"
                      << "<input type='hidden' name='epid_" << te.entryId << "' value='1'></td></tr>";
                }
                h << "</table><button>Execute Triggered Entries</button></form>";
            }
        }
        h << "<br><a class='btn' href='/price-check'>Back</a> <a class='btn' href='/trades'>Trades</a>";
        res.set_content(html::wrap("Price Check Results", h.str()), "text/html");
    });

    // ========== POST /execute-triggered-entries ==========
    svr.Post("/execute-triggered-entries", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        auto entryPts = db.loadEntryPoints();
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << "<h1>Entry Execution</h1>";
        int executed = 0, failed = 0;
        h << "<table><tr><th>ID</th><th>Symbol</th><th>Entry</th><th>Qty</th><th>Fee</th><th>Trade</th><th>TP</th><th>SL</th><th>Status</th></tr>";
        for (auto& ep : entryPts)
        {
            if (ep.traded) continue;
            if (fv(f, "epid_" + std::to_string(ep.entryId)).empty()) continue;
            double buyFee = fd(f, "fee_" + std::to_string(ep.entryId));
            double cost = ep.entryPrice * ep.fundingQty + buyFee;
            double walBal = db.loadWalletBalance();
            if (cost > walBal)
            {
                h << "<tr><td>" << ep.entryId << "</td><td>" << html::esc(ep.symbol) << "</td><td>" << ep.entryPrice << "</td>"
                  << "<td>" << ep.fundingQty << "</td><td>" << buyFee << "</td><td>-</td><td>-</td><td>-</td>"
                  << "<td class='sell'>INSUFFICIENT (need " << cost << ", have " << walBal << ")</td></tr>";
                ++failed; continue;
            }
            int bid = db.executeBuy(ep.symbol, ep.entryPrice, ep.fundingQty, buyFee);
            ep.traded = true; ep.linkedTradeId = bid;
            h << "<tr><td>" << ep.entryId << "</td><td>" << html::esc(ep.symbol) << "</td><td>" << ep.entryPrice << "</td>"
              << "<td>" << ep.fundingQty << "</td><td>" << buyFee << "</td><td class='buy'>#" << bid << "</td>"
              << "<td>" << ep.exitTakeProfit << "</td><td>" << ep.exitStopLoss << "</td><td class='buy'>OK</td></tr>";
            ++executed;
        }
        h << "</table>";
        if (executed > 0)
        {
            auto trades = db.loadTrades();
            for (const auto& ep : entryPts)
            {
                if (ep.linkedTradeId < 0) continue;
                auto* tradePtr = db.findTradeById(trades, ep.linkedTradeId);
                if (!tradePtr) continue;
                tradePtr->takeProfit = ep.exitTakeProfit * tradePtr->quantity;
                tradePtr->stopLoss = ep.exitStopLoss * tradePtr->quantity;
                tradePtr->stopLossActive = false;
                db.updateTrade(*tradePtr);
            }
        }
        db.saveEntryPoints(entryPts);
        h << "<div class='row'>"
             "<div class='stat'><div class='lbl'>Executed</div><div class='val'>" << executed << "</div></div>"
             "<div class='stat'><div class='lbl'>Failed</div><div class='val'>" << failed << "</div></div>"
             "<div class='stat'><div class='lbl'>Wallet</div><div class='val'>" << db.loadWalletBalance() << "</div></div></div>";
        h << "<br><a class='btn' href='/trades'>Trades</a> <a class='btn' href='/entry-points'>Entry Points</a> <a class='btn' href='/price-check'>Price Check</a>";
        res.set_content(html::wrap("Entry Execution", h.str()), "text/html");
    });
}
===== Routes_Profit.h ===== 
#pragma once

#include "AppContext.h"
#include "HtmlHelpers.h"
#include <mutex>

inline void registerProfitRoutes(httplib::Server& svr, AppContext& ctx)
{
    auto& db = ctx.defaultDb;
    auto& dbMutex = ctx.dbMutex;

    // ========== GET /profit ï¿½ Profit calculator form ==========
    svr.Get("/profit", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << html::msgBanner(req) << html::errBanner(req);
        h << "<h1>Profit Calculator</h1>"
             "<form class='card' method='POST' action='/profit'><h3>Calculate</h3>"
             "<label>Trade ID</label><input type='number' name='tradeId' required><br>"
             "<label>Current Price</label><input type='number' name='currentPrice' step='any' required><br>"
             "<label>Buy Fees</label><input type='number' name='buyFees' step='any' value='0'><br>"
             "<label>Sell Fees</label><input type='number' name='sellFees' step='any' value='0'><br>"
             "<button>Calculate</button></form>";
        auto trades = db.loadTrades();
        bool any = false;
        for (const auto& t : trades) if (t.type == TradeType::Buy) { any = true; break; }
        if (any)
        {
            h << "<h2>Buy Trades</h2><table><tr><th>ID</th><th>Symbol</th><th>Price</th><th>Qty</th><th>Sold</th><th>Rem</th><th>Buy Fee</th><th>Sell Fee</th></tr>";
            for (const auto& t : trades)
                if (t.type == TradeType::Buy)
                {
                    double sold = db.soldQuantityForParent(t.tradeId);
                    h << "<tr><td>" << t.tradeId << "</td><td>" << html::esc(t.symbol)
                      << "</td><td>" << t.value << "</td><td>" << t.quantity
                      << "</td><td>" << sold << "</td><td>" << (t.quantity - sold)
                      << "</td><td>" << t.buyFee << "</td><td>" << t.sellFee << "</td></tr>";
                }
            h << "</table>";
        }
        res.set_content(html::wrap("Profit", h.str()), "text/html");
    });

    // ========== POST /profit ï¿½ Calculate and show result ==========
    svr.Post("/profit", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        int id = fi(f, "tradeId");
        double cur = fd(f, "currentPrice");
        double buyFees = fd(f, "buyFees");
        double sellFees = fd(f, "sellFees");
        auto trades = db.loadTrades();
        auto* tp = db.findTradeById(trades, id);

        if (tp) {
            if (buyFees == 0.0) buyFees = tp->buyFee;
            if (sellFees == 0.0) sellFees = tp->sellFee;
        }

        std::ostringstream h;
        h << std::fixed << std::setprecision(17);

        if (!tp) { h << "<div class='msg err'>Trade not found</div>"; }
        else
        {
            bool isBuy = (tp->type == TradeType::Buy);
            double sold = isBuy ? db.soldQuantityForParent(tp->tradeId) : 0.0;
            double remaining = isBuy ? (tp->quantity - sold) : tp->quantity;
            double proRatedBuyFee = (tp->quantity > 0 && isBuy) ? buyFees * (remaining / tp->quantity) : buyFees;
            auto r = ProfitCalculator::calculateForQty(*tp, cur, remaining, proRatedBuyFee, sellFees);
            db.saveProfitSnapshot(tp->symbol, id, cur, r);

            h << "<h1>Profit Result</h1>";

            // realized profit from child sells (buy trades only)
            double realizedNet = 0;
            if (isBuy)
            {
                h << "<h2>Realized (Child Sells)</h2>";
                bool anyChild = false;
                for (const auto& c : trades)
                {
                    if (c.type != TradeType::CoveredSell || c.parentTradeId != tp->tradeId) continue;
                    if (!anyChild)
                    {
                        h << "<table><tr><th>Sell ID</th><th>Sell Price</th><th>Qty</th>"
                             "<th>Gross</th><th>Net</th><th>ROI</th></tr>";
                        anyChild = true;
                    }
                    auto cp = ProfitCalculator::childProfit(c, tp->value);
                    realizedNet += cp.netProfit;
                    h << "<tr><td>" << c.tradeId << "</td><td>" << c.value << "</td>"
                      << "<td>" << c.quantity << "</td>"
                      << "<td>" << cp.grossProfit << "</td>"
                      << "<td class='" << (cp.netProfit >= 0 ? "buy" : "sell") << "'>" << cp.netProfit << "</td>"
                      << "<td>" << cp.roi << "%</td></tr>";
                }
                if (anyChild) h << "</table>";
                else h << "<p class='empty'>(no sells yet)</p>";
            }

            h << "<h2>Unrealized (Remaining " << remaining << " qty)</h2>"
                 "<div class='row'>"
                 "<div class='stat'><div class='lbl'>Trade</div><div class='val'>#" << id << " " << html::esc(tp->symbol) << "</div></div>"
                 "<div class='stat'><div class='lbl'>Entry</div><div class='val'>" << tp->value << "</div></div>"
                 "<div class='stat'><div class='lbl'>Current</div><div class='val'>" << cur << "</div></div>"
                 "<div class='stat'><div class='lbl'>Qty</div><div class='val'>" << remaining << " / " << tp->quantity << "</div></div>"
                 "<div class='stat'><div class='lbl'>Gross</div><div class='val'>" << r.grossProfit << "</div></div>"
                 "<div class='stat'><div class='lbl'>Net</div><div class='val'>" << r.netProfit << "</div></div>"
                 "<div class='stat'><div class='lbl'>ROI</div><div class='val'>" << r.roi << "%</div></div>"
                 "</div>";

            if (isBuy)
            {
                double totalNet = realizedNet + r.netProfit;
                h << "<h2>Combined</h2>"
                     "<div class='row'>"
                     "<div class='stat'><div class='lbl'>Realized</div><div class='val "
                  << (realizedNet >= 0 ? "buy" : "sell") << "'>" << realizedNet << "</div></div>"
                     "<div class='stat'><div class='lbl'>Unrealized</div><div class='val "
                  << (r.netProfit >= 0 ? "buy" : "sell") << "'>" << r.netProfit << "</div></div>"
                     "<div class='stat'><div class='lbl'>Total</div><div class='val "
                  << (totalNet >= 0 ? "buy" : "sell") << "'>" << totalNet << "</div></div>"
                     "</div>";
            }

            h << "<div class='msg'>Snapshot saved</div>";
            h << "<details><summary style='cursor:pointer;color:#c9a44a;font-size:0.85em;margin:8px 0;'>"
                  "&#9654; Calculation Steps</summary><div class='calc-console'>";
            // build a temp trade with remaining qty for trace display
            Trade tempTrade = *tp;
            tempTrade.quantity = remaining;
            tempTrade.buyFee = proRatedBuyFee;
            h << html::traceProfit(tempTrade, cur, proRatedBuyFee, sellFees, r)
              << "</div></details>";
        }

        h << "<br><form class='card' method='POST' action='/profit'><h3>Calculate Again</h3>"
             "<label>Trade ID</label><input type='number' name='tradeId' value='" << id << "' required><br>"
             "<label>Current Price</label><input type='number' name='currentPrice' step='any' value='" << cur << "' required><br>"
             "<label>Buy Fees</label><input type='number' name='buyFees' step='any' value='" << buyFees << "'><br>"
             "<label>Sell Fees</label><input type='number' name='sellFees' step='any' value='" << sellFees << "'><br>"
             "<button>Calculate</button></form>"
             "<a class='btn' href='/profit'>Back</a>";
        res.set_content(html::wrap("Profit Result", h.str()), "text/html");
    });

    // ========== GET /profit-history ==========
    svr.Get("/profit-history", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << "<h1>Profit History</h1>";
        auto rows = db.loadProfitHistory();
        if (rows.empty()) { h << "<p class='empty'>(no history)</p>"; }
        else
        {
            h << "<table><tr><th>Trade</th><th>Symbol</th><th>Price</th>"
                 "<th>Gross</th><th>Net</th><th>ROI</th></tr>";
            for (const auto& r : rows)
            {
                h << "<tr><td>" << r.tradeId << "</td><td>" << html::esc(r.symbol)
                  << "</td><td>" << r.currentPrice << "</td><td>" << r.grossProfit
                  << "</td><td>" << r.netProfit << "</td><td>" << r.roi << "%</td></tr>";
            }
            h << "</table>";
        }
        res.set_content(html::wrap("Profit History", h.str()), "text/html");
    });

    // ========== GET /params-history ==========
    svr.Get("/params-history", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << "<h1>Parameter History</h1>";
        auto rows = db.loadParamsHistory();
        if (rows.empty()) { h << "<p class='empty'>(no history)</p>"; }
        else
        {
            h << "<table><tr><th>Type</th><th>Symbol</th><th>Trade</th>"
                 "<th>Price</th><th>Qty</th><th>Levels</th><th>BuyFee</th><th>SellFee</th>"
                 "<th>Hedging</th><th>Pump</th><th>Symbols</th><th>K</th>"
                 "<th>Spread</th><th>dT</th><th>Surplus</th><th>MaxRisk</th><th>MinRisk</th><th>Risk</th></tr>";
            for (const auto& r : rows)
            {
                h << "<tr><td>" << html::esc(r.calcType) << "</td>"
                  << "<td>" << html::esc(r.symbol) << "</td>"
                  << "<td>" << r.tradeId << "</td>"
                  << "<td>" << r.currentPrice << "</td><td>" << r.quantity << "</td>"
                  << "<td>" << r.horizonCount << "</td>"
                  << "<td>" << r.buyFees << "</td><td>" << r.sellFees << "</td>"
                  << "<td>" << r.feeHedgingCoefficient << "</td>"
                  << "<td>" << r.portfolioPump << "</td><td>" << r.symbolCount << "</td>"
                  << "<td>" << r.coefficientK << "</td>"
                  << "<td>" << r.feeSpread << "</td><td>" << r.deltaTime << "</td>"
                  << "<td>" << r.surplusRate << "</td><td>" << r.maxRisk << "</td><td>" << r.minRisk << "</td><td>" << r.riskCoefficient << "</td></tr>";
            }
            h << "</table>";
        }
        res.set_content(html::wrap("Params History", h.str()), "text/html");
    });
}
===== Routes_SerialGen.h ===== 
#pragma once

#include "AppContext.h"
#include "HtmlHelpers.h"
#include <mutex>
#include <cmath>
#include <limits>

inline void registerSerialGenRoutes(httplib::Server& svr, AppContext& ctx)
{
    auto& db = ctx.defaultDb;
    auto& dbMutex = ctx.dbMutex;

    // ========== GET /serial-generator ==========
    svr.Get("/serial-generator", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << html::msgBanner(req) << html::errBanner(req);
        double walBal = db.loadWalletBalance();
        h << "<h1>Serial Generator</h1>"
             "<div style='color:#64748b;font-size:0.82em;margin-bottom:12px;'>Generate a full series of entry + horizon + exit tuples</div>"
             "<div class='row'><div class='stat'><div class='lbl'>Wallet</div><div class='val'>" << walBal << "</div></div></div><br>"
             "<form class='card' method='POST' action='/serial-generator'><h3>Parameters</h3>"
             "<label>Symbol</label><input type='text' name='symbol' required><br>"
             "<label>Current Price</label><input type='number' name='currentPrice' step='any' required><br>"
             "<label>Quantity</label><input type='number' name='quantity' step='any' required><br>"
             "<label>Entry Levels</label><input type='number' name='levels' value='4'><br>"
             "<label>Risk</label><input type='number' name='risk' step='any' value='0.5'><br>"
             "<label>Steepness</label><input type='number' name='steepness' step='any' value='6'><br>"
             "<label>Fee Hedging</label><input type='number' name='feeHedgingCoefficient' step='any' value='1'><br>"
             "<label>Pump</label><input type='number' name='portfolioPump' step='any' value='0'><br>"
             "<label>Symbol Count</label><input type='number' name='symbolCount' value='1'><br>"
             "<label>Coefficient K</label><input type='number' name='coefficientK' step='any' value='0'><br>"
             "<label>Fee Spread</label><input type='number' name='feeSpread' step='any' value='0'><br>"
             "<label>Delta Time</label><input type='number' name='deltaTime' step='any' value='1'><br>"
             "<label>Surplus Rate</label><input type='number' name='surplusRate' step='any' value='0.02'><br>"
             "<label>Max Risk</label><input type='number' name='maxRisk' step='any' value='0'><br>"
             "<label>Min Risk</label><input type='number' name='minRisk' step='any' value='0'><br>"
             "<label>Direction</label><select name='isShort'><option value='0'>LONG</option><option value='1'>SHORT</option></select><br>"
             "<label>Funding</label><select name='fundMode'><option value='1'>Pump only</option><option value='2'>Pump + Wallet</option></select><br>"
             "<label>Stop Losses</label><select name='generateStopLosses'><option value='0'>No</option><option value='1'>Yes</option></select><br>"
             "<label>Range Above</label><input type='number' name='rangeAbove' step='any' value='0'><br>"
             "<label>Range Below</label><input type='number' name='rangeBelow' step='any' value='0'><br>"
             "<button>Generate Series</button></form>";
        res.set_content(html::wrap("Serial Generator", h.str()), "text/html");
    });

    // ========== POST /serial-generator ==========
    svr.Post("/serial-generator", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        std::string sym = normalizeSymbol(fv(f, "symbol"));
        double cur = fd(f, "currentPrice");
        double qty = fd(f, "quantity");
        double risk = fd(f, "risk");
        double steepness = fd(f, "steepness", 6.0);
        bool isShort = (fv(f, "isShort") == "1");
        int fundMode = fi(f, "fundMode", 1);
        bool genSL = (fv(f, "generateStopLosses") == "1");
        double rangeAbove = fd(f, "rangeAbove");
        double rangeBelow = fd(f, "rangeBelow");
        HorizonParams p;
        p.horizonCount = fi(f, "levels", 4);
        p.feeHedgingCoefficient = fd(f, "feeHedgingCoefficient", 1.0);
        p.portfolioPump = fd(f, "portfolioPump");
        p.symbolCount = fi(f, "symbolCount", 1);
        p.coefficientK = fd(f, "coefficientK");
        p.feeSpread = fd(f, "feeSpread");
        p.deltaTime = fd(f, "deltaTime", 1.0);
        p.surplusRate = fd(f, "surplusRate");
        p.maxRisk = fd(f, "maxRisk");
        p.minRisk = fd(f, "minRisk");
        p.generateStopLosses = genSL;
        double walBal = db.loadWalletBalance();
        double availableFunds = p.portfolioPump;
        if (fundMode == 2) availableFunds += walBal;
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        if (sym.empty() || cur <= 0 || qty <= 0)
        { h << "<div class='msg err'>Symbol, price, and quantity are required</div><br><a class='btn' href='/serial-generator'>Back</a>";
          res.set_content(html::wrap("Serial Generator", h.str()), "text/html"); return; }
        int N = p.horizonCount; if (N < 1) N = 1;
        if (steepness < 0.1) steepness = 0.1;
        auto sigmoid = [](double x) { return 1.0 / (1.0 + std::exp(-x)); };
        double sig0 = sigmoid(-steepness * 0.5);
        double sig1 = sigmoid(steepness * 0.5);
        double sigRange = (sig1 - sig0 > 0) ? sig1 - sig0 : 1.0;
        double eo = MultiHorizonEngine::effectiveOverhead(cur, qty, p);
        double overhead = MultiHorizonEngine::computeOverhead(cur, qty, p);
        struct SerialEntry { int idx; double entryPrice; double breakEven; double discount;
            double funding; double fundFrac; double fundQty; double tpTotal; double tpu; double tpGross;
            double slTotal; double slu; double slLoss; };
        std::vector<SerialEntry> entries;
        double priceLow, priceHigh;
        if (rangeAbove > 0.0 || rangeBelow > 0.0)
        { priceLow = cur - rangeBelow; if (priceLow < std::numeric_limits<double>::epsilon()) priceLow = std::numeric_limits<double>::epsilon();
          priceHigh = cur + rangeAbove; }
        else { priceLow = 0.0; priceHigh = cur; }
        std::vector<double> norm(N);
        for (int i = 0; i < N; ++i)
        { double t = (N > 1) ? static_cast<double>(i) / static_cast<double>(N - 1) : 1.0;
          double sigVal = sigmoid(steepness * (t - 0.5)); norm[i] = (sigVal - sig0) / sigRange; }
        double riskClamped = (risk < 0) ? 0 : (risk > 1) ? 1 : risk;
        std::vector<double> weights(N);
        double weightSum = 0;
        for (int i = 0; i < N; ++i)
        { weights[i] = (1.0 - riskClamped) * norm[i] + riskClamped * (1.0 - norm[i]);
          if (weights[i] < 1e-12) weights[i] = 1e-12; weightSum += weights[i]; }
        for (int i = 0; i < N; ++i)
        {
            double entryPrice = priceLow + norm[i] * (priceHigh - priceLow);
            if (entryPrice < std::numeric_limits<double>::epsilon()) entryPrice = std::numeric_limits<double>::epsilon();
            double tpPrice = MultiHorizonEngine::levelTP(entryPrice, overhead, eo, p, steepness, i, N, isShort, riskClamped, priceHigh);
            double slPrice = MultiHorizonEngine::levelSL(entryPrice, eo, isShort);
            double fundFrac = (weightSum > 0) ? weights[i] / weightSum : 0;
            double funding = availableFunds * fundFrac;
            double fundQty = funding / entryPrice;
            double breakEven = entryPrice * (1.0 + overhead);
            double cost = entryPrice * fundQty;
            double tpTotal = tpPrice * fundQty;
            double tpGross = tpTotal - cost;
            double slTotal = genSL ? slPrice * fundQty : 0;
            double slLoss = genSL ? slTotal - cost : 0;
            double disc = cur > 0 ? ((cur - entryPrice) / cur * 100) : 0;
            entries.push_back({i, entryPrice, breakEven, disc, funding, fundFrac, fundQty, tpTotal, tpPrice, tpGross, slTotal, slPrice, slLoss});
        }
        h << "<h1>Serial Plan: " << html::esc(sym) << " @ " << cur << "</h1>";
        h << "<div class='row'>"
             "<div class='stat'><div class='lbl'>Overhead</div><div class='val'>" << (overhead * 100) << "%</div></div>"
             "<div class='stat'><div class='lbl'>Effective</div><div class='val'>" << (eo * 100) << "%</div></div>"
             "<div class='stat'><div class='lbl'>Surplus</div><div class='val'>" << (p.surplusRate * 100) << "%</div></div>"
             "<div class='stat'><div class='lbl'>Direction</div><div class='val'>" << (isShort ? "SHORT" : "LONG") << "</div></div>"
             "<div class='stat'><div class='lbl'>Available</div><div class='val'>" << availableFunds << "</div></div>"
             "<div class='stat'><div class='lbl'>Steepness</div><div class='val'>" << steepness << "</div></div></div>";
        h << "<h2>Entry + Exit Tuples</h2><table><tr><th>Lvl</th><th>Entry</th><th>Discount</th><th>Qty</th><th>Cost</th>"
             "<th>Break Even</th><th>TP/unit</th><th>TP Total</th><th>TP Gross</th>";
        if (genSL) h << "<th>SL/unit</th><th>SL Total</th><th>SL Loss</th>";
        h << "</tr>";
        for (const auto& e : entries)
        {
            double cost = e.entryPrice * e.fundQty;
            h << "<tr><td>" << e.idx << "</td><td>" << e.entryPrice << "</td><td>" << e.discount << "%</td>"
              << "<td>" << e.fundQty << "</td><td>" << cost << "</td><td>" << e.breakEven << "</td>"
              << "<td class='buy'>" << e.tpu << "</td><td class='buy'>" << e.tpTotal << "</td><td class='buy'>" << e.tpGross << "</td>";
            if (genSL)
                h << "<td class='sell'>" << e.slu << "</td><td class='sell'>" << e.slTotal << "</td><td class='sell'>" << e.slLoss << "</td>";
            h << "</tr>";
        }
        h << "</table>";
        h << "<h2>Save Series</h2><form class='card' method='POST' action='/save-serial'>"
             "<h3>Save all entries as pending (buy fees entered when price hits)</h3>"
             "<input type='hidden' name='symbol' value='" << html::esc(sym) << "'>"
             "<input type='hidden' name='isShort' value='" << (isShort ? "1" : "0") << "'>"
             "<input type='hidden' name='pump' value='" << p.portfolioPump << "'>"
             "<input type='hidden' name='entryCount' value='" << N << "'>";
        for (const auto& e : entries)
        {
            if (e.funding <= 0) continue;
            h << "<input type='hidden' name='ep_" << e.idx << "' value='" << e.entryPrice << "'>"
              << "<input type='hidden' name='eq_" << e.idx << "' value='" << e.fundQty << "'>"
              << "<input type='hidden' name='eb_" << e.idx << "' value='" << e.breakEven << "'>"
              << "<input type='hidden' name='ef_" << e.idx << "' value='" << e.funding << "'>"
              << "<input type='hidden' name='eov_" << e.idx << "' value='" << eo << "'>"
              << "<input type='hidden' name='etp_" << e.idx << "' value='" << e.tpu << "'>"
              << "<input type='hidden' name='esl_" << e.idx << "' value='" << e.slu << "'>";
        }
        h << "<button>Save Entry Points</button></form>";
        h << "<br><a class='btn' href='/serial-generator'>Back</a>";
        res.set_content(html::wrap("Serial Plan", h.str()), "text/html");
    });

    // ========== POST /save-serial ==========
    svr.Post("/save-serial", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        std::string sym = normalizeSymbol(fv(f, "symbol"));
        bool isShort = (fv(f, "isShort") == "1");
        double pump = fd(f, "pump");
        int count = fi(f, "entryCount");
        if (sym.empty() || count <= 0) { res.set_redirect("/serial-generator?err=Invalid+parameters", 303); return; }
        if (pump > 0) db.deposit(pump);
        int nextEpId = db.nextEntryId();
        std::vector<TradeDatabase::EntryPoint> newPoints;
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << "<h1>Serial Entries Saved: " << html::esc(sym) << "</h1>";
        if (pump > 0) h << "<div class='msg'>Deposited pump " << pump << " into wallet. Balance: " << db.loadWalletBalance() << "</div>";
        h << "<table><tr><th>Lvl</th><th>Entry</th><th>Qty</th><th>Cost</th><th>Exit TP</th><th>Exit SL</th><th>Status</th></tr>";
        for (int i = 0; i < count; ++i)
        {
            std::string si = std::to_string(i);
            double entryPrice = fd(f, "ep_" + si);
            double fundQty = fd(f, "eq_" + si);
            double breakEven = fd(f, "eb_" + si);
            double funding = fd(f, "ef_" + si);
            double effOh = fd(f, "eov_" + si);
            double exitTP = fd(f, "etp_" + si);
            double exitSL = fd(f, "esl_" + si);
            if (funding <= 0) continue;
            double cost = entryPrice * fundQty;
            TradeDatabase::EntryPoint ep;
            ep.symbol = sym; ep.entryId = nextEpId++; ep.levelIndex = i;
            ep.entryPrice = entryPrice; ep.breakEven = breakEven;
            ep.funding = funding; ep.fundingQty = fundQty;
            ep.effectiveOverhead = effOh; ep.isShort = isShort;
            ep.exitTakeProfit = exitTP; ep.exitStopLoss = exitSL;
            ep.traded = false; ep.linkedTradeId = -1;
            newPoints.push_back(ep);
            h << "<tr><td>" << i << "</td><td>" << entryPrice << "</td><td>" << fundQty << "</td>"
              << "<td>" << cost << "</td><td>" << exitTP << "</td><td>" << exitSL << "</td><td class='buy'>PENDING</td></tr>";
        }
        h << "</table>";
        auto existing = db.loadEntryPoints();
        for (const auto& ep : newPoints) existing.push_back(ep);
        db.saveEntryPoints(existing);
        h << "<div class='row'><div class='stat'><div class='lbl'>Saved</div><div class='val'>" << newPoints.size() << "</div></div>"
             "<div class='stat'><div class='lbl'>Wallet</div><div class='val'>" << db.loadWalletBalance() << "</div></div></div>";
        h << "<div class='msg'>" << newPoints.size() << " entry point(s) saved as pending.</div>";
        h << "<br><a class='btn' href='/entry-points'>Entry Points</a> <a class='btn' href='/price-check'>Price Check</a> <a class='btn' href='/serial-generator'>New Series</a>";
        res.set_content(html::wrap("Serial Entries Saved", h.str()), "text/html");
    });
}
===== Routes_Trades.h ===== 
#pragma once

#include "AppContext.h"
#include "HtmlHelpers.h"
#include "ProfitCalculator.h"
#include <mutex>

inline void registerTradeRoutes(httplib::Server& svr, AppContext& ctx)
{
    auto& db = ctx.defaultDb;
    auto& dbMutex = ctx.dbMutex;

    // ========== GET /trades ï¿½ Trades list + forms ==========
    svr.Get("/trades", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << html::msgBanner(req) << html::errBanner(req);
        h << "<h1>Trades</h1>";
        auto trades = db.loadTrades();
        if (trades.empty()) { h << "<p class='empty'>(no trades)</p>"; }
        else
        {
            // collect parent buys, then render each with children indented below
            std::vector<const Trade*> parents;
            std::vector<const Trade*> orphanSells;
            for (const auto& t : trades)
            {
                if (t.type == TradeType::Buy)
                    parents.push_back(&t);
                else if (t.parentTradeId < 0)
                    orphanSells.push_back(&t);
            }

            h << "<table><tr>"
                 "<th>ID</th><th>Symbol</th><th>Type</th><th>Price</th><th>Qty</th>"
                 "<th>Cost</th><th>Fees</th>"
                 "<th>TP</th><th>SL</th><th>SL?</th>"
                 "<th>Sold</th><th>Rem</th><th>Realized</th><th>Actions</th>"
                 "</tr>";

            for (const auto* bp : parents)
            {
                const Trade& b = *bp;
                double sold = db.soldQuantityForParent(b.tradeId);
                double remaining = b.quantity - sold;
                double grossCost = b.value * b.quantity;
                double totalFees = b.buyFee + b.sellFee;
                // sum realized from children
                double realized = 0;
                std::vector<const Trade*> children;
                for (const auto& c : trades)
                {
                    if (c.type == TradeType::CoveredSell && c.parentTradeId == b.tradeId)
                    {
                        children.push_back(&c);
                        auto cp = ProfitCalculator::childProfit(c, b.value);
                        realized += cp.netProfit;
                    }
                }

                // ---- parent row ----
                h << "<tr>"
                  << "<td><a href='/horizons?tradeId=" << b.tradeId << "'><strong>" << b.tradeId << "</strong></a></td>"
                  << "<td><strong>" << html::esc(b.symbol) << "</strong></td>"
                  << "<td class='buy'>BUY</td>"
                  << "<td>" << b.value << "</td><td>" << b.quantity << "</td>"
                  << "<td>" << grossCost << "</td>"
                  << "<td>" << totalFees << "</td>"
                  // TP inline
                  << "<td><form class='iform' method='POST' action='/set-tp'>"
                  << "<input type='hidden' name='id' value='" << b.tradeId << "'>"
                  << "<input type='number' name='tp' step='any' value='" << b.takeProfit << "' style='width:70px;'>"
                  << "<button class='btn-sm' title='Set TP'>&#10003;</button></form></td>"
                  // SL inline
                  << "<td><form class='iform' method='POST' action='/set-sl'>"
                  << "<input type='hidden' name='id' value='" << b.tradeId << "'>"
                  << "<input type='number' name='sl' step='any' value='" << b.stopLoss << "' style='width:70px;'>"
                  << "<button class='btn-sm' title='Set SL'>&#10003;</button></form></td>"
                  // SL toggle
                  << "<td><form class='iform' method='POST' action='/toggle-sl'>"
                  << "<input type='hidden' name='id' value='" << b.tradeId << "'>"
                  << "<button class='btn-sm " << (b.stopLossActive ? "btn-warn" : "") << "'>"
                  << (b.stopLossActive ? "ON" : "OFF") << "</button></form></td>"
                  << "<td>" << sold << "</td><td>" << remaining << "</td>"
                  << "<td class='" << (realized >= 0 ? "buy" : "sell") << "'>" << realized << "</td>"
                  << "<td>"
                  << "<a class='btn btn-sm' href='/edit-trade?id=" << b.tradeId << "'>Edit</a> "
                  << "<form class='iform' method='POST' action='/delete-trade'>"
                  << "<input type='hidden' name='id' value='" << b.tradeId << "'>"
                  << "<button class='btn-sm btn-danger'>Del</button></form>"
                  << "</td></tr>";

                // ---- child rows (indented) ----
                for (const auto* cp : children)
                {
                    const Trade& c = *cp;
                    auto profit = ProfitCalculator::childProfit(c, b.value);
                    double cGross = c.value * c.quantity;
                    h << "<tr class='child-row'>"
                      << "<td><span class='child-indent'>&#9492;&#9472;</span>"
                      << "<a href='/edit-trade?id=" << c.tradeId << "'>" << c.tradeId << "</a></td>"
                      << "<td>" << html::esc(c.symbol) << "</td>"
                      << "<td class='sell'>SELL</td>"
                      << "<td>" << c.value << "</td><td>" << c.quantity << "</td>"
                      << "<td>" << cGross << "</td>"
                      << "<td>" << c.sellFee << "</td>"
                      << "<td>-</td><td>-</td><td>-</td>"
                      << "<td>-</td><td>-</td>"
                      << "<td class='" << (profit.netProfit >= 0 ? "buy" : "sell") << "'>"
                      << profit.netProfit << " (" << std::setprecision(2) << profit.roi << "%)" << std::setprecision(17) << "</td>"
                      << "<td>"
                      << "<a class='btn btn-sm' href='/edit-trade?id=" << c.tradeId << "'>Edit</a> "
                      << "<form class='iform' method='POST' action='/delete-trade'>"
                      << "<input type='hidden' name='id' value='" << c.tradeId << "'>"
                      << "<button class='btn-sm btn-danger'>Del</button></form>"
                      << "</td></tr>";
                }
            }

            // orphan sells (no valid parent)
            for (const auto* sp : orphanSells)
            {
                const Trade& s = *sp;
                double cGross = s.value * s.quantity;
                h << "<tr>"
                  << "<td>" << s.tradeId << "</td>"
                  << "<td>" << html::esc(s.symbol) << "</td>"
                  << "<td class='sell'>SELL</td>"
                  << "<td>" << s.value << "</td><td>" << s.quantity << "</td>"
                  << "<td>" << cGross << "</td>"
                  << "<td>" << s.sellFee << "</td>"
                  << "<td>-</td><td>-</td><td>-</td>"
                  << "<td>-</td><td>-</td><td>-</td>"
                  << "<td>"
                  << "<a class='btn btn-sm' href='/edit-trade?id=" << s.tradeId << "'>Edit</a> "
                  << "<form class='iform' method='POST' action='/delete-trade'>"
                  << "<input type='hidden' name='id' value='" << s.tradeId << "'>"
                  << "<button class='btn-sm btn-danger'>Del</button></form>"
                  << "</td></tr>";
            }

            h << "</table>";
        }
        h << "<div class='forms-row'>";
        h << "<form class='card' method='POST' action='/execute-buy'>"
             "<h3>Execute Buy</h3>"
             "<div style='color:#64748b;font-size:0.78em;margin-bottom:8px;'>Creates trade &amp; debits wallet</div>"
             "<label>Symbol</label><input type='text' name='symbol' required><br>"
             "<label>Price</label><input type='number' name='price' step='any' required><br>"
             "<label>Quantity</label><input type='number' name='quantity' step='any' required><br>"
             "<label>Buy Fee</label><input type='number' name='buyFee' step='any' value='0'><br>"
             "<label>Take Profit</label><input type='number' name='takeProfit' step='any' value='0'><br>"
             "<label>Stop Loss</label><input type='number' name='stopLoss' step='any' value='0'><br>"
             "<button>Execute Buy</button></form>";
        h << "<form class='card' method='POST' action='/execute-sell'>"
             "<h3>Execute Sell</h3>"
             "<div style='color:#64748b;font-size:0.78em;margin-bottom:8px;'>Deducts from symbol holdings &amp; credits wallet</div>"
             "<label>Symbol</label><input type='text' name='symbol' required><br>"
             "<label>Price</label><input type='number' name='price' step='any' required><br>"
             "<label>Quantity</label><input type='number' name='quantity' step='any' required><br>"
             "<label>Sell Fee</label><input type='number' name='sellFee' step='any' value='0'><br>"
             "<button>Execute Sell</button></form>";
        h << "<form class='card' method='POST' action='/add-trade'>"
             "<h3>Import Buy</h3>"
             "<div style='color:#64748b;font-size:0.78em;margin-bottom:8px;'>Record only &mdash; no wallet movement</div>"
             "<input type='hidden' name='type' value='Buy'>"
             "<label>Symbol</label><input type='text' name='symbol' required><br>"
             "<label>Price</label><input type='number' name='price' step='any' required><br>"
             "<label>Quantity</label><input type='number' name='quantity' step='any' required><br>"
             "<label>Buy Fee</label><input type='number' name='buyFee' step='any' value='0'><br>"
             "<label>Take Profit</label><input type='number' name='takeProfit' step='any' value='0'><br>"
             "<label>Stop Loss</label><input type='number' name='stopLoss' step='any' value='0'><br>"
             "<button>Import Buy</button></form>";
        h << "<form class='card' method='POST' action='/add-trade'>"
             "<h3>Import Sell</h3>"
             "<div style='color:#64748b;font-size:0.78em;margin-bottom:8px;'>Record only &mdash; no wallet movement</div>"
             "<input type='hidden' name='type' value='CoveredSell'>"
             "<label>Symbol</label><input type='text' name='symbol' required><br>"
             "<label>Parent Buy ID</label><input type='number' name='parentTradeId' required><br>"
             "<label>Price</label><input type='number' name='price' step='any' required><br>"
             "<label>Quantity</label><input type='number' name='quantity' step='any' required><br>"
             "<label>Sell Fee</label><input type='number' name='sellFee' step='any' value='0'><br>"
             "<button>Import Sell</button></form>";
        h << "</div>";
        res.set_content(html::wrap("Trades", h.str()), "text/html");
    });

    // ========== POST /add-trade ==========
    svr.Post("/add-trade", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        if (!ctx.canAddTrade(req))
        {
            res.set_redirect("/trades?err=Trade+limit+reached.+Upgrade+to+Premium+for+unlimited+trades.", 303);
            return;
        }
        auto f = parseForm(req.body);
        Trade t;
        t.tradeId = db.nextTradeId();
        t.symbol = normalizeSymbol(fv(f, "symbol"));
        t.type = (fv(f, "type") == "CoveredSell") ? TradeType::CoveredSell : TradeType::Buy;
        t.value = fd(f, "price");
        t.quantity = fd(f, "quantity");
        t.stopLossActive = false;
        t.shortEnabled = false;
        if (t.value <= 0 || t.quantity <= 0) { res.set_redirect("/trades?err=Price+and+quantity+must+be+positive", 303); return; }
        if (t.type == TradeType::Buy)
        {
            t.parentTradeId = -1;
            t.buyFee = fd(f, "buyFee");
            t.sellFee = 0.0;
            t.takeProfit = fd(f, "takeProfit");
            t.stopLoss = fd(f, "stopLoss");
        }
        else
        {
            t.parentTradeId = fi(f, "parentTradeId", -1);
            auto trades = db.loadTrades();
            auto* parent = db.findTradeById(trades, t.parentTradeId);
            if (!parent || parent->type != TradeType::Buy)
            {
                res.set_redirect("/trades?err=Parent+must+be+an+existing+Buy+trade", 303);
                return;
            }
            t.buyFee = 0.0;
            t.sellFee = fd(f, "sellFee");
        }
        db.addTrade(t);
        res.set_redirect("/trades?msg=Trade+" + std::to_string(t.tradeId) + "+created", 303);
    });

    // ========== POST /delete-trade ==========
    svr.Post("/delete-trade", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        int id = fi(f, "id");
        auto trades = db.loadTrades();
        if (!db.findTradeById(trades, id)) { res.set_redirect("/trades?err=Trade+not+found", 303); return; }
        db.removeTrade(id);
        res.set_redirect("/trades?msg=Trade+" + std::to_string(id) + "+deleted", 303);
    });

    // ========== POST /toggle-sl ==========
    svr.Post("/toggle-sl", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        int id = fi(f, "id");
        auto trades = db.loadTrades();
        auto* tp = db.findTradeById(trades, id);
        if (!tp) { res.set_redirect("/trades?err=Trade+not+found", 303); return; }
        tp->stopLossActive = !tp->stopLossActive;
        db.updateTrade(*tp);
        std::string state = tp->stopLossActive ? "ON" : "OFF";
        res.set_redirect("/trades?msg=SL+now+" + state + "+for+" + std::to_string(id), 303);
    });

    // ========== POST /set-tp ==========
    svr.Post("/set-tp", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        int id = fi(f, "id");
        auto trades = db.loadTrades();
        auto* t = db.findTradeById(trades, id);
        if (!t) { res.set_redirect("/trades?err=Trade+not+found", 303); return; }
        t->takeProfit = fd(f, "tp");
        db.updateTrade(*t);
        res.set_redirect("/trades?msg=TP+set+to+" + fv(f, "tp") + "+for+" + std::to_string(id), 303);
    });

    // ========== POST /set-sl ==========
    svr.Post("/set-sl", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        int id = fi(f, "id");
        auto trades = db.loadTrades();
        auto* t = db.findTradeById(trades, id);
        if (!t) { res.set_redirect("/trades?err=Trade+not+found", 303); return; }
        t->stopLoss = fd(f, "sl");
        if (t->stopLoss > 0 && !t->stopLossActive)
            t->stopLossActive = true;
        db.updateTrade(*t);
        res.set_redirect("/trades?msg=SL+set+to+" + fv(f, "sl") + "+for+" + std::to_string(id), 303);
    });

    // ========== POST /execute-buy ==========
    svr.Post("/execute-buy", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        if (!ctx.canAddTrade(req))
        {
            res.set_redirect("/trades?err=Trade+limit+reached.+Upgrade+to+Premium+for+unlimited+trades.", 303);
            return;
        }
        auto f = parseForm(req.body);
        std::string sym = normalizeSymbol(fv(f, "symbol"));
        double price = fd(f, "price");
        double qty = fd(f, "quantity");
        double fee = fd(f, "buyFee");
        double tp = fd(f, "takeProfit");
        double sl = fd(f, "stopLoss");
        if (sym.empty() || price <= 0 || qty <= 0) { res.set_redirect("/trades?err=Invalid+buy+parameters", 303); return; }
        double walBal = db.loadWalletBalance();
        double needed = price * qty + fee;
        if (needed > walBal) { res.set_redirect("/trades?err=Insufficient+funds", 303); return; }
        int bid = db.executeBuy(sym, price, qty, fee, tp, sl);
        res.set_redirect("/trades?msg=Buy+" + std::to_string(bid) + "+executed", 303);
    });

    // ========== POST /execute-sell ==========
    svr.Post("/execute-sell", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        if (!ctx.canAddTrade(req))
        {
            res.set_redirect("/trades?err=Trade+limit+reached.+Upgrade+to+Premium+for+unlimited+trades.", 303);
            return;
        }
        auto f = parseForm(req.body);
        std::string sym = normalizeSymbol(fv(f, "symbol"));
        double price = fd(f, "price");
        double qty = fd(f, "quantity");
        double fee = fd(f, "sellFee");
        if (sym.empty() || price <= 0 || qty <= 0) { res.set_redirect("/trades?err=Invalid+sell+parameters", 303); return; }
        int sid = db.executeSell(sym, price, qty, fee);
        if (sid < 0) { res.set_redirect("/trades?err=Sell+failed+(insufficient+holdings)", 303); return; }
        res.set_redirect("/trades?msg=Sell+" + std::to_string(sid) + "+executed", 303);
    });

    // ========== GET /edit-trade ==========
    svr.Get("/edit-trade", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        std::ostringstream h;
        h << std::fixed << std::setprecision(17);
        h << html::msgBanner(req) << html::errBanner(req);
        int id = 0;
        try { id = std::stoi(req.get_param_value("id")); } catch (...) {}
        auto trades = db.loadTrades();
        auto* tp = db.findTradeById(trades, id);
        if (!tp) { h << "<h1>Edit Trade</h1><div class='msg err'>Trade not found</div>"; }
        else
        {
            bool isBuy = (tp->type == TradeType::Buy);
            h << "<h1>Edit Trade #" << tp->tradeId << "</h1>"
                 "<form class='card' method='POST' action='/edit-trade'>"
                 "<input type='hidden' name='id' value='" << tp->tradeId << "'>"
                 "<label>Symbol</label><input type='text' name='symbol' value='" << html::esc(tp->symbol) << "'><br>"
                 "<label>Type</label><select name='type'>"
                 "<option value='Buy'" << (isBuy ? " selected" : "") << ">Buy</option>"
                 "<option value='CoveredSell'" << (!isBuy ? " selected" : "") << ">CoveredSell</option>"
                 "</select><br>"
                 "<label>Price</label><input type='number' name='price' step='any' value='" << tp->value << "'><br>"
                 "<label>Quantity</label><input type='number' name='quantity' step='any' value='" << tp->quantity << "'><br>"
                 "<label>Parent Buy ID</label><input type='number' name='parentTradeId' value='" << tp->parentTradeId << "'>"
                 "<div style='color:#64748b;font-size:0.78em;'>-1 = none (for Buy trades)</div><br>"
                 "<label>Buy Fee</label><input type='number' name='buyFee' step='any' value='" << tp->buyFee << "'><br>"
                 "<label>Sell Fee</label><input type='number' name='sellFee' step='any' value='" << tp->sellFee << "'><br>"
                 "<label>Take Profit</label><input type='number' name='takeProfit' step='any' value='" << tp->takeProfit << "'><br>"
                 "<label>Stop Loss</label><input type='number' name='stopLoss' step='any' value='" << tp->stopLoss << "'><br>"
                 "<label>SL Active</label><select name='stopLossActive'>"
                 "<option value='0'" << (!tp->stopLossActive ? " selected" : "") << ">OFF</option>"
                 "<option value='1'" << (tp->stopLossActive ? " selected" : "") << ">ON</option>"
                 "</select><br>"
                 "<br><button>Save Changes</button></form>";
        }
        h << "<br><a class='btn' href='/trades'>Back to Trades</a>";
        res.set_content(html::wrap("Edit Trade", h.str()), "text/html");
    });

    // ========== POST /edit-trade ==========
    svr.Post("/edit-trade", [&](const httplib::Request& req, httplib::Response& res) {
        std::lock_guard<std::mutex> lk(dbMutex);
        auto f = parseForm(req.body);
        int id = fi(f, "id");
        auto trades = db.loadTrades();
        auto* tp = db.findTradeById(trades, id);
        if (!tp) { res.set_redirect("/trades?err=Trade+not+found", 303); return; }
        auto sym = fv(f, "symbol");
        if (!sym.empty()) tp->symbol = normalizeSymbol(sym);
        auto typeStr = fv(f, "type");
        if (!typeStr.empty()) tp->type = (typeStr == "CoveredSell") ? TradeType::CoveredSell : TradeType::Buy;
        double price = fd(f, "price");
        if (price > 0) tp->value = price;
        double qty = fd(f, "quantity");
        if (qty > 0) tp->quantity = qty;
        int pid = fi(f, "parentTradeId", tp->parentTradeId);
        if (tp->type == TradeType::Buy)
        {
            tp->parentTradeId = -1;
        }
        else
        {
            if (pid >= 0)
            {
                auto* parent = db.findTradeById(trades, pid);
                if (!parent || parent->type != TradeType::Buy)
                {
                    res.set_redirect("/trades?err=Parent+must+be+an+existing+Buy+trade", 303);
                    return;
                }
            }
            tp->parentTradeId = pid;
        }
        tp->buyFee = fd(f, "buyFee", tp->buyFee);
        tp->sellFee = fd(f, "sellFee", tp->sellFee);
        tp->takeProfit = fd(f, "takeProfit", tp->takeProfit);
        tp->stopLoss = fd(f, "stopLoss", tp->stopLoss);
        auto slStr = fv(f, "stopLossActive");
        if (!slStr.empty()) tp->stopLossActive = (slStr == "1");
        db.updateTrade(*tp);
        res.set_redirect("/trades?msg=Trade+" + std::to_string(id) + "+updated", 303);
    });
}
===== Trade.h ===== 
#pragma once

#include <string>
#include <stdexcept>
#include <algorithm>
#include <cctype>

enum class TradeType
{
    Buy,
    CoveredSell   // asset-backed sell only, no short trades
};

inline std::string normalizeSymbol(std::string s)
{
    std::transform(s.begin(), s.end(), s.begin(),
                   [](unsigned char c) { return std::toupper(c); });
    return s;
}

struct Trade
{
    std::string symbol;
    int         tradeId       = 0;
    TradeType   type          = TradeType::Buy;
    double      value         = 0.0;   // entry price per unit
    double      quantity      = 0.0;
    int         parentTradeId = -1;    // -1 = no parent (Buy); >= 0 = parent Buy trade id (CoveredSell)

    // Fees paid at execution
    double buyFee          = 0.0;
    double sellFee         = 0.0;
    //
    // Take-profit / stop-loss (meaningful for Buy trades only)
    double takeProfit      = 0.0;
    double stopLoss        = 0.0;
    bool   stopLossActive  = false;   // deactivated by default
    bool   shortEnabled    = false;   // short trades disabled by default

    Trade() = default;

    bool isChild()  const { return parentTradeId >= 0; }
    bool isParent() const { return type == TradeType::Buy && parentTradeId < 0; }

    void setTakeProfit(double tp)
    {
        if (type != TradeType::Buy)
            throw std::logic_error("Take-profit is only supported for Buy trades");
        takeProfit = tp;
    }

    void setStopLoss(double sl, bool active = false)
    {
        if (type != TradeType::Buy)
            throw std::logic_error("Stop-loss is only supported for Buy trades");
        stopLoss       = sl;
        stopLossActive = active;
    }
};
===== TradeDatabase.h ===== 
ï»¿#pragma once

#include "Trade.h"
#include "MultiHorizonEngine.h"
#include "ProfitCalculator.h"

#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <filesystem>
#include <stdexcept>
#include <iomanip>
#include <algorithm>
#include <chrono>
#include <ctime>

class TradeDatabase
{
public:
    explicit TradeDatabase(const std::string& directory = "db")
        : m_dir(directory)
    {
        std::filesystem::create_directories(m_dir);
    }

    // ---- Trades ----

    void saveTrades(const std::vector<Trade>& trades)
    {
        std::ofstream f(tradesPath(), std::ios::trunc);
        if (!f) throw std::runtime_error("Cannot open " + tradesPath());

        for (const auto& t : trades)
        {
            f << t.symbol       << ','
              << t.tradeId      << ','
              << static_cast<int>(t.type) << ','
              << std::fixed << std::setprecision(17)
              << t.value        << ','
              << t.quantity     << ','
              << t.parentTradeId << ','
              << t.takeProfit   << ','
              << t.stopLoss     << ','
              << t.stopLossActive << ','
              << t.shortEnabled  << ','
              << t.buyFee        << ','
              << t.sellFee
              << '\n';
        }
    }

    void addTrade(const Trade& t)
    {
        auto all = loadTrades();
        all.push_back(t);
        saveTrades(all);
    }

    void removeTrade(int tradeId)
    {
        auto all = loadTrades();

        // cascade: if this is a parent Buy, also remove its CoveredSell children
        std::vector<int> idsToRemove = { tradeId };
        for (const auto& t : all)
            if (t.parentTradeId == tradeId)
                idsToRemove.push_back(t.tradeId);

        std::erase_if(all, [&](const Trade& t) {
            return std::find(idsToRemove.begin(), idsToRemove.end(), t.tradeId) != idsToRemove.end();
        });
        saveTrades(all);

        auto hl = loadAllHorizons();
        std::erase_if(hl, [&](const std::tuple<std::string, int, HorizonLevel>& e) {
            return std::find(idsToRemove.begin(), idsToRemove.end(), std::get<1>(e)) != idsToRemove.end();
        });
        saveAllHorizons(hl);
    }

    void updateTrade(const Trade& updated)
    {
        auto all = loadTrades();
        for (auto& t : all)
        {
            if (t.tradeId == updated.tradeId)
            {
                t = updated;
                break;
            }
        }
        saveTrades(all);
    }

    std::vector<Trade> loadTrades() const
    {
        std::vector<Trade> out;
        std::ifstream f(tradesPath());
        if (!f) return out;

        std::string line;
        while (std::getline(f, line))
        {
            if (line.empty()) continue;
            std::istringstream ss(line);
            std::string tok;
            Trade t;

            std::getline(ss, t.symbol, ',');
            std::getline(ss, tok, ','); t.tradeId       = std::stoi(tok);
            std::getline(ss, tok, ','); t.type           = static_cast<TradeType>(std::stoi(tok));
            std::getline(ss, tok, ','); t.value          = std::stod(tok);
            std::getline(ss, tok, ','); t.quantity       = std::stod(tok);
            std::getline(ss, tok, ','); t.parentTradeId  = std::stoi(tok);
            std::getline(ss, tok, ','); t.takeProfit     = std::stod(tok);
            std::getline(ss, tok, ','); t.stopLoss       = std::stod(tok);
            std::getline(ss, tok, ','); t.stopLossActive = (std::stoi(tok) != 0);
            std::getline(ss, tok, ','); t.shortEnabled   = (std::stoi(tok) != 0);
            if (std::getline(ss, tok, ',') && !tok.empty()) { try { t.buyFee  = std::stod(tok); } catch (...) {} }
            if (std::getline(ss, tok, ',') && !tok.empty()) { try { t.sellFee = std::stod(tok); } catch (...) {} }

            out.push_back(t);
        }
        return out;
    }

    Trade* findTrade(std::vector<Trade>& trades,
                     const std::string& symbol, int tradeId) const
    {
        for (auto& t : trades)
            if (t.symbol == symbol && t.tradeId == tradeId)
                return &t;
        return nullptr;
    }

    Trade* findTradeById(std::vector<Trade>& trades, int tradeId) const
    {
        for (auto& t : trades)
            if (t.tradeId == tradeId)
                return &t;
        return nullptr;
    }

    double soldQuantityForParent(int parentId) const
    {
        double sold = 0.0;
        for (const auto& t : loadTrades())
            if (t.type == TradeType::CoveredSell && t.parentTradeId == parentId)
                sold += t.quantity;
        return sold;
    }

    int nextTradeId() const
    {
        auto all = loadTrades();
        int maxId = 0;
        for (const auto& t : all)
            if (t.tradeId > maxId) maxId = t.tradeId;
        return maxId + 1;
    }

    // ---- Horizon Levels ----

    void saveHorizonLevels(const std::string& symbol, int tradeId,
                           const std::vector<HorizonLevel>& levels)
    {
        auto all = loadAllHorizons();
        std::erase_if(all, [&](const std::tuple<std::string, int, HorizonLevel>& e) {
            return std::get<0>(e) == symbol && std::get<1>(e) == tradeId;
        });
        for (const auto& lv : levels)
            all.emplace_back(symbol, tradeId, lv);
        saveAllHorizons(all);
    }

    std::vector<HorizonLevel> loadHorizonLevels(const std::string& symbol,
                                                 int tradeId) const
    {
        std::vector<HorizonLevel> out;
        for (const auto& [sym, tid, lv] : loadAllHorizons())
            if (sym == symbol && tid == tradeId)
                out.push_back(lv);
        return out;
    }

    // ---- Profit Snapshots ----

    void saveProfitSnapshot(const std::string& symbol, int tradeId,
                            double currentPrice, const ProfitResult& r)
    {
        std::ofstream f(profitsPath(), std::ios::app);
        if (!f) throw std::runtime_error("Cannot open " + profitsPath());

        f << symbol       << ','
          << tradeId      << ','
          << std::fixed << std::setprecision(17)
          << currentPrice << ','
          << r.grossProfit << ','
          << r.netProfit   << ','
          << r.roi
          << '\n';
    }

    struct ProfitRow
    {
        std::string symbol;
        int    tradeId      = 0;
        double currentPrice = 0.0;
        double grossProfit  = 0.0;
        double netProfit    = 0.0;
        double roi          = 0.0;
    };

    std::vector<ProfitRow> loadProfitHistory() const
    {
        std::vector<ProfitRow> out;
        std::ifstream f(profitsPath());
        if (!f) return out;

        std::string line;
        while (std::getline(f, line))
        {
            if (line.empty()) continue;
            std::istringstream ss(line);
            std::string tok;
            ProfitRow r;
            std::getline(ss, r.symbol, ',');
            std::getline(ss, tok, ','); r.tradeId      = std::stoi(tok);
            std::getline(ss, tok, ','); r.currentPrice = std::stod(tok);
            std::getline(ss, tok, ','); r.grossProfit  = std::stod(tok);
            std::getline(ss, tok, ','); r.netProfit    = std::stod(tok);
            std::getline(ss, tok, ','); r.roi          = std::stod(tok);
            out.push_back(r);
        }
        return out;
    }

    // ---- Parameter Snapshots ----

    struct ParamsRow
    {
        std::string calcType;     // "horizon", "entry", or "exit"
        std::string symbol;
        int    tradeId                    = -1;
        double currentPrice               = 0.0;
        double quantity                   = 0.0;
        double buyFees                    = 0.0;
        double sellFees                   = 0.0;
        double feeHedgingCoefficient      = 0.0;
        double portfolioPump              = 0.0;
        int    symbolCount                = 0;
        double coefficientK               = 0.0;
        double feeSpread                  = 0.0;
        double deltaTime                  = 0.0;
        double surplusRate                = 0.0;
        int    horizonCount               = 0;
        bool   generateStopLosses         = false;
        double riskCoefficient            = 0.0;
        double maxRisk                    = 0.0;
        double minRisk                    = 0.0;

        static ParamsRow from(const std::string& type, const std::string& sym,
                              int tid, double price, double qty,
                              const HorizonParams& p, double risk = 0.0,
                              double buyFees = 0.0, double sellFees = 0.0)
        {
            ParamsRow r;
            r.calcType              = type;
            r.symbol                = sym;
            r.tradeId               = tid;
            r.currentPrice          = price;
            r.quantity              = qty;
            r.buyFees               = buyFees;
            r.sellFees              = sellFees;
            r.feeHedgingCoefficient = p.feeHedgingCoefficient;
            r.portfolioPump         = p.portfolioPump;
            r.symbolCount           = p.symbolCount;
            r.coefficientK          = p.coefficientK;
            r.feeSpread             = p.feeSpread;
            r.deltaTime             = p.deltaTime;
            r.surplusRate           = p.surplusRate;
            r.horizonCount          = p.horizonCount;
            r.generateStopLosses    = p.generateStopLosses;
            r.riskCoefficient       = risk;
            r.maxRisk               = p.maxRisk;
            r.minRisk               = p.minRisk;
            return r;
        }

        HorizonParams toHorizonParams() const
        {
            HorizonParams p;
            p.feeHedgingCoefficient = feeHedgingCoefficient;
            p.portfolioPump         = portfolioPump;
            p.symbolCount           = symbolCount;
            p.coefficientK          = coefficientK;
            p.feeSpread             = feeSpread;
            p.deltaTime             = deltaTime;
            p.surplusRate           = surplusRate;
            p.horizonCount          = horizonCount;
            p.generateStopLosses    = generateStopLosses;
            p.maxRisk               = maxRisk;
            p.minRisk               = minRisk;
            return p;
        }
    };

    void saveParamsSnapshot(const ParamsRow& r)
    {
        std::ofstream f(paramsPath(), std::ios::app);
        if (!f) throw std::runtime_error("Cannot open " + paramsPath());

        f << r.calcType     << ','
          << r.symbol       << ','
          << r.tradeId      << ','
          << std::fixed << std::setprecision(17)
          << r.currentPrice << ','
          << r.quantity     << ','
          << r.buyFees      << ','
          << r.sellFees     << ','
          << r.feeHedgingCoefficient << ','
          << r.portfolioPump << ','
          << r.symbolCount  << ','
          << r.coefficientK << ','
          << r.feeSpread    << ','
          << r.deltaTime    << ','
          << r.surplusRate  << ','
          << r.horizonCount << ','
          << r.generateStopLosses << ','
          << r.riskCoefficient << ','
          << r.maxRisk << ','
          << r.minRisk
          << '\n';
    }

    std::vector<ParamsRow> loadParamsHistory() const
    {
        std::vector<ParamsRow> out;
        std::ifstream f(paramsPath());
        if (!f) return out;

        std::string line;
        while (std::getline(f, line))
        {
            if (line.empty()) continue;
            std::istringstream ss(line);
            std::string tok;
            ParamsRow r;

            std::getline(ss, r.calcType, ',');
            std::getline(ss, r.symbol, ',');
            std::getline(ss, tok, ','); r.tradeId                    = std::stoi(tok);
            std::getline(ss, tok, ','); r.currentPrice               = std::stod(tok);
            std::getline(ss, tok, ','); r.quantity                   = std::stod(tok);
            std::getline(ss, tok, ','); r.buyFees                    = std::stod(tok);
            std::getline(ss, tok, ','); r.sellFees                   = std::stod(tok);
            std::getline(ss, tok, ','); r.feeHedgingCoefficient      = std::stod(tok);
            std::getline(ss, tok, ','); r.portfolioPump              = std::stod(tok);
            std::getline(ss, tok, ','); r.symbolCount                = std::stoi(tok);
            std::getline(ss, tok, ','); r.coefficientK               = std::stod(tok);
            std::getline(ss, tok, ','); r.feeSpread                  = std::stod(tok);
            std::getline(ss, tok, ','); r.deltaTime                  = std::stod(tok);
            std::getline(ss, tok, ','); r.surplusRate                = std::stod(tok);
            std::getline(ss, tok, ','); r.horizonCount               = std::stoi(tok);
            std::getline(ss, tok, ','); r.generateStopLosses         = (std::stoi(tok) != 0);
            std::getline(ss, tok, ','); r.riskCoefficient            = std::stod(tok);
            if (std::getline(ss, tok, ',') && !tok.empty())
                r.maxRisk = std::stod(tok);
            if (std::getline(ss, tok, ',') && !tok.empty())
                r.minRisk = std::stod(tok);

            out.push_back(r);
        }
        return out;
    }

    // ---- Pending Exits ----

    struct PendingExit
    {
        std::string symbol;
        int    orderId       = 0;
        int    tradeId       = 0;    // parent Buy trade
        double triggerPrice  = 0.0;  // market price must reach this to trigger
        double sellQty       = 0.0;  // quantity to sell when triggered
        int    levelIndex    = 0;
    };

    void savePendingExits(const std::vector<PendingExit>& orders)
    {
        std::ofstream f(pendingExitsPath(), std::ios::trunc);
        if (!f) throw std::runtime_error("Cannot open " + pendingExitsPath());
        for (const auto& o : orders)
        {
            f << o.symbol      << ','
              << o.orderId     << ','
              << o.tradeId     << ','
              << std::fixed << std::setprecision(17)
              << o.triggerPrice << ','
              << o.sellQty     << ','
              << o.levelIndex  << '\n';
        }
    }

    std::vector<PendingExit> loadPendingExits() const
    {
        std::vector<PendingExit> out;
        std::ifstream f(pendingExitsPath());
        if (!f) return out;
        std::string line;
        while (std::getline(f, line))
        {
            if (line.empty()) continue;
            std::istringstream ss(line);
            std::string tok;
            PendingExit o;
            std::getline(ss, o.symbol, ',');
            std::getline(ss, tok, ','); o.orderId      = std::stoi(tok);
            std::getline(ss, tok, ','); o.tradeId      = std::stoi(tok);
            std::getline(ss, tok, ','); o.triggerPrice  = std::stod(tok);
            std::getline(ss, tok, ','); o.sellQty       = std::stod(tok);
            std::getline(ss, tok, ','); o.levelIndex    = std::stoi(tok);
            out.push_back(o);
        }
        return out;
    }

    void addPendingExits(const std::vector<PendingExit>& orders)
    {
        auto all = loadPendingExits();
        for (const auto& o : orders) all.push_back(o);
        savePendingExits(all);
    }

    void removePendingExit(int orderId)
    {
        auto all = loadPendingExits();
        std::erase_if(all, [orderId](const PendingExit& o) { return o.orderId == orderId; });
        savePendingExits(all);
    }

    int nextPendingId() const
    {
        int maxId = 0;
        for (const auto& o : loadPendingExits())
            if (o.orderId > maxId) maxId = o.orderId;
        return maxId + 1;
    }

    // ---- Entry Points ----

    struct EntryPoint
    {
        std::string symbol;
        int    entryId            = 0;
        int    levelIndex         = 0;
        double entryPrice         = 0.0;
        double breakEven          = 0.0;
        double funding            = 0.0;
        double fundingQty         = 0.0;
        double effectiveOverhead  = 0.0;
        bool   isShort            = false;
        bool   traded             = false;
        int    linkedTradeId      = -1;
        double exitTakeProfit     = 0.0;   // per-unit TP price
        double exitStopLoss       = 0.0;   // per-unit SL price
        bool   stopLossActive     = false;
    };

    void saveEntryPoints(const std::vector<EntryPoint>& points)
    {
        std::ofstream f(entryPointsPath(), std::ios::trunc);
        if (!f) throw std::runtime_error("Cannot open " + entryPointsPath());
        for (const auto& ep : points)
        {
            f << ep.symbol             << ','
              << ep.entryId            << ','
              << ep.levelIndex         << ','
              << std::fixed << std::setprecision(17)
              << ep.entryPrice         << ','
              << ep.breakEven          << ','
              << ep.funding            << ','
              << ep.fundingQty         << ','
              << ep.effectiveOverhead  << ','
              << ep.isShort            << ','
              << ep.traded             << ','
              << ep.linkedTradeId      << ','
              << ep.exitTakeProfit     << ','
              << ep.exitStopLoss       << ','
              << ep.stopLossActive
              << '\n';
        }
    }

    std::vector<EntryPoint> loadEntryPoints() const
    {
        std::vector<EntryPoint> out;
        std::ifstream f(entryPointsPath());
        if (!f) return out;
        std::string line;
        while (std::getline(f, line))
        {
            if (line.empty()) continue;
            std::istringstream ss(line);
            std::string tok;
            EntryPoint ep;
            std::getline(ss, ep.symbol, ',');
            std::getline(ss, tok, ','); ep.entryId           = std::stoi(tok);
            std::getline(ss, tok, ','); ep.levelIndex        = std::stoi(tok);
            std::getline(ss, tok, ','); ep.entryPrice        = std::stod(tok);
            std::getline(ss, tok, ','); ep.breakEven         = std::stod(tok);
            std::getline(ss, tok, ','); ep.funding           = std::stod(tok);
            std::getline(ss, tok, ','); ep.fundingQty        = std::stod(tok);
            std::getline(ss, tok, ','); ep.effectiveOverhead = std::stod(tok);
            std::getline(ss, tok, ','); ep.isShort           = (std::stoi(tok) != 0);
            std::getline(ss, tok, ','); ep.traded            = (std::stoi(tok) != 0);
            std::getline(ss, tok, ','); ep.linkedTradeId     = std::stoi(tok);
            std::getline(ss, tok, ','); ep.exitTakeProfit    = std::stod(tok);
            std::getline(ss, tok, ','); ep.exitStopLoss      = std::stod(tok);
            std::getline(ss, tok, ','); ep.stopLossActive    = (std::stoi(tok) != 0);
            out.push_back(ep);
        }
        return out;
    }

    int nextEntryId() const
    {
        int maxId = 0;
        for (const auto& ep : loadEntryPoints())
            if (ep.entryId > maxId) maxId = ep.entryId;
        return maxId + 1;
    }

    // ---- Wallet ----

    double loadWalletBalance() const
    {
        std::ifstream f(walletPath());
        if (!f) return 0.0;
        double bal = 0.0;
        f >> bal;
        return bal;
    }

    void saveWalletBalance(double balance)
    {
        std::ofstream f(walletPath(), std::ios::trunc);
        if (!f) throw std::runtime_error("Cannot open " + walletPath());
        f << std::fixed << std::setprecision(17) << balance << '\n';
    }

    void deposit(double amount)
    {
        saveWalletBalance(loadWalletBalance() + amount);
    }

    void withdraw(double amount)
    {
        saveWalletBalance(loadWalletBalance() - amount);
    }

    double deployedCapital() const
    {
        double deployed = 0.0;
        for (const auto& t : loadTrades())
        {
            if (t.type != TradeType::Buy) continue;
            double sold = soldQuantityForParent(t.tradeId);
            double released = releasedForTrade(t.tradeId);
            double remaining = t.quantity - sold - released;
            if (remaining <= 0) continue;
            double remainFrac = t.quantity > 0 ? remaining / t.quantity : 0.0;
            deployed += t.value * remaining + t.buyFee * remainFrac;
        }
        return deployed;
    }

    // ---- Released Holdings ----

    double releasedForTrade(int tradeId) const
    {
        double total = 0.0;
        std::ifstream f(releasedPath());
        if (!f) return 0.0;
        std::string line;
        while (std::getline(f, line))
        {
            if (line.empty()) continue;
            std::istringstream ss(line);
            std::string tok;
            int tid = 0;
            double qty = 0;
            std::getline(ss, tok, ',');
            std::getline(ss, tok, ','); try { tid = std::stoi(tok); } catch (...) { continue; }
            std::getline(ss, tok, ','); try { qty = std::stod(tok); } catch (...) { continue; }
            if (tid == tradeId) total += qty;
        }
        return total;
    }

    bool releaseFromTrade(int tradeId, double qty)
    {
        auto trades = loadTrades();
        auto* t = findTradeById(trades, tradeId);
        if (!t || t->type != TradeType::Buy) return false;

        double sold = soldQuantityForParent(tradeId);
        double released = releasedForTrade(tradeId);
        double allocated = t->quantity - sold - released;
        if (qty > allocated + 1e-9) return false;
        if (qty > allocated) qty = allocated;

        std::ofstream f(releasedPath(), std::ios::app);
        if (!f) return false;
        f << t->symbol << ',' << tradeId << ','
          << std::fixed << std::setprecision(17) << qty << '\n';
        return true;
    }

    bool hasBuyTrades() const
    {
        for (const auto& t : loadTrades())
            if (t.type == TradeType::Buy) return true;
        return false;
    }

    bool hasAnyHorizons() const
    {
        return !loadAllHorizons().empty();
    }

    // Compute net holdings for a symbol (total bought - total sold).
    double holdingsForSymbol(const std::string& symbol) const
    {
        double holdings = 0.0;
        for (const auto& t : loadTrades())
        {
            if (t.symbol != symbol) continue;
            if (t.type == TradeType::Buy)
                holdings += t.quantity;
            else
                holdings -= t.quantity;
        }
        return holdings;
    }

    // Execute a sell: deduct from the symbol's holdings, credit wallet with (proceeds - sellFee).
    // Returns the new trade ID, or -1 if validation fails.
    int executeSell(const std::string& symbol, double sellPrice, double sellQty, double sellFee = 0.0)
    {
        if (symbol.empty()) return -1;

        double remaining = holdingsForSymbol(symbol);
        if (sellQty > remaining + 1e-9) return -1;
        if (sellQty > remaining) sellQty = remaining;

        Trade sell;
        sell.tradeId       = nextTradeId();
        sell.symbol        = symbol;
        sell.type          = TradeType::CoveredSell;
        sell.value         = sellPrice;
        sell.quantity      = sellQty;
        sell.parentTradeId = -1;
        sell.sellFee       = sellFee;
        addTrade(sell);

        double proceeds = sellPrice * sellQty - sellFee;
        deposit(proceeds);

        return sell.tradeId;
    }

    // Per-trade sell: validates against a specific parent Buy trade's remaining qty
    // instead of global holdings. Avoids floating-point issues with extreme quantities.
    int executeSellForTrade(const std::string& symbol, double sellPrice, double sellQty,
                           double sellFee, int parentTradeId)
    {
        if (symbol.empty()) return -1;

        auto trades = loadTrades();
        Trade* parent = nullptr;
        for (auto& t : trades)
            if (t.tradeId == parentTradeId) { parent = &t; break; }
        if (!parent || parent->type != TradeType::Buy || parent->symbol != symbol)
            return -1;

        double sold = soldQuantityForParent(parentTradeId);
        double remaining = parent->quantity - sold;
        if (sellQty > remaining + 1e-9) return -1;
        if (sellQty > remaining) sellQty = remaining;

        Trade sell;
        sell.tradeId       = nextTradeId();
        sell.symbol        = symbol;
        sell.type          = TradeType::CoveredSell;
        sell.value         = sellPrice;
        sell.quantity      = sellQty;
        sell.parentTradeId = parentTradeId;
        sell.sellFee       = sellFee;
        addTrade(sell);

        double proceeds = sellPrice * sellQty - sellFee;
        deposit(proceeds);

        // record realized P&L
        double gp = (sellPrice - parent->value) * sellQty;
        double np = gp - sellFee;
        recordPnl(symbol, sell.tradeId, parentTradeId,
                  parent->value, sellPrice, sellQty, gp, np);

        return sell.tradeId;
    }

    // Execute a buy: create a Buy trade, debit wallet for (cost + buyFee).
    // Returns the new trade ID.
    int executeBuy(const std::string& symbol, double price, double qty, double buyFee = 0.0,
                   double takeProfit = 0.0, double stopLoss = 0.0)
    {
        Trade buy;
        buy.tradeId    = nextTradeId();
        buy.symbol     = symbol;
        buy.type       = TradeType::Buy;
        buy.value      = price;
        buy.quantity   = qty;
        buy.buyFee     = buyFee;
        buy.takeProfit = takeProfit;
        buy.stopLoss   = stopLoss;
        addTrade(buy);

        double cost = price * qty + buyFee;
        withdraw(cost);

        return buy.tradeId;
    }

    // ---- Housekeeping ----

    void exportHtmlReport(const std::string& path) const
    {
        std::ofstream f(path, std::ios::trunc);
        if (!f) throw std::runtime_error("Cannot open " + path);

        f << std::fixed << std::setprecision(17);

        f << R"(<!DOCTYPE html>
<html><head><meta charset="utf-8"><title>Quant Trade Report</title>
<style>
body{font-family:monospace;background:#0b1426;color:#cbd5e1;padding:20px}
h1{color:#c9a44a}h2{color:#7b97c4;border-bottom:1px solid #1a2744;padding-bottom:4px}
table{border-collapse:collapse;margin:10px 0;width:100%}
th,td{border:1px solid #1a2744;padding:6px 10px;text-align:right}
th{background:#0f1b2d;color:#c9a44a}
tr:nth-child(even){background:#0f1b2d}
.buy{color:#22c55e}.sell{color:#ef4444}.pos{color:#22c55e}.neg{color:#ef4444}
.wallet{background:#0f1b2d;padding:12px;border-radius:6px;margin:10px 0;display:inline-block}
</style></head><body>
<h1>Quant Trade Report</h1>
)";

        // Wallet
        double wb = loadWalletBalance();
        double dc = deployedCapital();
        f << "<h2>Wallet</h2><div class='wallet'>"
          << "Liquid: <b>" << wb << "</b> &nbsp; "
          << "Deployed: <b>" << dc << "</b> &nbsp; "
          << "Total: <b>" << (wb + dc) << "</b></div>\n";

        // Trades
        auto trades = loadTrades();
        f << "<h2>Trades</h2>\n";
        if (trades.empty()) { f << "<p>(none)</p>\n"; }
        else
        {
            f << "<table><tr><th>ID</th><th>Symbol</th><th>Type</th>"
              << "<th>Price</th><th>Qty</th><th>Parent</th>"
              << "<th>Buy Fee</th><th>Sell Fee</th>"
              << "<th>TP</th><th>SL</th><th>SL Active</th></tr>\n";
            for (const auto& t : trades)
            {
                f << "<tr><td>" << t.tradeId << "</td>"
                  << "<td>" << t.symbol << "</td>"
                  << "<td class='" << (t.type == TradeType::Buy ? "buy" : "sell") << "'>"
                  << (t.type == TradeType::Buy ? "BUY" : "COVERED_SELL") << "</td>"
                  << "<td>" << t.value << "</td>"
                  << "<td>" << t.quantity << "</td>"
                  << "<td>" << (t.parentTradeId >= 0 ? std::to_string(t.parentTradeId) : "-") << "</td>"
                  << "<td>" << t.buyFee << "</td>"
                  << "<td>" << t.sellFee << "</td>"
                  << "<td>" << t.takeProfit << "</td>"
                  << "<td>" << t.stopLoss << "</td>"
                  << "<td>" << (t.stopLossActive ? "ON" : "OFF") << "</td></tr>\n";
            }
            f << "</table>\n";
        }

        // Horizon Levels
        auto hl = loadAllHorizons();
        f << "<h2>Horizon Levels</h2>\n";
        if (hl.empty()) { f << "<p>(none)</p>\n"; }
        else
        {
            f << "<table><tr><th>Symbol</th><th>Trade</th><th>Level</th>"
              << "<th>TP</th><th>SL</th><th>SL Active</th></tr>\n";
            for (const auto& [sym, tid, lv] : hl)
            {
                f << "<tr><td>" << sym << "</td>"
                  << "<td>" << tid << "</td>"
                  << "<td>" << lv.index << "</td>"
                  << "<td>" << lv.takeProfit << "</td>"
                  << "<td>" << lv.stopLoss << "</td>"
                  << "<td>" << (lv.stopLossActive ? "ON" : "OFF") << "</td></tr>\n";
            }
            f << "</table>\n";
        }

        // Profit History
        auto ph = loadProfitHistory();
        f << "<h2>Profit History</h2>\n";
        if (ph.empty()) { f << "<p>(none)</p>\n"; }
        else
        {
            f << "<table><tr><th>Trade</th><th>Symbol</th><th>Price</th>"
              << "<th>Gross</th><th>Net</th><th>ROI%</th></tr>\n";
            for (const auto& r : ph)
            {
                f << "<tr><td>" << r.tradeId << "</td>"
                  << "<td>" << r.symbol << "</td>"
                  << "<td>" << r.currentPrice << "</td>"
                  << "<td class='" << (r.grossProfit >= 0 ? "pos" : "neg") << "'>"
                  << r.grossProfit << "</td>"
                  << "<td class='" << (r.netProfit >= 0 ? "pos" : "neg") << "'>"
                  << r.netProfit << "</td>"
                  << "<td class='" << (r.roi >= 0 ? "pos" : "neg") << "'>"
                  << r.roi << "%</td></tr>\n";
            }
            f << "</table>\n";
        }

        // Parameter History
        auto pm = loadParamsHistory();
        f << "<h2>Parameter History</h2>\n";
        if (pm.empty()) { f << "<p>(none)</p>\n"; }
        else
        {
            f << std::setprecision(17);
            f << "<table><tr><th>Type</th><th>Symbol</th><th>Trade</th>"
              << "<th>Price</th><th>Qty</th><th>Levels</th>"
              << "<th>BuyF</th><th>SellF</th><th>Hedge</th>"
              << "<th>Pump</th><th>Syms</th><th>K</th>"
              << "<th>Spread</th><th>dt</th><th>Surplus</th></tr>\n";
            for (const auto& r : pm)
            {
                f << "<tr><td>" << r.calcType << "</td>"
                  << "<td>" << r.symbol << "</td>"
                  << "<td>" << (r.tradeId >= 0 ? std::to_string(r.tradeId) : "-") << "</td>"
                  << "<td>" << r.currentPrice << "</td>"
                  << "<td>" << r.quantity << "</td>"
                  << "<td>" << r.horizonCount << "</td>"
                  << "<td>" << r.buyFees << "</td>"
                  << "<td>" << r.sellFees << "</td>"
                  << "<td>" << r.feeHedgingCoefficient << "</td>"
                  << "<td>" << r.portfolioPump << "</td>"
                  << "<td>" << r.symbolCount << "</td>"
                  << "<td>" << r.coefficientK << "</td>"
                  << "<td>" << r.feeSpread << "</td>"
                  << "<td>" << r.deltaTime << "</td>"
                  << "<td>" << r.surplusRate << "</td></tr>\n";
            }
            f << "</table>\n";
        }

        f << "</body></html>\n";
    }

    void exportReport(const std::string& path) const
    {
        std::ofstream f(path, std::ios::trunc);
        if (!f) throw std::runtime_error("Cannot open " + path);

        f << std::fixed << std::setprecision(17);

        f << "====== QUANT TRADE REPORT ======\n\n";

        f << "--- WALLET ---\n";
        double wb = loadWalletBalance();
        double dc = deployedCapital();
        f << "  balance=" << wb
          << "  deployed=" << dc
          << "  total=" << (wb + dc) << "\n";

        f << "\n--- TRADES ---\n";
        auto trades = loadTrades();
        if (trades.empty()) f << "(none)\n";
        for (const auto& t : trades)
        {
            f << "#" << t.tradeId
              << "  " << t.symbol
              << "  " << (t.type == TradeType::Buy ? "BUY" : "COVERED_SELL")
              << "  price=" << t.value
              << "  qty=" << t.quantity;
            if (t.parentTradeId >= 0)
                f << "  parent=#" << t.parentTradeId;
            if (t.buyFee > 0) f << "  buyFee=" << t.buyFee;
            if (t.sellFee > 0) f << "  sellFee=" << t.sellFee;
            f << "  TP=" << t.takeProfit
              << "  SL=" << t.stopLoss
              << (t.stopLossActive ? " [SL ON]" : " [SL OFF]")
              << "\n";
        }

        f << "\n--- HORIZON LEVELS ---\n";
        auto hl = loadAllHorizons();
        if (hl.empty()) f << "(none)\n";
        for (const auto& [sym, tid, lv] : hl)
        {
            f << sym << " #" << tid
              << "  [" << lv.index << "]"
              << "  TP=" << lv.takeProfit
              << "  SL=" << lv.stopLoss
              << (lv.stopLossActive ? " [ON]" : " [OFF]")
              << "\n";
        }

        f << "\n--- PROFIT HISTORY ---\n";
        auto ph = loadProfitHistory();
        if (ph.empty()) f << "(none)\n";
        for (const auto& r : ph)
        {
            f << "#" << r.tradeId
              << "  " << r.symbol
              << "  @" << r.currentPrice
              << "  gross=" << r.grossProfit
              << "  net=" << r.netProfit
              << "  ROI=" << r.roi << "%"
              << "\n";
        }

        f << "\n--- PARAMETER HISTORY ---\n";
        auto pm = loadParamsHistory();
        if (pm.empty()) f << "(none)\n";
        f << std::setprecision(17);
        for (const auto& r : pm)
        {
            f << r.calcType << "  " << r.symbol;
            if (r.tradeId >= 0) f << " #" << r.tradeId;
            f << "  price=" << r.currentPrice
              << " qty=" << r.quantity
              << " levels=" << r.horizonCount
              << " buyF=" << r.buyFees
              << " sellF=" << r.sellFees
              << " hedge=" << r.feeHedgingCoefficient
              << " pump=" << r.portfolioPump
              << " syms=" << r.symbolCount
              << " K=" << r.coefficientK
              << " spread=" << r.feeSpread
              << " dt=" << r.deltaTime
              << " surplus=" << r.surplusRate;
            if (r.calcType == "horizon")
                f << " SL=" << (r.generateStopLosses ? "yes" : "no");
            if (r.calcType == "entry" || r.calcType == "exit")
                f << " risk=" << r.riskCoefficient;
            f << "\n";
        }

        f << "\n====== END OF REPORT ======\n";
    }

    // ---- Parameter Models (named presets) ----

    struct ParamModel
    {
        std::string name;
        int    levels                     = 4;
        double risk                       = 0.5;
        double steepness                  = 6.0;
        double feeHedgingCoefficient      = 1.0;
        double portfolioPump              = 0.0;
        int    symbolCount                = 1;
        double coefficientK               = 0.0;
        double feeSpread                  = 0.0;
        double deltaTime                  = 1.0;
        double surplusRate                = 0.02;
        double maxRisk                    = 0.0;
        double minRisk                    = 0.0;
        bool   isShort                    = false;
        int    fundMode                   = 1;
        bool   generateStopLosses         = false;
        double rangeAbove                 = 0.0;
        double rangeBelow                 = 0.0;
    };

    void saveParamModels(const std::vector<ParamModel>& models)
    {
        std::ofstream f(paramModelsPath(), std::ios::trunc);
        if (!f) throw std::runtime_error("Cannot open " + paramModelsPath());
        for (const auto& m : models)
        {
            f << m.name << ','
              << m.levels << ','
              << std::fixed << std::setprecision(17)
              << m.risk << ','
              << m.steepness << ','
              << m.feeHedgingCoefficient << ','
              << m.portfolioPump << ','
              << m.symbolCount << ','
              << m.coefficientK << ','
              << m.feeSpread << ','
              << m.deltaTime << ','
              << m.surplusRate << ','
              << m.maxRisk << ','
              << m.minRisk << ','
              << m.isShort << ','
              << m.fundMode << ','
              << m.generateStopLosses << ','
              << m.rangeAbove << ','
              << m.rangeBelow
              << '\n';
        }
    }

    std::vector<ParamModel> loadParamModels() const
    {
        std::vector<ParamModel> out;
        std::ifstream f(paramModelsPath());
        if (!f) return out;
        std::string line;
        while (std::getline(f, line))
        {
            if (line.empty()) continue;
            std::istringstream ss(line);
            std::string tok;
            ParamModel m;
            std::getline(ss, m.name, ',');
            if (std::getline(ss, tok, ',') && !tok.empty()) m.levels               = std::stoi(tok);
            if (std::getline(ss, tok, ',') && !tok.empty()) m.risk                 = std::stod(tok);
            if (std::getline(ss, tok, ',') && !tok.empty()) m.steepness            = std::stod(tok);
            if (std::getline(ss, tok, ',') && !tok.empty()) m.feeHedgingCoefficient = std::stod(tok);
            if (std::getline(ss, tok, ',') && !tok.empty()) m.portfolioPump        = std::stod(tok);
            if (std::getline(ss, tok, ',') && !tok.empty()) m.symbolCount          = std::stoi(tok);
            if (std::getline(ss, tok, ',') && !tok.empty()) m.coefficientK         = std::stod(tok);
            if (std::getline(ss, tok, ',') && !tok.empty()) m.feeSpread            = std::stod(tok);
            if (std::getline(ss, tok, ',') && !tok.empty()) m.deltaTime            = std::stod(tok);
            if (std::getline(ss, tok, ',') && !tok.empty()) m.surplusRate          = std::stod(tok);
            if (std::getline(ss, tok, ',') && !tok.empty()) m.maxRisk              = std::stod(tok);
            if (std::getline(ss, tok, ',') && !tok.empty()) m.minRisk              = std::stod(tok);
            if (std::getline(ss, tok, ',') && !tok.empty()) m.isShort              = (std::stoi(tok) != 0);
            if (std::getline(ss, tok, ',') && !tok.empty()) m.fundMode             = std::stoi(tok);
            if (std::getline(ss, tok, ',') && !tok.empty()) m.generateStopLosses   = (std::stoi(tok) != 0);
            if (std::getline(ss, tok, ',') && !tok.empty()) m.rangeAbove           = std::stod(tok);
            if (std::getline(ss, tok, ',') && !tok.empty()) m.rangeBelow           = std::stod(tok);
            out.push_back(m);
        }
        return out;
    }

    void addParamModel(const ParamModel& model)
    {
        auto all = loadParamModels();
        // overwrite if name already exists
        std::erase_if(all, [&](const ParamModel& m) { return m.name == model.name; });
        all.push_back(model);
        saveParamModels(all);
    }

    void removeParamModel(const std::string& name)
    {
        auto all = loadParamModels();
        std::erase_if(all, [&](const ParamModel& m) { return m.name == name; });
        saveParamModels(all);
    }

    const ParamModel* findParamModel(const std::vector<ParamModel>& models,
                                     const std::string& name) const
    {
        for (const auto& m : models)
            if (m.name == name) return &m;
        return nullptr;
    }

    // ---- P&L Ledger ----

    struct PnlEntry
    {
        long long   timestamp    = 0;   // unix seconds
        std::string symbol;
        int         sellTradeId  = 0;
        int         parentTradeId= 0;
        double      entryPrice   = 0.0;
        double      sellPrice    = 0.0;
        double      quantity     = 0.0;
        double      grossProfit  = 0.0;
        double      netProfit    = 0.0;
        double      cumProfit    = 0.0; // cumulative net at this point
    };

    void recordPnl(const std::string& symbol, int sellId, int parentId,
                   double entryPrice, double sellPrice, double qty,
                   double grossProfit, double netProfit)
    {
        // load existing to compute cumulative
        auto history = loadPnl();
        double cum = history.empty() ? 0.0 : history.back().cumProfit;
        cum += netProfit;

        auto now = std::chrono::system_clock::now();
        long long ts = std::chrono::duration_cast<std::chrono::seconds>(
            now.time_since_epoch()).count();

        std::ofstream f(pnlPath(), std::ios::app);
        if (!f) return;
        f << std::fixed << std::setprecision(17)
          << ts << ','
          << symbol << ','
          << sellId << ','
          << parentId << ','
          << entryPrice << ','
          << sellPrice << ','
          << qty << ','
          << grossProfit << ','
          << netProfit << ','
          << cum << '\n';
    }

    std::vector<PnlEntry> loadPnl() const
    {
        std::vector<PnlEntry> out;
        std::ifstream f(pnlPath());
        if (!f) return out;
        std::string line;
        while (std::getline(f, line))
        {
            if (line.empty()) continue;
            std::istringstream ss(line);
            std::string tok;
            PnlEntry e;
            try {
                std::getline(ss, tok, ','); e.timestamp     = std::stoll(tok);
                std::getline(ss, e.symbol, ',');
                std::getline(ss, tok, ','); e.sellTradeId   = std::stoi(tok);
                std::getline(ss, tok, ','); e.parentTradeId = std::stoi(tok);
                std::getline(ss, tok, ','); e.entryPrice    = std::stod(tok);
                std::getline(ss, tok, ','); e.sellPrice     = std::stod(tok);
                std::getline(ss, tok, ','); e.quantity       = std::stod(tok);
                std::getline(ss, tok, ','); e.grossProfit   = std::stod(tok);
                std::getline(ss, tok, ','); e.netProfit     = std::stod(tok);
                std::getline(ss, tok, ','); e.cumProfit     = std::stod(tok);
                out.push_back(e);
            } catch (...) {}
        }
        return out;
    }

    void clearAll()
    {
        std::filesystem::remove(tradesPath());
        std::filesystem::remove(horizonsPath());
        std::filesystem::remove(profitsPath());
        std::filesystem::remove(paramsPath());
        std::filesystem::remove(walletPath());
        std::filesystem::remove(pendingExitsPath());
        std::filesystem::remove(entryPointsPath());
        std::filesystem::remove(releasedPath());
        std::filesystem::remove(paramModelsPath());
        std::filesystem::remove(pnlPath());
    }

private:
    std::string m_dir;

    std::string tradesPath()   const { return m_dir + "/trades.csv"; }
    std::string horizonsPath() const { return m_dir + "/horizons.csv"; }
    std::string profitsPath()  const { return m_dir + "/profits.csv"; }
    std::string paramsPath()   const { return m_dir + "/params.csv"; }
    std::string walletPath()   const { return m_dir + "/wallet.csv"; }
    std::string pendingExitsPath() const { return m_dir + "/pending_exits.csv"; }
    std::string entryPointsPath()  const { return m_dir + "/entry_points.csv"; }
    std::string releasedPath()     const { return m_dir + "/released.csv"; }
    std::string paramModelsPath()  const { return m_dir + "/param_models.csv"; }
    std::string pnlPath()          const { return m_dir + "/pnl.csv"; }

    using HorizonRow = std::tuple<std::string, int, HorizonLevel>;

    std::vector<HorizonRow> loadAllHorizons() const
    {
        std::vector<HorizonRow> out;
        std::ifstream f(horizonsPath());
        if (!f) return out;

        std::string line;
        while (std::getline(f, line))
        {
            if (line.empty()) continue;
            std::istringstream ss(line);
            std::string tok, sym;
            int tid = 0;
            HorizonLevel lv;

            std::getline(ss, sym, ',');
            std::getline(ss, tok, ','); tid              = std::stoi(tok);
            std::getline(ss, tok, ','); lv.index         = std::stoi(tok);
            std::getline(ss, tok, ','); lv.takeProfit    = std::stod(tok);
            std::getline(ss, tok, ','); lv.stopLoss      = std::stod(tok);
            std::getline(ss, tok, ','); lv.stopLossActive = (std::stoi(tok) != 0);

            out.emplace_back(sym, tid, lv);
        }
        return out;
    }

    void saveAllHorizons(const std::vector<HorizonRow>& rows)
    {
        std::ofstream f(horizonsPath(), std::ios::trunc);
        if (!f) throw std::runtime_error("Cannot open " + horizonsPath());

        for (const auto& [sym, tid, lv] : rows)
        {
            f << sym            << ','
              << tid            << ','
              << lv.index       << ','
              << std::fixed << std::setprecision(17)
              << lv.takeProfit  << ','
              << lv.stopLoss    << ','
              << lv.stopLossActive
              << '\n';
        }
    }
};

===== UserManager.h ===== 
#pragma once

#include <string>
#include <vector>
#include <map>
#include <fstream>
#include <sstream>
#include <filesystem>
#include <random>
#include <chrono>
#include <algorithm>
#include <iomanip>
#include <cctype>

class UserManager
{
public:
    struct User
    {
        std::string username;
        std::string passwordHash;
        std::string salt;
        std::string email;
        std::string createdAt;
        bool        premium       = false;
        std::string premiumExpiry;
    };

    explicit UserManager(const std::string& baseDir = "users")
        : m_baseDir(baseDir)
    {
        std::filesystem::create_directories(m_baseDir);
        loadUsers();
        loadPendingPayments();
        ensureAdmin();
    }

    static constexpr const char* adminUser() { return "ADMIN"; }
    static constexpr const char* adminPass() { return "02AdminA!12"; }

    bool isAdmin(const std::string& username) const
    {
        return toLower(username) == toLower(std::string(adminUser()));
    }

    // Register a new user. Returns empty string on success, error message on failure.
    std::string registerUser(const std::string& username, const std::string& password, const std::string& email)
    {
        if (username.empty() || username.size() > 32)
            return "Username must be 1-32 characters";
        if (password.size() < 4)
            return "Password must be at least 4 characters";
        for (char c : username)
            if (!std::isalnum(static_cast<unsigned char>(c)) && c != '_')
                return "Username: only letters, digits, underscores";

        std::string lower = toLower(username);
        for (const auto& u : m_users)
            if (toLower(u.username) == lower)
                return "Username already taken";

        User u;
        u.username     = username;
        u.salt         = generateRandom(32);
        u.passwordHash = hashPassword(password, u.salt);
        u.email        = email;
        u.createdAt    = nowISO();
        u.premium      = false;

        m_users.push_back(u);
        std::filesystem::create_directories(userDbDir(username));
        saveUsers();
        return "";
    }

    bool authenticate(const std::string& username, const std::string& password) const
    {
        for (const auto& u : m_users)
            if (u.username == username)
                return u.passwordHash == hashPassword(password, u.salt);
        return false;
    }

    std::string createSession(const std::string& username)
    {
        std::string token = generateRandom(48);
        m_sessions[token] = username;
        return token;
    }

    std::string getSessionUser(const std::string& token) const
    {
        auto it = m_sessions.find(token);
        return (it != m_sessions.end()) ? it->second : "";
    }

    void destroySession(const std::string& token) { m_sessions.erase(token); }

    std::string userDbDir(const std::string& username) const
    {
        return m_baseDir + "/" + toLower(username) + "/db";
    }

    bool isPremium(const std::string& username) const
    {
        for (const auto& u : m_users)
            if (u.username == username) return u.premium;
        return false;
    }

    void setPremium(const std::string& username, bool val, const std::string& expiry = "")
    {
        for (auto& u : m_users)
            if (u.username == username)
            {
                u.premium = val;
                u.premiumExpiry = expiry;
                saveUsers();
                return;
            }
    }

    static constexpr const char* cookieName() { return "quant_session"; }

    const std::vector<User>& users() const { return m_users; }

    // ---- Pending payments ----
    struct PendingPayment
    {
        std::string username;
        std::string btcAddress;
        double      requiredBtc = 0;
        std::string createdAt;
    };

    void addPendingPayment(const PendingPayment& p)
    {
        m_pendingPayments.push_back(p);
        savePendingPayments();
    }

    PendingPayment* findPendingPayment(const std::string& username)
    {
        for (auto& p : m_pendingPayments)
            if (p.username == username) return &p;
        return nullptr;
    }

    void removePendingPayment(const std::string& username)
    {
        m_pendingPayments.erase(
            std::remove_if(m_pendingPayments.begin(), m_pendingPayments.end(),
                [&](const PendingPayment& p) { return p.username == username; }),
            m_pendingPayments.end());
        savePendingPayments();
    }

    const std::vector<PendingPayment>& pendingPayments() const { return m_pendingPayments; }

private:
    std::string m_path;  // unused legacy
    std::string m_baseDir;
    std::vector<User> m_users;
    std::map<std::string, std::string> m_sessions; // token -> username
    std::vector<PendingPayment> m_pendingPayments;

    std::string usersPath() const { return m_baseDir + "/users.json"; }

    // ---- JSON persistence ----

    static std::string jsonEsc(const std::string& s)
    {
        std::string o;
        for (char c : s)
        {
            if (c == '"')       o += "\\\"";
            else if (c == '\\') o += "\\\\";
            else if (c == '\n') o += "\\n";
            else                o += c;
        }
        return o;
    }

    static std::string jsonUnesc(const std::string& s)
    {
        std::string o;
        for (size_t i = 0; i < s.size(); ++i)
        {
            if (s[i] == '\\' && i + 1 < s.size())
            {
                char next = s[++i];
                if (next == '"')       o += '"';
                else if (next == '\\') o += '\\';
                else if (next == 'n')  o += '\n';
                else { o += '\\'; o += next; }
            }
            else o += s[i];
        }
        return o;
    }

    static std::string jsonGetStr(const std::string& obj, const std::string& key)
    {
        std::string needle = "\"" + key + "\"";
        auto pos = obj.find(needle);
        if (pos == std::string::npos) return "";
        pos = obj.find(':', pos + needle.size());
        if (pos == std::string::npos) return "";
        pos++;
        while (pos < obj.size() && (obj[pos] == ' ' || obj[pos] == '\t' || obj[pos] == '\n' || obj[pos] == '\r')) pos++;
        if (pos >= obj.size()) return "";
        if (obj[pos] == '"')
        {
            pos++;
            auto end = pos;
            while (end < obj.size() && !(obj[end] == '"' && obj[end - 1] != '\\')) end++;
            return jsonUnesc(obj.substr(pos, end - pos));
        }
        auto end = obj.find_first_of(",}\n\r", pos);
        std::string val = obj.substr(pos, end == std::string::npos ? end : end - pos);
        while (!val.empty() && std::isspace(static_cast<unsigned char>(val.back()))) val.pop_back();
        return val;
    }

    void saveUsers() const
    {
        std::ofstream f(usersPath(), std::ios::trunc);
        if (!f) return;
        f << "[\n";
        for (size_t i = 0; i < m_users.size(); ++i)
        {
            const auto& u = m_users[i];
            f << "  {\n"
              << "    \"username\": \""     << jsonEsc(u.username)     << "\",\n"
              << "    \"passwordHash\": \"" << jsonEsc(u.passwordHash) << "\",\n"
              << "    \"salt\": \""         << jsonEsc(u.salt)         << "\",\n"
              << "    \"email\": \""        << jsonEsc(u.email)        << "\",\n"
              << "    \"createdAt\": \""    << jsonEsc(u.createdAt)    << "\",\n"
              << "    \"premium\": "        << (u.premium ? "true" : "false") << ",\n"
              << "    \"premiumExpiry\": \"" << jsonEsc(u.premiumExpiry) << "\"\n"
              << "  }" << (i + 1 < m_users.size() ? "," : "") << "\n";
        }
        f << "]\n";
    }

    void loadUsers()
    {
        m_users.clear();
        std::ifstream f(usersPath());
        if (!f) return;
        std::string content((std::istreambuf_iterator<char>(f)), std::istreambuf_iterator<char>());

        size_t pos = 0;
        while ((pos = content.find('{', pos)) != std::string::npos)
        {
            auto end = content.find('}', pos);
            if (end == std::string::npos) break;
            std::string obj = content.substr(pos, end - pos + 1);

            User u;
            u.username     = jsonGetStr(obj, "username");
            u.passwordHash = jsonGetStr(obj, "passwordHash");
            u.salt         = jsonGetStr(obj, "salt");
            u.email        = jsonGetStr(obj, "email");
            u.createdAt    = jsonGetStr(obj, "createdAt");
            u.premium      = jsonGetStr(obj, "premium") == "true";
            u.premiumExpiry = jsonGetStr(obj, "premiumExpiry");

            if (!u.username.empty())
                m_users.push_back(u);

            pos = end + 1;
        }
    }

    // ---- Hashing ----

    static std::string hashPassword(const std::string& password, const std::string& salt)
    {
        std::string input = salt + password + salt;
        size_t h1 = 0x6a09e667, h2 = 0xbb67ae85, h3 = 0x3c6ef372, h4 = 0xa54ff53a;
        for (int round = 0; round < 5000; ++round)
        {
            h1 = std::hash<std::string>{}(input + std::to_string(h1) + std::to_string(round));
            h2 = std::hash<std::string>{}(input + std::to_string(h2) + std::to_string(h1));
            h3 = std::hash<std::string>{}(input + std::to_string(h3) + std::to_string(h2));
            h4 = std::hash<std::string>{}(input + std::to_string(h4) + std::to_string(h3));
        }
        std::ostringstream ss;
        ss << std::hex << std::setfill('0')
           << std::setw(16) << h1 << std::setw(16) << h2
           << std::setw(16) << h3 << std::setw(16) << h4;
        return ss.str();
    }

    // ---- Utilities ----

    static std::string generateRandom(int length)
    {
        static const char chars[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        static thread_local std::mt19937 rng(
            static_cast<unsigned>(std::chrono::steady_clock::now().time_since_epoch().count()));
        std::uniform_int_distribution<int> dist(0, sizeof(chars) - 2);
        std::string s;
        s.reserve(length);
        for (int i = 0; i < length; ++i) s += chars[dist(rng)];
        return s;
    }

    static std::string toLower(const std::string& s)
    {
        std::string r = s;
        for (auto& c : r) c = static_cast<char>(std::tolower(static_cast<unsigned char>(c)));
        return r;
    }

    static std::string nowISO()
    {
        auto now = std::chrono::system_clock::now();
        auto t = std::chrono::system_clock::to_time_t(now);
        std::tm tm{};
#ifdef _WIN32
        localtime_s(&tm, &t);
#else
        localtime_r(&t, &tm);
#endif
        std::ostringstream ss;
        ss << std::put_time(&tm, "%Y-%m-%dT%H:%M:%S");
        return ss.str();
    }

    // ---- Admin seed ----

    void ensureAdmin()
    {
        std::string lower = toLower(std::string(adminUser()));
        for (const auto& u : m_users)
            if (toLower(u.username) == lower) return;
        User u;
        u.username     = adminUser();
        u.salt         = generateRandom(32);
        u.passwordHash = hashPassword(std::string(adminPass()), u.salt);
        u.createdAt    = nowISO();
        u.premium      = true;
        m_users.push_back(u);
        std::filesystem::create_directories(userDbDir(u.username));
        saveUsers();
    }

    // ---- Pending payment persistence ----

    std::string pendingPath() const { return m_baseDir + "/pending_payments.json"; }

    void savePendingPayments() const
    {
        std::ofstream f(pendingPath(), std::ios::trunc);
        if (!f) return;
        f << "[\n";
        for (size_t i = 0; i < m_pendingPayments.size(); ++i)
        {
            const auto& p = m_pendingPayments[i];
            f << "  {\n"
              << "    \"username\": \""    << jsonEsc(p.username)   << "\",\n"
              << "    \"btcAddress\": \""  << jsonEsc(p.btcAddress) << "\",\n"
              << "    \"requiredBtc\": "   << std::fixed << std::setprecision(8) << p.requiredBtc << ",\n"
              << "    \"createdAt\": \""   << jsonEsc(p.createdAt)  << "\"\n"
              << "  }" << (i + 1 < m_pendingPayments.size() ? "," : "") << "\n";
        }
        f << "]\n";
    }

    void loadPendingPayments()
    {
        m_pendingPayments.clear();
        std::ifstream f(pendingPath());
        if (!f) return;
        std::string content((std::istreambuf_iterator<char>(f)), std::istreambuf_iterator<char>());
        size_t pos = 0;
        while ((pos = content.find('{', pos)) != std::string::npos)
        {
            auto end = content.find('}', pos);
            if (end == std::string::npos) break;
            std::string obj = content.substr(pos, end - pos + 1);
            PendingPayment p;
            p.username    = jsonGetStr(obj, "username");
            p.btcAddress  = jsonGetStr(obj, "btcAddress");
            std::string rb = jsonGetStr(obj, "requiredBtc");
            try { p.requiredBtc = std::stod(rb); } catch (...) { p.requiredBtc = 0; }
            p.createdAt   = jsonGetStr(obj, "createdAt");
            if (!p.username.empty())
                m_pendingPayments.push_back(p);
            pos = end + 1;
        }
    }
};
===== Quant.cpp ===== 
#include <iostream>
#include <iomanip>
#include <string>
#include <sstream>
#include <limits>
#include <algorithm>

#include "Trade.h"
#include "ProfitCalculator.h"
#include "MultiHorizonEngine.h"
#include "MarketEntryCalculator.h"
#include "ExitStrategyCalculator.h"
#include "TradeDatabase.h"
#include "HttpApi.h"

#include <thread>
#include <mutex>

static void printSep() { std::cout << "----------------------------------------\n"; }

static void clearInput()
{
    std::cin.clear();
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
}

static double readDouble(const char* prompt)
{
    double v;
    while (true)
    {
        std::cout << prompt;
        if (std::cin >> v) return v;
        std::cout << "  Invalid number, try again.\n";
        clearInput();
    }
}

static double readDouble(const std::string& prompt) { return readDouble(prompt.c_str()); }

static int readInt(const char* prompt)
{
    int v;
    while (true)
    {
        std::cout << prompt;
        if (std::cin >> v) return v;
        std::cout << "  Invalid number, try again.\n";
        clearInput();
    }
}

static int readInt(const std::string& prompt) { return readInt(prompt.c_str()); }

static std::string readSymbol(const char* prompt)
{
    std::string s;
    std::cout << prompt;
    std::cin >> s;
    return normalizeSymbol(s);
}

static std::string readSymbol(const std::string& prompt) { return readSymbol(prompt.c_str()); }

static std::string readString(const char* prompt)
{
    std::string s;
    std::cout << prompt;
    std::cin >> s;
    return s;
}

static std::string readString(const std::string& prompt) { return readString(prompt.c_str()); }

static HorizonParams readHorizonParams(const char* levelsPrompt = "  How many levels: ")
{
HorizonParams p;
if (levelsPrompt)
{
    p.horizonCount = readInt(levelsPrompt);
    if (p.horizonCount < 1) p.horizonCount = 1;
}
else
{
    p.horizonCount = 1;
}
p.feeHedgingCoefficient = readDouble("  Fee hedging coefficient: ");
    p.portfolioPump         = readDouble("  Portfolio pump (t): ");
    p.symbolCount           = readInt("  Symbol count in portfolio: ");
    if (p.symbolCount < 1) p.symbolCount = 1;
    p.coefficientK          = readDouble("  Coefficient K: ");
    p.feeSpread             = readDouble("  Fee spread / slippage: ");
    p.deltaTime             = readDouble("  Delta time: ");
    p.surplusRate           = readDouble("  Surplus rate (profit margin, e.g. 0.02 = 2%): ");
    return p;
}

// Exit strategy params: no pump (not injecting capital), no batch fees (per-exit)
static HorizonParams readExitParams()
{
    HorizonParams p;
    p.horizonCount          = 1;
    p.feeHedgingCoefficient = readDouble("  Fee hedging coefficient: ");
    p.symbolCount           = readInt("  Symbol count in portfolio: ");
    if (p.symbolCount < 1) p.symbolCount = 1;
    p.coefficientK          = readDouble("  Coefficient K: ");
    p.feeSpread             = readDouble("  Fee spread / slippage: ");
    p.deltaTime             = readDouble("  Delta time: ");
    p.surplusRate           = readDouble("  Surplus rate (profit margin, e.g. 0.02 = 2%): ");
    return p;
}

static void printOverhead(double overhead, double surplusRate, double posDelta)
{
    double eo = overhead + surplusRate;
    std::cout << std::fixed << std::setprecision(6)
              << "  overhead ratio  = " << overhead
              << "  (" << (overhead * 100.0) << "% cost per level)\n"
              << "  surplus rate    = " << surplusRate
              << "  (" << (surplusRate * 100.0) << "% profit margin)\n"
              << "  effective rate  = " << eo
              << "  (" << (eo * 100.0) << "% per level)\n"
              << "  position delta  = " << posDelta
              << "  (" << (posDelta * 100.0) << "% of portfolio)\n";
}

// ---- Menu actions ----

static void listTrades(TradeDatabase& db)
{
    auto trades  = db.loadTrades();
    if (trades.empty()) { std::cout << "  (no trades)\n"; return; }

    auto pending = db.loadPendingExits();

    std::cout << std::fixed << std::setprecision(2);

    // show Buy trades first, with children and pending exits indented underneath
    for (const auto& t : trades)
    {
        if (t.type != TradeType::Buy) continue;

        double sold      = db.soldQuantityForParent(t.tradeId);
        double remaining = t.quantity - sold;

        std::cout << "  #" << t.tradeId
                  << "  " << t.symbol
                  << "  BUY"
                  << "  price=" << t.value
                  << "  qty=" << t.quantity
                  << "  TP=" << t.takeProfit
                  << "  SL=" << t.stopLoss
                  << (t.stopLossActive ? " [SL ON]" : " [SL OFF]");
        if (sold > 0.0)
            std::cout << "  sold=" << sold
                      << "  remaining=" << remaining;
        std::cout << '\n';

        // show executed child CoveredSell trades
        for (const auto& c : trades)
        {
            if (c.parentTradeId != t.tradeId) continue;
            double exitPnl = (c.value - t.value) * c.quantity;
            std::cout << "    -> #" << c.tradeId
                      << "  EXIT"
                      << "  price=" << c.value
                      << "  qty=" << c.quantity
                      << "  P&L=" << exitPnl
                      << " (" << ((c.value - t.value) / t.value * 100.0) << "%)\n";
        }

        // show pending exit orders for this trade
        for (const auto& pe : pending)
        {
            if (pe.tradeId != t.tradeId) continue;
            double pctGain = ((pe.triggerPrice - t.value) / t.value) * 100.0;
            std::cout << "    .. order#" << pe.orderId
                      << "  PENDING EXIT"
                      << "  trigger=" << pe.triggerPrice
                      << "  (+" << pctGain << "%)"
                      << "  qty=" << pe.sellQty
                      << "  [" << pe.levelIndex << "]\n";
        }
    }

    // show orphan CoveredSells (parent deleted or missing)
    for (const auto& t : trades)
    {
        if (t.type != TradeType::CoveredSell) continue;
        bool hasParent = false;
        for (const auto& p : trades)
            if (p.tradeId == t.parentTradeId && p.type == TradeType::Buy)
            { hasParent = true; break; }
        if (hasParent) continue;

        std::cout << "  #" << t.tradeId
                  << "  " << t.symbol
                  << "  COVERED_SELL"
                  << "  price=" << t.value
                  << "  qty=" << t.quantity
                  << "  parent=#" << t.parentTradeId << " (missing)\n";
    }
}

static void addTrade(TradeDatabase& db)
{
    Trade t;
    t.tradeId = db.nextTradeId();
    t.symbol  = readSymbol("  Symbol: ");

    int typeChoice = readInt("  Type (0=Buy, 1=CoveredSell): ");
    t.type = (typeChoice == 1) ? TradeType::CoveredSell : TradeType::Buy;

    t.value    = readDouble("  Entry price per unit: ");
    if (t.value <= 0.0) { std::cout << "  Price must be positive.\n"; return; }
    t.quantity = readDouble("  Quantity: ");
    if (t.quantity <= 0.0) { std::cout << "  Quantity must be positive.\n"; return; }

    if (t.type == TradeType::CoveredSell)
    {
        std::cout << "  Available parent Buy trades:\n";
        auto trades = db.loadTrades();
        for (const auto& bt : trades)
            if (bt.isParent())
            {
                double sold = db.soldQuantityForParent(bt.tradeId);
                std::cout << "    #" << bt.tradeId << "  " << bt.symbol
                          << "  qty=" << bt.quantity
                          << "  already sold=" << sold
                          << "  remaining=" << (bt.quantity - sold) << '\n';
            }
        t.parentTradeId = readInt("  Parent trade ID: ");

        auto* parent = db.findTradeById(trades, t.parentTradeId);
        if (!parent || !parent->isParent())
        {
            std::cout << "  Invalid parent trade.\n";
            return;
        }
        double remaining = parent->quantity - db.soldQuantityForParent(parent->tradeId);
        if (t.quantity > remaining)
        {
            std::cout << "  Cannot sell " << t.quantity
                      << ", only " << remaining << " remaining.\n";
            return;
        }
        t.symbol = parent->symbol;
    }

    t.stopLossActive = false;
    t.shortEnabled   = false;

    db.addTrade(t);
    std::cout << "  -> Trade #" << t.tradeId << " saved.\n";
}

static void deleteTrade(TradeDatabase& db)
{
    listTrades(db);
    int id = readInt("  Trade ID to delete: ");
    auto trades = db.loadTrades();
    auto* tp = db.findTradeById(trades, id);
    if (!tp) { std::cout << "  Trade not found.\n"; return; }

    if (tp->isParent())
    {
        bool hasChildren = false;
        for (const auto& t : trades)
            if (t.parentTradeId == id) { hasChildren = true; break; }
        if (hasChildren)
            std::cout << "  Warning: child CoveredSell trades will also be deleted.\n";
    }

    db.removeTrade(id);
    std::cout << "  -> Deleted.\n";
}

static void editTrade(TradeDatabase& db)
{
    listTrades(db);
    int id = readInt("  Trade ID: ");

    auto trades = db.loadTrades();
    auto* tp = db.findTradeById(trades, id);
    if (!tp) { std::cout << "  Trade not found.\n"; return; }

    std::cout << "  Enter new values (enter 0 to keep current):\n";
    std::cout << std::fixed << std::setprecision(2);

    auto newSym = readSymbol("  Symbol [" + tp->symbol + "]: ");
    if (newSym != "0") tp->symbol = newSym;

    int newType = readInt("  Type 0=Buy 1=CoveredSell [-1=keep]: ");
    if (newType >= 0) tp->type = (newType == 1) ? TradeType::CoveredSell : TradeType::Buy;

    double v;
    v = readDouble("  Entry price [" + std::to_string(tp->value) + "]: ");
    if (v != 0) tp->value = v;

    v = readDouble("  Quantity [" + std::to_string(tp->quantity) + "]: ");
    if (v != 0) tp->quantity = v;

    if (tp->type == TradeType::CoveredSell)
    {
        int pid = readInt("  Parent trade ID [" + std::to_string(tp->parentTradeId) + "] (-1=keep): ");
        if (pid >= 0) tp->parentTradeId = pid;
    }

    v = readDouble("  Take profit [" + std::to_string(tp->takeProfit) + "]: ");
    if (v != 0) tp->takeProfit = v;

    v = readDouble("  Stop loss [" + std::to_string(tp->stopLoss) + "]: ");
    if (v != 0) tp->stopLoss = v;

    db.updateTrade(*tp);
    std::cout << "  -> Trade #" << tp->tradeId << " updated.\n";
}

static void calculateProfit(TradeDatabase& db)
{
    listTrades(db);
    int id = readInt("  Trade ID: ");

    auto trades = db.loadTrades();
    auto* tp = db.findTradeById(trades, id);
    if (!tp) { std::cout << "  Trade not found.\n"; return; }

    double cur      = readDouble("  Current market price: ");
    double buyFees  = readDouble("  Buy fees: ");
    double sellFees = readDouble("  Sell fees: ");
    auto r = ProfitCalculator::calculate(*tp, cur, buyFees, sellFees);
    db.saveProfitSnapshot(tp->symbol, id, cur, r);

    std::cout << std::fixed << std::setprecision(2);
    std::cout << "  Gross profit : " << r.grossProfit << '\n';
    std::cout << "  Net profit   : " << r.netProfit << '\n';
    std::cout << "  ROI          : " << r.roi << "%\n";
    std::cout << "  (snapshot saved)\n";
}

static void generateHorizons(TradeDatabase& db)
{
    auto trades = db.loadTrades();

    // collect symbols that have Buy trades
    std::vector<std::string> symbols;
    for (const auto& t : trades)
        if (t.type == TradeType::Buy &&
            std::find(symbols.begin(), symbols.end(), t.symbol) == symbols.end())
            symbols.push_back(t.symbol);

    if (symbols.empty()) { std::cout << "  (no Buy trades)\n"; return; }

    std::cout << "  Symbols with Buy trades:\n";
    for (const auto& sym : symbols)
    {
        int count = 0;
        for (const auto& t : trades)
            if (t.symbol == sym && t.type == TradeType::Buy) ++count;
        std::cout << "    " << sym << "  (" << count << " trades)\n";
    }

    auto sym = readSymbol("  Symbol to generate horizons for: ");

    std::vector<Trade*> buyTrades;
    for (auto& t : trades)
        if (t.symbol == sym && t.type == TradeType::Buy)
            buyTrades.push_back(&t);

    if (buyTrades.empty())
    {
        std::cout << "  No Buy trades for " << sym << ".\n";
        return;
    }

    std::cout << std::fixed << std::setprecision(2);
    for (const auto* bt : buyTrades)
    {
        std::cout << "    #" << bt->tradeId
                  << "  price=" << bt->value
                  << "  qty=" << bt->quantity
                  << "  cost=" << (bt->value * bt->quantity) << '\n';
    }

    std::cout << "  Enter trade IDs to include (comma-separated, or 0 for all): ";
    {
        clearInput();
        std::string line;
        std::getline(std::cin, line);

        if (line.find('0') == std::string::npos || line.size() > 1)
        {
            std::vector<int> selected;
            std::istringstream ss(line);
            std::string tok;
            while (std::getline(ss, tok, ','))
            {
                try { selected.push_back(std::stoi(tok)); }
                catch (...) {}
            }

            if (!selected.empty())
            {
                std::erase_if(buyTrades, [&](const Trade* bt) {
                    return std::find(selected.begin(), selected.end(), bt->tradeId) == selected.end();
                });
            }
        }
    }

    if (buyTrades.empty())
    {
        std::cout << "  No trades selected.\n";
        return;
    }

    std::cout << "  Selected " << buyTrades.size() << " trade(s) -> "
              << buyTrades.size() << " TP/SL level(s).\n";

    HorizonParams p = readHorizonParams(nullptr);

    int genSL = readInt("  Generate stop losses? (0=no, 1=yes): ");
    p.generateStopLosses = (genSL == 1);

    // compute total cost of all selected trades to budget the pump fairly
    double totalCost = 0.0;
    for (const auto* bt : buyTrades)
        totalCost += bt->value * bt->quantity;

    double walletBal    = db.loadWalletBalance();
    double pumpBudget   = p.portfolioPump;
    double fundingCap   = pumpBudget + walletBal;
    double remainingCap = fundingCap;

    std::cout << std::fixed << std::setprecision(2);
    std::cout << "  Pump budget: " << pumpBudget
              << "  Wallet: " << walletBal
              << "  Funding cap: " << fundingCap << "\n\n";

    for (auto* bt : buyTrades)
    {
        double originalQty = bt->quantity;
        double maxFundable = (bt->value > 0.0) ? remainingCap / bt->value : 0.0;
        double fundedQty   = MultiHorizonEngine::fundedQuantity(bt->value, p);
        if (fundedQty > maxFundable)
        {
            std::cout << "  Trade #" << bt->tradeId
                      << "  funded qty capped: " << fundedQty
                      << " -> " << maxFundable
                      << " (remaining cap=" << remainingCap << ")\n";
            fundedQty = maxFundable;
        }
        double fundedCost = fundedQty * bt->value;
        remainingCap -= fundedCost;
        if (remainingCap < 0.0) remainingCap = 0.0;
        bt->quantity += fundedQty;

        auto levels = MultiHorizonEngine::generate(*bt, p);
        MultiHorizonEngine::applyFirstHorizon(*bt, levels, false);
        db.updateTrade(*bt);
        db.saveHorizonLevels(sym, bt->tradeId, levels);

        std::cout << "  Trade #" << bt->tradeId
                  << "  price=" << bt->value
                  << "  qty=" << originalQty;
        if (fundedQty > 0.0)
            std::cout << " + funded " << fundedQty
                      << " = " << bt->quantity;
        std::cout << '\n';

        for (const auto& lv : levels)
        {
            double tpPerUnit = lv.takeProfit / bt->quantity;
            double slPerUnit = (lv.stopLoss > 0.0) ? lv.stopLoss / bt->quantity : 0.0;
            std::cout << "    [" << lv.index << "]"
                      << "  TP=" << lv.takeProfit
                      << " (" << tpPerUnit << "/unit)"
                      << "  SL=" << lv.stopLoss;
            if (slPerUnit > 0.0)
                std::cout << " (" << slPerUnit << "/unit)";
            std::cout << (lv.stopLossActive ? " [ON]" : " [OFF]")
                      << '\n';
        }

        db.saveParamsSnapshot(
            TradeDatabase::ParamsRow::from("horizon", sym, bt->tradeId,
                                           bt->value, bt->quantity, p));
    }

    std::cout << "  -> Saved to DB for " << buyTrades.size()
              << " trades. SL is OFF by default.\n";
}

static void viewHorizons(TradeDatabase& db)
{
    auto sym = readSymbol("  Symbol (or trade ID with #, e.g. #5): ");

    auto trades = db.loadTrades();

    // if user typed a number, treat as trade ID for backward compat
    std::vector<HorizonLevel> levels;
    std::string displayLabel;

    bool foundById = false;
    if (!sym.empty())
    {
        // try to find a trade with this symbol
        for (const auto& t : trades)
        {
            if (t.symbol == sym && t.type == TradeType::Buy)
            {
                levels = db.loadHorizonLevels(sym, t.tradeId);
                if (!levels.empty())
                {
                    displayLabel = sym + " (from trade #" + std::to_string(t.tradeId) + ")";
                    foundById = true;
                    break;
                }
            }
        }
    }

    if (!foundById)
    {
        // fallback: ask for trade ID
        int id = readInt("  Trade ID: ");
        auto* tp = db.findTradeById(trades, id);
        if (!tp) { std::cout << "  Trade not found.\n"; return; }
        levels = db.loadHorizonLevels(tp->symbol, id);
        displayLabel = tp->symbol + " #" + std::to_string(id);
    }

    if (levels.empty()) { std::cout << "  (no levels)\n"; return; }

    std::cout << "  Horizons for " << displayLabel << ":\n";
    std::cout << std::fixed << std::setprecision(2);
    for (const auto& lv : levels)
    {
        std::cout << "    [" << lv.index << "]"
                  << "  TP=" << lv.takeProfit
                  << "  SL=" << lv.stopLoss
                  << (lv.stopLossActive ? " [ON]" : " [OFF]")
                  << '\n';
    }
}

static void toggleStopLoss(TradeDatabase& db)
{
    listTrades(db);
    int id = readInt("  Trade ID: ");

    auto trades = db.loadTrades();
    auto* tp = db.findTradeById(trades, id);
    if (!tp) { std::cout << "  Trade not found.\n"; return; }

    tp->stopLossActive = !tp->stopLossActive;
    db.updateTrade(*tp);
    std::cout << "  -> SL is now " << (tp->stopLossActive ? "ON" : "OFF") << "\n";
}

static void portfolioSummary(TradeDatabase& db)
{
    auto trades = db.loadTrades();
    if (trades.empty()) { std::cout << "  (no trades)\n"; return; }

    double totalCost = 0.0;
    int buyCount = 0, sellCount = 0;

    std::cout << std::fixed << std::setprecision(2);
    std::cout << "  Symbol summary:\n";

    // group by symbol
    std::vector<std::string> seen;
    for (const auto& t : trades)
    {
        if (std::find(seen.begin(), seen.end(), t.symbol) != seen.end()) continue;
        seen.push_back(t.symbol);

        double symCost = 0.0;
        double symQty  = 0.0;
        int buys = 0, sells = 0;
        for (const auto& u : trades)
        {
            if (u.symbol != t.symbol) continue;
            if (u.type == TradeType::Buy)
            {
                symCost += u.value * u.quantity;
                symQty  += u.quantity;
                ++buys;
            }
            else { ++sells; }
        }
        std::cout << "    " << t.symbol
                  << "  buys=" << buys << " sells=" << sells
                  << "  total_qty=" << symQty
                  << "  total_cost=" << symCost << '\n';
        totalCost += symCost;
        buyCount  += buys;
        sellCount += sells;
    }

    std::cout << "  --------\n";
    std::cout << "  Total: " << buyCount << " buys, "
              << sellCount << " sells, cost=" << totalCost << '\n';

    double walBal = db.loadWalletBalance();
    if (walBal != 0.0 || totalCost != 0.0)
    {
        std::cout << "  Wallet: liquid=" << walBal
                  << "  deployed=" << totalCost
                  << "  total=" << (walBal + totalCost) << '\n';
    }
}

static void viewProfitHistory(TradeDatabase& db)
{
    auto rows = db.loadProfitHistory();
    if (rows.empty()) { std::cout << "  (no history)\n"; return; }

    std::cout << std::fixed << std::setprecision(2);
    for (const auto& r : rows)
    {
        std::cout << "  #" << r.tradeId
                  << "  " << r.symbol
                  << "  @" << r.currentPrice
                  << "  gross=" << r.grossProfit
                  << "  net=" << r.netProfit
                  << "  ROI=" << r.roi << "%"
                  << '\n';
    }
}

static void marketEntry(TradeDatabase& db)
{
    double walletBal = db.loadWalletBalance();
    std::cout << std::fixed << std::setprecision(2);
    std::cout << "  Wallet liquid balance: " << walletBal << "\n\n";

    auto sym     = readSymbol("  Symbol: ");
    double cur   = readDouble("  Current market price: ");
    double qty   = readDouble("  Quantity you plan to buy: ");

    HorizonParams p = readHorizonParams("  How many entry levels: ");

    int fundMode = readInt("  Funding source (1=pump only, 2=pump + liquid balance): ");
    double availableFunds = p.portfolioPump;
    if (fundMode == 2)
    {
        availableFunds += walletBal;
        std::cout << "  Available funds: " << p.portfolioPump
                  << " (pump) + " << walletBal
                  << " (liquid) = " << availableFunds << "\n";
    }
    else
    {
        std::cout << "  Available funds: " << availableFunds << " (pump only)\n";
    }

    double risk = readDouble("  Risk coefficient (0=low risk, 1=high risk): ");
    int shortTrade = readInt("  Short trade? (0=no/long, 1=yes/short): ");
    bool isShort = (shortTrade == 1);

    // use availableFunds for entry level generation
    HorizonParams entryParams = p;
    entryParams.portfolioPump = availableFunds;

    auto levels = MarketEntryCalculator::generate(cur, qty, entryParams, risk);
    double eo = MultiHorizonEngine::effectiveOverhead(cur, qty, p);

    db.saveParamsSnapshot(
        TradeDatabase::ParamsRow::from("entry", sym, -1, cur, qty, p, risk));

    printOverhead(MultiHorizonEngine::computeOverhead(cur, qty, p), p.surplusRate,
                  MultiHorizonEngine::positionDelta(cur, qty, p.portfolioPump));

    std::cout << std::fixed << std::setprecision(2);
    std::cout << "\n  " << sym << " @ " << cur
              << "  qty=" << qty
              << "  funds=" << availableFunds
              << "  risk=" << risk << "\n";
    std::cout << "  Entry levels (best entry points below current price):\n\n";

    for (const auto& el : levels)
    {
        double discount = ((cur - el.entryPrice) / cur) * 100.0;
        std::cout << "    [" << el.index << "]\n"
                  << "        entry price      = " << el.entryPrice
                  << "  (" << discount << "% below market)\n"
                  << "        break-even price = " << el.breakEven
                  << "  (min price to recover all fees + overhead)\n"
                  << "        potential profit = " << el.potentialNet
                  << "  (net gain if price returns to " << cur << " after fees)\n"
                  << "        funding          = " << el.funding
                  << " of " << availableFunds
                  << "  (" << (el.fundingFraction * 100.0) << "% of total funds)\n"
                  << "        buys             = " << el.fundingQty
                  << " units at this entry price\n"
                  << "        cost coverage    = " << el.costCoverage
                  << "x  (layers of overhead baked into this entry)\n";
    }

    // Build entry points with linked exit TP/SL
    int nextEpId = db.nextEntryId();
    std::vector<TradeDatabase::EntryPoint> entryPoints;
    for (const auto& el : levels)
    {
        TradeDatabase::EntryPoint ep;
        ep.symbol             = sym;
        ep.entryId            = nextEpId++;
        ep.levelIndex         = el.index;
        ep.entryPrice         = el.entryPrice;
        ep.breakEven          = el.breakEven;
        ep.funding            = el.funding;
        ep.fundingQty         = el.fundingQty;
        ep.effectiveOverhead  = eo;
        ep.isShort            = isShort;
        if (isShort)
        {
            ep.exitTakeProfit = el.entryPrice * (1.0 - eo);
            ep.exitStopLoss   = el.entryPrice * (1.0 + eo);
        }
        else
        {
            ep.exitTakeProfit = el.entryPrice * (1.0 + eo);
            ep.exitStopLoss   = el.entryPrice * (1.0 - eo);
        }
        entryPoints.push_back(ep);
    }

    int confirm = readInt("\n  Execute this entry strategy? (1=yes, 0=no): ");
    if (confirm == 1)
    {
        // deposit the pump capital into wallet before executing buys
        if (p.portfolioPump > 0.0)
        {
            db.deposit(p.portfolioPump);
            std::cout << "  -> Deposited pump " << p.portfolioPump
                      << " into wallet. Balance: " << db.loadWalletBalance() << "\n";
        }

        std::cout << "\n  Enter buy fees for each entry:\n";
        std::cout << std::fixed << std::setprecision(2);
        for (size_t i = 0; i < levels.size(); ++i)
        {
            double buyQty = (levels[i].fundingQty > 0.0) ? levels[i].fundingQty : 0.0;
            if (buyQty <= 0.0) continue;

            double cost = levels[i].entryPrice * buyQty;
            std::ostringstream fp;
            fp << std::fixed << std::setprecision(2)
               << "    [" << levels[i].index << "] " << buyQty
               << " @ " << levels[i].entryPrice
               << " (cost=" << cost << ")  buy fee: ";
            double buyFee = readDouble(fp.str());

            double walBal = db.loadWalletBalance();
            double totalNeeded = cost + buyFee;
            if (totalNeeded > walBal)
            {
                double maxQty = (levels[i].entryPrice > 0.0)
                    ? (walBal - buyFee) / levels[i].entryPrice : 0.0;
                if (maxQty <= 0.0)
                {
                    std::cout << "    [" << levels[i].index
                              << "] SKIPPED: insufficient funds (need "
                              << totalNeeded << ", have " << walBal << ")\n";
                    continue;
                }
                std::cout << "    [" << levels[i].index
                          << "] capped: " << buyQty << " -> " << maxQty
                          << " (wallet=" << walBal << ")\n";
                buyQty = maxQty;
                cost   = levels[i].entryPrice * buyQty;
            }

            int bid = db.executeBuy(sym, levels[i].entryPrice, buyQty);
            if (buyFee > 0.0)
                db.withdraw(buyFee);

            entryPoints[i].traded        = true;
            entryPoints[i].linkedTradeId = bid;

            auto trades = db.loadTrades();
            auto* tradePtr = db.findTradeById(trades, bid);
            if (tradePtr)
            {
                tradePtr->takeProfit     = entryPoints[i].exitTakeProfit * tradePtr->quantity;
                tradePtr->stopLoss       = entryPoints[i].exitStopLoss * tradePtr->quantity;
                tradePtr->stopLossActive = false;
                db.updateTrade(*tradePtr);
            }

            std::cout << "    -> Buy #" << bid
                      << "  " << buyQty << " @ " << levels[i].entryPrice
                      << "  fee=" << buyFee
                      << "  TP=" << entryPoints[i].exitTakeProfit
                      << "  SL=" << entryPoints[i].exitStopLoss
                      << "  (funded " << levels[i].funding << ")\n";
        }
        std::cout << "  -> Entry orders created. Wallet debited (including fees).\n";
    }

    auto existingEp = db.loadEntryPoints();
    for (const auto& ep : entryPoints) existingEp.push_back(ep);
    db.saveEntryPoints(existingEp);
    std::cout << "  -> " << entryPoints.size() << " entry points saved.\n";
}

static void viewParams(TradeDatabase& db)
{
    auto rows = db.loadParamsHistory();
    if (rows.empty()) { std::cout << "  (no parameter history)\n"; return; }

    std::cout << std::fixed << std::setprecision(4);
    int idx = 0;
    for (const auto& r : rows)
    {
        std::cout << "  [" << idx++ << "] " << r.calcType
                  << "  " << r.symbol;
        if (r.tradeId >= 0)
            std::cout << "  trade=#" << r.tradeId;
        std::cout << "\n"
                  << "      price=" << r.currentPrice
                  << "  qty=" << r.quantity
                  << "  levels=" << r.horizonCount << "\n"
                  << "      buyFees=" << r.buyFees
                  << "  sellFees=" << r.sellFees
                  << "  hedging=" << r.feeHedgingCoefficient << "\n"
                  << "      pump=" << r.portfolioPump
                  << "  symbols=" << r.symbolCount << "\n"
                  << "      K=" << r.coefficientK
                  << "  spread=" << r.feeSpread
                  << "  dt=" << r.deltaTime
                  << "  surplus=" << r.surplusRate << "\n";
        if (r.calcType == "horizon")
            std::cout << "      stopLosses=" << (r.generateStopLosses ? "yes" : "no") << "\n";
        if (r.calcType == "entry" || r.calcType == "exit")
            std::cout << "      risk=" << r.riskCoefficient << "\n";
    }
}

static void exitStrategy(TradeDatabase& db)
{
    listTrades(db);

    std::cout << "  Trade IDs (comma-separated): ";
    clearInput();
    std::string line;
    std::getline(std::cin, line);

    std::vector<int> ids;
    {
        std::istringstream ss(line);
        std::string tok;
        while (std::getline(ss, tok, ','))
        {
            try { ids.push_back(std::stoi(tok)); }
            catch (...) {}
        }
    }

    if (ids.empty()) { std::cout << "  No trade IDs entered.\n"; return; }

    auto trades = db.loadTrades();
    std::vector<Trade*> selected;
    for (int id : ids)
    {
        auto* tp = db.findTradeById(trades, id);
        if (!tp) { std::cout << "  Trade #" << id << " not found.\n"; continue; }
        if (tp->type != TradeType::Buy) { std::cout << "  #" << id << " is not a Buy trade.\n"; continue; }
        selected.push_back(tp);
    }

    if (selected.empty()) { std::cout << "  No valid Buy trades selected.\n"; return; }

    std::cout << "  Selected " << selected.size() << " trade(s) -> "
              << selected.size() << " exit level(s).\n";

    HorizonParams p = readExitParams();

    double risk     = readDouble("  Risk coefficient (0=sell early, 1=hold for deeper): ");
    double exitFrac = readDouble("  Exit fraction (0.0-1.0, e.g. 0.5 = sell 50%): ");
    double steep    = readDouble("  Sigmoid steepness (0=uniform, 4=smooth S, 10+=step): ");

    std::cout << std::fixed << std::setprecision(2);
    std::cout << "\n";

    // First pass: generate and display exit levels per trade
    struct TradeExit {
        Trade* tp;
        std::vector<ExitLevel> levels;
        double sellableQty;
        double remaining;
    };
    std::vector<TradeExit> tradeExits;

    // load pending exits to account for already-reserved qty
    auto existingPending = db.loadPendingExits();

    for (auto* tp : selected)
    {
        double sold = db.soldQuantityForParent(tp->tradeId);
        double pendingQty = 0.0;
        for (const auto& pe : existingPending)
            if (pe.tradeId == tp->tradeId)
                pendingQty += pe.sellQty;

        double remaining = tp->quantity - sold - pendingQty;
        if (remaining <= 0.0)
        {
            std::cout << "  #" << tp->tradeId << "  " << tp->symbol
                      << "  fully committed (sold=" << sold
                      << " pending=" << pendingQty << "), skipping.\n";
            continue;
        }

        // generate exits based on remaining qty, not total qty
        Trade tempTrade = *tp;
        tempTrade.quantity = remaining;

        auto levels = ExitStrategyCalculator::generate(tempTrade, p, risk, exitFrac, steep);
        double clampedFrac = (exitFrac < 0.0) ? 0.0 : (exitFrac > 1.0) ? 1.0 : exitFrac;
        double sellableQty = remaining * clampedFrac;

        std::cout << "  Exit for #" << tp->tradeId
                  << "  " << tp->symbol
                  << "  entry=" << tp->value
                  << "  total_qty=" << tp->quantity
                  << "  sold=" << sold
                  << "  pending=" << pendingQty
                  << "  available=" << remaining
                  << "  selling=" << sellableQty
                  << " (" << (clampedFrac * 100.0) << "%)\n";

        for (const auto& el : levels)
        {
            double pctGain = ((el.tpPrice - tp->value) / tp->value) * 100.0;
            std::cout << "    [" << el.index << "]"
                      << "  trigger=" << el.tpPrice
                      << "  (+" << pctGain << "%)"
                      << "  sell=" << el.sellQty
                      << "  value=" << el.sellValue << "\n";
        }
        std::cout << "    remaining after exit = " << (remaining - sellableQty) << "\n\n";

        tradeExits.push_back({tp, levels, sellableQty, remaining});
    }

    if (tradeExits.empty())
    {
        std::cout << "  No trades with available quantity.\n";
        return;
    }

    // Second pass: ask sell fees per trade exit and recalculate net
    std::cout << "  Enter sell fees for each exit:\n";
    std::vector<TradeDatabase::PendingExit> allOrders;
    int nextId = db.nextPendingId();
    double totalNet = 0.0;

    for (auto& te : tradeExits)
    {
        for (auto& el : te.levels)
        {
            if (el.sellQty <= 0.0) continue;

            std::ostringstream exitInfo;
            exitInfo << std::fixed << std::setprecision(2)
                     << "    #" << te.tp->tradeId
                     << " sell " << el.sellQty
                     << " @ " << el.tpPrice
                     << " (value=" << el.sellValue << ")";
            std::cout << exitInfo.str() << "\n";
            double buyFee  = readDouble("      Buy fee (original, proportional): ");
            double sellFee = readDouble("      Sell fee: ");

            el.netProfit    = el.grossProfit - buyFee - sellFee;
            totalNet       += el.netProfit;

            std::cout << "      -> gross=" << el.grossProfit
                      << "  buyFee=" << buyFee
                      << "  sellFee=" << sellFee
                      << "  net=" << el.netProfit << "\n";

            TradeDatabase::PendingExit pe;
            pe.symbol       = te.tp->symbol;
            pe.orderId      = nextId++;
            pe.tradeId      = te.tp->tradeId;
            pe.triggerPrice = el.tpPrice;
            pe.sellQty      = el.sellQty;
            pe.levelIndex   = el.index;
            allOrders.push_back(pe);
        }

        db.saveParamsSnapshot(
            TradeDatabase::ParamsRow::from("exit", te.tp->symbol, te.tp->tradeId,
                                           te.tp->value, te.tp->quantity, p, risk));
    }

    std::cout << "\n  Total net across all exits: " << totalNet << "\n";
    std::cout << "  (params saved)\n";

    if (!allOrders.empty())
    {
        double cur = readDouble("\n  Current market price: ");

        // split into immediately executable vs pending
        std::vector<TradeDatabase::PendingExit> hitOrders;
        std::vector<TradeDatabase::PendingExit> pendingOrders;
        for (const auto& pe : allOrders)
        {
            if (cur >= pe.triggerPrice)
                hitOrders.push_back(pe);
            else
                pendingOrders.push_back(pe);
        }

        // execute exits that have already hit their trigger
        if (!hitOrders.empty())
        {
            std::cout << "\n  " << hitOrders.size()
                      << " exit(s) already at or above trigger price:\n";
            for (const auto& pe : hitOrders)
            {
                std::cout << "    order#" << pe.orderId
                          << "  #" << pe.tradeId
                          << "  trigger=" << pe.triggerPrice
                          << "  qty=" << pe.sellQty
                          << "  << HIT\n";
            }
            int exec = readInt("  Execute these now? (1=yes, 0=save as pending): ");
            if (exec == 1)
            {
                for (const auto& pe : hitOrders)
                {
                    int sid = db.executeSell(pe.symbol, pe.triggerPrice, pe.sellQty);
                    if (sid >= 0)
                        std::cout << "    -> CoveredSell #" << sid
                                  << "  " << pe.sellQty << " @ " << pe.triggerPrice << "\n";
                    else
                        std::cout << "    -> Failed " << pe.symbol
                                  << " (insufficient holdings)\n";
                }
                std::cout << "  -> Executed. Wallet credited.\n";
            }
            else
            {
                // user chose not to execute, move to pending
                for (const auto& pe : hitOrders)
                    pendingOrders.push_back(pe);
            }
        }

        // save remaining as pending orders
        if (!pendingOrders.empty())
        {
            std::cout << "\n  " << pendingOrders.size()
                      << " exit(s) not yet triggered (price below trigger):\n";
            for (const auto& pe : pendingOrders)
            {
                double away = pe.triggerPrice - cur;
                std::cout << "    order#" << pe.orderId
                          << "  #" << pe.tradeId
                          << "  trigger=" << pe.triggerPrice
                          << "  qty=" << pe.sellQty
                          << "  (" << away << " away)\n";
            }
            int confirm = readInt("  Save as pending exit orders? (1=yes, 0=no): ");
            if (confirm == 1)
            {
                db.addPendingExits(pendingOrders);
                std::cout << "  -> " << pendingOrders.size()
                          << " pending exit orders saved.\n";
            }
        }
        else if (hitOrders.empty())
        {
            std::cout << "  (no exits to save)\n";
        }
    }
}

static void priceCheck(TradeDatabase& db)
{
    auto trades = db.loadTrades();
    bool anyBuy = false;
    for (const auto& t : trades)
        if (t.type == TradeType::Buy) { anyBuy = true; break; }
    if (!anyBuy) { std::cout << "  (no Buy trades)\n"; return; }

    // collect unique symbols and ask market price per symbol
    std::vector<std::string> symbols;
    for (const auto& t : trades)
        if (t.type == TradeType::Buy &&
            std::find(symbols.begin(), symbols.end(), t.symbol) == symbols.end())
            symbols.push_back(t.symbol);

    std::vector<std::pair<std::string, double>> symbolPrices;
    for (const auto& sym : symbols)
    {
        double price = readDouble(("  Current market price for " + sym + ": ").c_str());
        symbolPrices.push_back({sym, price});
    }

    auto priceForSymbol = [&](const std::string& sym) -> double {
        for (const auto& sp : symbolPrices)
            if (sp.first == sym) return sp.second;
        return 0.0;
    };

    std::cout << std::fixed << std::setprecision(2);
    std::cout << '\n';

    struct Trigger { int tradeId; std::string symbol; double price; double qty; std::string tag; };
    std::vector<Trigger> triggers;

    for (const auto& t : trades)
    {
        if (t.type != TradeType::Buy) continue;

        double remaining = t.quantity - db.soldQuantityForParent(t.tradeId);
        if (remaining <= 0.0) continue;

        double cur = priceForSymbol(t.symbol);

        double cost = t.value * remaining;
        std::cout << "  #" << t.tradeId << "  " << t.symbol
                  << "  entry=" << t.value << "  qty=" << remaining
                  << "  cost=" << cost
                  << "  market=" << cur << "\n";
        double buyFees  = readDouble("    Buy fee: ");
        double sellFees = readDouble("    Sell fee: ");

        auto r = ProfitCalculator::calculate(t, cur, buyFees, sellFees);

        std::cout << "    net=" << r.netProfit << "  ROI=" << r.roi << "%";

        // trade-level TP/SL
        if (t.takeProfit > 0.0)
        {
            double tpPrice = t.takeProfit / t.quantity;
            if (cur >= tpPrice)
            {
                std::cout << "  ** TP HIT (" << tpPrice << ") **";
                triggers.push_back({t.tradeId, t.symbol, cur, remaining, "TP"});
            }
        }
        if (t.stopLossActive && t.stopLoss > 0.0)
        {
            double slPrice = t.stopLoss / t.quantity;
            if (cur <= slPrice)
            {
                std::cout << "  !! SL BREACHED (" << slPrice << ") !!";
                triggers.push_back({t.tradeId, t.symbol, cur, remaining, "SL"});
            }
        }
        std::cout << '\n';

        // horizon levels
        auto levels = db.loadHorizonLevels(t.symbol, t.tradeId);
        if (levels.empty()) continue;

        for (const auto& lv : levels)
        {
            double tpPrice = lv.takeProfit / t.quantity;
            bool tpHit = (cur >= tpPrice);

            std::cout << "    [" << lv.index << "]  TP=" << lv.takeProfit
                      << " (" << tpPrice << "/unit)";
            if (tpHit)
            {
                double tpProfit = (cur - tpPrice) * t.quantity;
                std::cout << "  >> EXCEEDED  surplus=" << tpProfit;
            }
            else
            {
                std::cout << "  -- " << (tpPrice - cur) << " away";
            }

            if (lv.stopLoss != 0.0)
            {
                double slPrice = lv.stopLoss / t.quantity;
                bool slHit = (cur <= slPrice);
                std::cout << "  |  SL=" << lv.stopLoss
                          << " (" << slPrice << "/unit)";
                if (lv.stopLossActive)
                {
                    if (slHit)
                        std::cout << "  !! BREACHED";
                    else
                        std::cout << "  -- " << (cur - slPrice) << " above";
                }
                else
                {
                    std::cout << "  [OFF]";
                }
            }
            std::cout << '\n';
        }
    }

    if (!triggers.empty())
    {
        std::cout << "\n  Triggered:\n";
        for (size_t i = 0; i < triggers.size(); ++i)
        {
            const auto& tr = triggers[i];
            std::cout << "    [" << i << "] " << tr.tag
                      << " #" << tr.tradeId << "  " << tr.symbol
                      << "  qty=" << tr.qty << "  @ " << tr.price << "\n";
        }
        int exec = readInt("  Execute all triggered sells? (1=yes, 0=no): ");
        if (exec == 1)
        {
            for (const auto& tr : triggers)
            {
                int sid = db.executeSell(tr.symbol, tr.price, tr.qty);
                if (sid >= 0)
                    std::cout << "    -> CoveredSell #" << sid
                              << "  " << tr.qty << " @ " << tr.price << "\n";
                else
                    std::cout << "    -> Sell failed for " << tr.symbol << "\n";
            }
            std::cout << "  -> Executed. Wallet credited.\n";
        }
    }

    // ---- Pending exit orders ----
    auto pending = db.loadPendingExits();
    std::vector<TradeDatabase::PendingExit> triggered;
    for (const auto& pe : pending)
    {
        double cur = priceForSymbol(pe.symbol);
        if (cur >= pe.triggerPrice)
            triggered.push_back(pe);
    }

    if (!triggered.empty())
    {
        std::cout << "\n  Pending exits triggered:\n";
        for (const auto& pe : triggered)
        {
            double cur = priceForSymbol(pe.symbol);
            std::cout << "    order#" << pe.orderId
                      << "  " << pe.symbol << " #" << pe.tradeId
                      << "  [" << pe.levelIndex << "]"
                      << "  trigger=" << pe.triggerPrice
                      << "  market=" << cur
                      << "  qty=" << pe.sellQty << "\n";
        }
        int exec = readInt("  Execute triggered pending exits? (1=yes, 0=no): ");
        if (exec == 1)
        {
            for (const auto& pe : triggered)
            {
                double cur = priceForSymbol(pe.symbol);
                int sid = db.executeSell(pe.symbol, cur, pe.sellQty);
                if (sid >= 0)
                {
                    std::cout << "    -> CoveredSell #" << sid
                              << "  " << pe.sellQty << " @ " << cur
                              << "  (trigger was " << pe.triggerPrice << ")\n";
                    db.removePendingExit(pe.orderId);
                }
                else
                {
                    std::cout << "    -> Sell failed for " << pe.symbol
                              << " (insufficient holdings)\n";
                }
            }
            std::cout << "  -> Pending exits executed. Wallet credited.\n";
        }
    }
}

static void wipeDatabaseMenu(TradeDatabase& db)
{
    int c = readInt("  Are you sure? (1=yes, 0=no): ");
    if (c == 1) { db.clearAll(); std::cout << "  -> Database wiped.\n"; }
}

// ---- Replay params ----

static void replayParams(TradeDatabase& db)
{
    auto rows = db.loadParamsHistory();
    if (rows.empty()) { std::cout << "  (no parameter history)\n"; return; }

    std::cout << std::fixed << std::setprecision(2);
    for (int i = 0; i < static_cast<int>(rows.size()); ++i)
    {
        const auto& r = rows[i];
        std::cout << "  [" << i << "] " << r.calcType << "  " << r.symbol;
        if (r.tradeId >= 0) std::cout << " #" << r.tradeId;
        std::cout << "  levels=" << r.horizonCount << '\n';
    }

    int idx = readInt("  Replay which entry: ");
    if (idx < 0 || idx >= static_cast<int>(rows.size()))
    {
        std::cout << "  Invalid index.\n";
        return;
    }

    const auto& src = rows[idx];
    HorizonParams p = src.toHorizonParams();

    if (src.calcType == "horizon")
    {
        auto trades = db.loadTrades();
        auto* tp = db.findTradeById(trades, src.tradeId);
        if (!tp) { std::cout << "  Original trade #" << src.tradeId << " no longer exists.\n"; return; }

        auto levels = MultiHorizonEngine::generate(*tp, p);
        MultiHorizonEngine::applyFirstHorizon(*tp, levels, false);
        db.updateTrade(*tp);
        db.saveHorizonLevels(tp->symbol, tp->tradeId, levels);

        TradeDatabase::ParamsRow pr = src;
        db.saveParamsSnapshot(pr);

        std::cout << std::fixed << std::setprecision(2);
        std::cout << "  Replayed horizon for " << tp->symbol << " #" << tp->tradeId << ":\n";
        for (const auto& lv : levels)
        {
            std::cout << "    [" << lv.index << "]"
                      << "  TP=" << lv.takeProfit
                      << "  SL=" << lv.stopLoss
                      << (lv.stopLossActive ? " [ON]" : " [OFF]")
                      << '\n';
        }
        std::cout << "  -> Saved to DB.\n";
    }
    else if (src.calcType == "exit")
    {
        auto trades = db.loadTrades();
        auto* tp = db.findTradeById(trades, src.tradeId);
        if (!tp) { std::cout << "  Original trade #" << src.tradeId << " no longer exists.\n"; return; }

        double risk = src.riskCoefficient;
        auto levels = ExitStrategyCalculator::generate(*tp, p, risk, 1.0, 4.0);

        TradeDatabase::ParamsRow pr = src;
        db.saveParamsSnapshot(pr);

        std::cout << std::fixed << std::setprecision(2);
        std::cout << "  Replayed exit for " << tp->symbol << " #" << tp->tradeId << ":\n\n";
        for (const auto& el : levels)
        {
            std::cout << "    [" << el.index << "]"
                      << "  sell@" << el.tpPrice
                      << "  qty=" << el.sellQty
                      << " (" << (el.sellFraction * 100.0) << "%)"
                      << "  net=" << el.netProfit
                      << '\n';
        }
    }
    else // entry
    {
        double risk = src.riskCoefficient;
        auto levels = MarketEntryCalculator::generate(src.currentPrice, src.quantity, p, risk);

        TradeDatabase::ParamsRow pr = src;
        db.saveParamsSnapshot(pr);

        std::cout << std::fixed << std::setprecision(2);
        std::cout << "  Replayed entry for " << src.symbol << " @ " << src.currentPrice << ":\n\n";
        for (const auto& el : levels)
        {
            double discount = ((src.currentPrice - el.entryPrice) / src.currentPrice) * 100.0;
            std::cout << "    [" << el.index << "]"
                      << "  entry=" << el.entryPrice
                      << "  (" << discount << "% below)"
                      << "  fund=" << el.funding
                      << " (" << (el.fundingFraction * 100.0) << "%)"
                      << '\n';
        }
    }
}

// ---- DCA tracker ----

static void dcaTracker(TradeDatabase& db)
{
    auto trades = db.loadTrades();
    if (trades.empty()) { std::cout << "  (no trades)\n"; return; }

    std::cout << std::fixed << std::setprecision(2);
    std::cout << "  DCA (Dollar Cost Average) per symbol:\n\n";

    std::vector<std::string> seen;
    for (const auto& t : trades)
    {
        if (t.type != TradeType::Buy) continue;
        if (std::find(seen.begin(), seen.end(), t.symbol) != seen.end()) continue;
        seen.push_back(t.symbol);

        double totalCost = 0.0;
        double totalQty  = 0.0;
        int    count     = 0;
        double minPrice  = 1e18, maxPrice = 0.0;

        for (const auto& u : trades)
        {
            if (u.symbol != t.symbol || u.type != TradeType::Buy) continue;
            totalCost += u.value * u.quantity;
            totalQty  += u.quantity;
            if (u.value < minPrice) minPrice = u.value;
            if (u.value > maxPrice) maxPrice = u.value;
            ++count;
        }

        double avgPrice = (totalQty != 0.0) ? totalCost / totalQty : 0.0;

        std::cout << "    " << t.symbol << "\n"
                  << "        buy trades     = " << count << "\n"
                  << "        total quantity = " << totalQty << "\n"
                  << "        total cost     = " << totalCost << "\n"
                  << "        avg entry (DCA)= " << avgPrice << "\n"
                  << "        lowest entry   = " << minPrice << "\n"
                  << "        highest entry  = " << maxPrice << "\n"
                  << "        spread         = " << (maxPrice - minPrice) << "\n\n";
    }
}

// ---- Unrealized P&L dashboard ----

static void unrealizedPnl(TradeDatabase& db)
{
    auto trades = db.loadTrades();
    if (trades.empty()) { std::cout << "  (no trades)\n"; return; }

    std::vector<std::string> symbols;
    for (const auto& t : trades)
        if (t.type == TradeType::Buy &&
            std::find(symbols.begin(), symbols.end(), t.symbol) == symbols.end())
            symbols.push_back(t.symbol);

    if (symbols.empty()) { std::cout << "  (no Buy trades)\n"; return; }

    std::cout << std::fixed << std::setprecision(2);
    std::cout << "\n  Unrealized P&L:\n\n";

    double grandCost = 0.0, grandValue = 0.0, grandNet = 0.0;

    for (const auto& sym : symbols)
    {
        double curPrice = readDouble(("  Current price for " + sym + ": ").c_str());

        double symCost = 0.0, symQty = 0.0, symNet = 0.0;
        for (const auto& t : trades)
        {
            if (t.symbol != sym || t.type != TradeType::Buy) continue;

            double cost = t.value * t.quantity;
            std::cout << "    #" << t.tradeId << "  entry=" << t.value
                      << "  qty=" << t.quantity << "  cost=" << cost << "\n";
            double buyFees  = readDouble("      Buy fee: ");
            double sellFees = readDouble("      Sell fee: ");

            auto r = ProfitCalculator::calculate(t, curPrice, buyFees, sellFees);
            symCost += t.value * t.quantity;
            symQty  += t.quantity;
            symNet  += r.netProfit;
        }

        double symValue = curPrice * symQty;
        double symRoi   = (symCost != 0.0) ? (symNet / symCost) * 100.0 : 0.0;

        std::cout << "    " << sym
                  << "  qty=" << symQty
                  << "  cost=" << symCost
                  << "  value=" << symValue
                  << "  unrealized=" << symNet
                  << "  ROI=" << symRoi << "%\n";

        grandCost  += symCost;
        grandValue += symValue;
        grandNet   += symNet;
    }

    double grandRoi = (grandCost != 0.0) ? (grandNet / grandCost) * 100.0 : 0.0;
    std::cout << "    --------\n"
              << "    TOTAL"
              << "  cost=" << grandCost
              << "  value=" << grandValue
              << "  unrealized=" << grandNet
              << "  ROI=" << grandRoi << "%\n";
}

// ---- Export report ----

static void exportReport(TradeDatabase& db)
{
    int fmt = readInt("  Format (1=text, 2=HTML): ");
    if (fmt == 2)
    {
        auto path = readString("  Export file path (e.g. report.html): ");
        db.exportHtmlReport(path);
        std::cout << "  -> HTML report exported to " << path << "\n";
    }
    else
    {
        auto path = readString("  Export file path (e.g. report.txt): ");
        db.exportReport(path);
        std::cout << "  -> Text report exported to " << path << "\n";
    }
}

// ---- Duplicate trade ----

static void duplicateTrade(TradeDatabase& db)
{
    listTrades(db);
    int id = readInt("  Trade ID to duplicate: ");

    auto trades = db.loadTrades();
    auto* src = db.findTradeById(trades, id);
    if (!src) { std::cout << "  Trade not found.\n"; return; }

    Trade t = *src;
    t.tradeId      = db.nextTradeId();
    t.takeProfit   = 0.0;
    t.stopLoss     = 0.0;
    t.stopLossActive = false;

    db.addTrade(t);
    std::cout << "  -> Duplicated as trade #" << t.tradeId
              << " (" << t.symbol << " " << (t.type == TradeType::Buy ? "BUY" : "COVERED_SELL")
              << " price=" << t.value << " qty=" << t.quantity << ")\n";
}

// ---- Wallet ----

static void walletMenu(TradeDatabase& db)
{
    std::cout << std::fixed << std::setprecision(2);
    double balance  = db.loadWalletBalance();
    double deployed = db.deployedCapital();
    double total    = balance + deployed;

    std::cout << "  Wallet:\n"
              << "    liquid balance   = " << balance << "\n"
              << "    deployed capital = " << deployed << "\n"
              << "    total capital    = " << total << "\n\n";

    int c = readInt("  1=Deposit  2=Withdraw  0=Back: ");
    if (c == 1)
    {
        double amt = readDouble("  Deposit amount: ");
        if (amt <= 0.0) { std::cout << "  Amount must be positive.\n"; return; }
        db.deposit(amt);
        std::cout << "  -> Deposited " << amt
                  << ". Balance: " << db.loadWalletBalance() << "\n";
    }
    else if (c == 2)
    {
        double amt = readDouble("  Withdraw amount: ");
        if (amt <= 0.0) { std::cout << "  Amount must be positive.\n"; return; }
        if (amt > balance)
        {
            std::cout << "  Cannot withdraw " << amt
                      << ", only " << balance << " available.\n";
            return;
        }
        db.withdraw(amt);
        std::cout << "  -> Withdrew " << amt
                  << ". Balance: " << db.loadWalletBalance() << "\n";
    }
}

// ---- Pending exits ----

static void viewPendingExits(TradeDatabase& db)
{
    auto orders = db.loadPendingExits();
    if (orders.empty()) { std::cout << "  (no pending exit orders)\n"; return; }

    std::cout << std::fixed << std::setprecision(2);
    std::cout << "  Pending exit orders:\n";
    for (const auto& pe : orders)
    {
        std::cout << "    order#" << pe.orderId
                  << "  " << pe.symbol << " #" << pe.tradeId
                  << "  [" << pe.levelIndex << "]"
                  << "  trigger=" << pe.triggerPrice
                  << "  qty=" << pe.sellQty << "\n";
    }

    int c = readInt("  1=Clear all  2=Remove one  3=Execute  0=Back: ");
    if (c == 1)
    {
        db.savePendingExits({});
        std::cout << "  -> All pending exits cleared.\n";
    }
    else if (c == 2)
    {
        int oid = readInt("  Order ID to remove: ");
        db.removePendingExit(oid);
        std::cout << "  -> Removed order#" << oid << ".\n";
    }
    else if (c == 3)
    {
        std::cout << "  Order IDs to execute (comma-separated, or 0 for all): ";
        clearInput();
        std::string line;
        std::getline(std::cin, line);

        bool execAll = (line == "0");
        std::vector<int> execIds;
        if (!execAll)
        {
            std::istringstream ss(line);
            std::string tok;
            while (std::getline(ss, tok, ','))
            {
                try { execIds.push_back(std::stoi(tok)); }
                catch (...) {}
            }
        }

        double cur = readDouble("  Current market price: ");

        std::cout << std::fixed << std::setprecision(2);
        int executed = 0;
        int skipped  = 0;
        for (const auto& pe : orders)
        {
            if (!execAll &&
                std::find(execIds.begin(), execIds.end(), pe.orderId) == execIds.end())
                continue;

            if (cur < pe.triggerPrice)
            {
                std::cout << "    -- order#" << pe.orderId
                          << "  trigger=" << pe.triggerPrice
                          << " not reached (" << (pe.triggerPrice - cur) << " away)\n";
                ++skipped;
                continue;
            }

            int sid = db.executeSell(pe.symbol, pe.triggerPrice, pe.sellQty);
            if (sid >= 0)
            {
                std::cout << "    -> CoveredSell #" << sid
                          << "  " << pe.sellQty << " @ " << pe.triggerPrice
                          << "  (order#" << pe.orderId << ")\n";
                db.removePendingExit(pe.orderId);
                ++executed;
            }
            else
            {
                std::cout << "    -> Failed " << pe.symbol
                          << " (insufficient holdings)\n";
            }
        }
        if (skipped > 0)
            std::cout << "  " << skipped << " order(s) skipped (trigger not reached).\n";
        std::cout << "  -> Executed " << executed << " exit order(s) at trigger prices. Wallet credited.\n";
    }
}

// ---- Entry points ----

static void viewEntryPoints(TradeDatabase& db)
{
    auto points = db.loadEntryPoints();
    if (points.empty()) { std::cout << "  (no entry points)\n"; return; }

    std::cout << std::fixed << std::setprecision(2);
    for (const auto& ep : points)
    {
        std::cout << "  [" << ep.entryId << "]"
                  << "  " << ep.symbol
                  << "  lvl=" << ep.levelIndex
                  << "  entry=" << ep.entryPrice
                  << "  BE=" << ep.breakEven
                  << "  qty=" << ep.fundingQty
                  << (ep.isShort ? " SHORT" : " LONG")
                  << (ep.traded ? " [TRADED]" : " [OPEN]");
        if (ep.traded)
        {
            std::cout << "  TP=" << ep.exitTakeProfit
                      << "  SL=" << ep.exitStopLoss
                      << (ep.stopLossActive ? " [SL ON]" : " [SL OFF]");
            if (ep.linkedTradeId >= 0)
                std::cout << "  trade=#" << ep.linkedTradeId;
        }
        else
        {
            std::cout << "  exitTP=" << ep.exitTakeProfit
                      << "  exitSL=" << ep.exitStopLoss;
        }
        std::cout << '\n';
    }
}

static void markEntryTraded(TradeDatabase& db)
{
    auto points = db.loadEntryPoints();
    if (points.empty()) { std::cout << "  (no entry points)\n"; return; }

    std::cout << std::fixed << std::setprecision(2);
    std::cout << "  Open entry points:\n";
    bool anyOpen = false;
    for (const auto& ep : points)
    {
        if (ep.traded) continue;
        anyOpen = true;
        std::cout << "    [" << ep.entryId << "]"
                  << "  " << ep.symbol
                  << "  lvl=" << ep.levelIndex
                  << "  entry=" << ep.entryPrice
                  << "  qty=" << ep.fundingQty
                  << (ep.isShort ? " SHORT" : " LONG")
                  << "  exitTP=" << ep.exitTakeProfit
                  << "  exitSL=" << ep.exitStopLoss
                  << '\n';
    }
    if (!anyOpen) { std::cout << "  (all entry points already traded)\n"; return; }

    int id = readInt("  Entry ID to mark as traded: ");

    TradeDatabase::EntryPoint* target = nullptr;
    for (auto& ep : points)
        if (ep.entryId == id) { target = &ep; break; }

    if (!target) { std::cout << "  Entry point not found.\n"; return; }
    if (target->traded) { std::cout << "  Already marked as traded.\n"; return; }

    target->traded = true;

    int slActive = readInt("  Activate stop-loss? (0=no, 1=yes): ");
    target->stopLossActive = (slActive == 1);

    int createTrade = readInt("  Create a Buy trade for this entry? (1=yes, 0=no): ");
    if (createTrade == 1)
    {
        int tid = db.executeBuy(target->symbol, target->entryPrice, target->fundingQty);
        target->linkedTradeId = tid;

        auto trades = db.loadTrades();
        auto* tp = db.findTradeById(trades, tid);
        if (tp)
        {
            tp->takeProfit     = target->exitTakeProfit * tp->quantity;
            tp->stopLoss       = target->exitStopLoss * tp->quantity;
            tp->stopLossActive = target->stopLossActive;
            db.updateTrade(*tp);
        }
        std::cout << "  -> Trade #" << tid << " created. Wallet debited.\n";
    }

    db.saveEntryPoints(points);

    std::cout << std::fixed << std::setprecision(2);
    std::cout << "  -> Entry [" << target->entryId << "] marked as TRADED.\n"
              << "     " << (target->isShort ? "SHORT" : "LONG")
              << "  entry=" << target->entryPrice
              << "  TP=" << target->exitTakeProfit
              << "  SL=" << target->exitStopLoss
              << (target->stopLossActive ? " [SL ON]" : " [SL OFF]") << '\n';
}

// ---- Main ----

int main()
{
    TradeDatabase db("db");
    std::mutex dbMutex;

    // Start HTTP API on a background thread
    int httpPort = 8080;
    std::thread httpThread([&]() {
        startHttpApi(db, httpPort, dbMutex);
        });
    httpThread.detach();

    bool running = true;
    while (running)
    {
        std::cout << "\n";
        printSep();
        std::cout << "  QUANT TRADE MANAGER\n";
        printSep();
        std::cout << "   1) List trades\n";
        std::cout << "   2) Add trade\n";
        std::cout << "   3) Edit trade\n";
        std::cout << "   4) Delete trade\n";
        std::cout << "   5) Duplicate trade\n";
        std::cout << "   6) Calculate profit\n";
        std::cout << "   7) Generate TP/SL horizons\n";
        std::cout << "   8) View horizons\n";
        std::cout << "   9) Toggle stop-loss on/off\n";
        std::cout << "  10) DCA tracker\n";
        std::cout << "  11) Portfolio summary\n";
        std::cout << "  12) Unrealized P&L\n";
        std::cout << "  13) Profit history\n";
        std::cout << "  14) Price check (TP/SL vs market)\n";
        std::cout << "  15) Market entry calculator\n";
        std::cout << "  16) Exit strategy\n";
        std::cout << "  17) Parameter history\n";
        std::cout << "  18) Replay params\n";
        std::cout << "  19) Export report\n";
        std::cout << "  20) Wallet\n";
        std::cout << "  21) Pending exit orders\n";
        std::cout << "  22) Wipe database\n";
        std::cout << "  23) View entry points\n";
        std::cout << "  24) Mark entry as traded\n";
        std::cout << "   0) Exit\n";
        printSep();

        int choice = readInt("  > ");

        std::cout << '\n';
        switch (choice)
        {
        case 1:  listTrades(db);         break;
        case 2:  addTrade(db);           break;
        case 3:  editTrade(db);          break;
        case 4:  deleteTrade(db);        break;
        case 5:  duplicateTrade(db);     break;
        case 6:  calculateProfit(db);    break;
        case 7:  generateHorizons(db);   break;
        case 8:  viewHorizons(db);       break;
        case 9:  toggleStopLoss(db);     break;
        case 10: dcaTracker(db);         break;
        case 11: portfolioSummary(db);   break;
        case 12: unrealizedPnl(db);      break;
        case 13: viewProfitHistory(db);  break;
        case 14: priceCheck(db);         break;
        case 15: marketEntry(db);        break;
        case 16: exitStrategy(db);        break;
        case 17: viewParams(db);         break;
        case 18: replayParams(db);       break;
        case 19: exportReport(db);       break;
        case 20: walletMenu(db);         break;
        case 21: viewPendingExits(db);   break;
        case 22: wipeDatabaseMenu(db);   break;
        case 23: viewEntryPoints(db);    break;
        case 24: markEntryTraded(db);    break;
        case 0:  running = false;        break;
        default: std::cout << "  Invalid choice.\n"; break;
        }
    }

    return 0;

}
